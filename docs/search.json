{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "description": "Some additional details about the website",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-23T15:38:51-03:00"
    },
    {
      "path": "colaboradores.html",
      "title": "Colaboradores",
      "description": "Exclusivo para a Semana Universitária",
      "author": [],
      "contents": "\r\n\r\nContents\r\nThiago\r\nLappicy\r\nSaulo\r\nAires de Souza\r\nLuiz Felipe Pereira de\r\nBrito\r\n\r\nApesar deste curso ser uma iniciativa do grupo Água e Modelagem,\r\ncontamos com a participação exclusiva para a Semana Universtária da UnB\r\nde dois integrantes:\r\nThiago Lappicy\r\nThiago Lappicy é aluno de mestrado do Programa de Engenharia Civil e\r\nAmbiental da Universidade de Brasília (PTARH/UnB).\r\nSaulo Aires de Souza\r\nSaulo é Coordenador de Estudos Hidrológicos da Agência Nacional de\r\nÁguas\r\nLuiz Felipe Pereira de Brito\r\nLuiz Felipe é aluno do curso de Engenharia Ambiental da Universidade\r\nde Brasília\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-23T15:38:52-03:00"
    },
    {
      "path": "conc_basic_R.html",
      "title": "Linguagem R",
      "description": "Conceitos básicos para o curso",
      "author": [],
      "contents": "\r\n\r\nContents\r\nVisão geral do R e RStudio\r\nO\r\nque é a linguagem R\r\nPorque usar o R em\r\nHidrologia?\r\nInstalação do programa\r\nInterface do R e RStudio\r\n\r\nPrimeiros passos, comandos no\r\nR\r\nCriação de\r\nvariáveis e atribuição de valores\r\n\r\nObjetos do R\r\nClasses de\r\nvetores\r\nFatores\r\nCoerção de variáveis\r\nSequências\r\nIndexing\r\nOperações em ou com\r\nvetores\r\n\r\nOutros\r\ntipos de dados (Data Frames, matrizes e listas)\r\nData Frames\r\nMatrizes\r\nListas\r\n\r\nProgramação Básica\r\nFunções\r\nEstruturas condicionais\r\n(ifelse)\r\nLoops (for e\r\nwhile)\r\n\r\n\r\nVisão geral do R e RStudio\r\nO que é a linguagem R\r\nR\r\nProgramming for Data Science, Roger D. Peng, 2019. Johns Hopkins\r\nBloomberg School of Public Health.\r\nPorque usar o R em\r\nHidrologia?\r\nSimplicidade da linguagem\r\nExcelente desempenho na manipulação de grandes bancos de\r\ndados\r\nAcesso a métodos estatísticos consolidados\r\nAcesso a diversas ferramentas de visualização de dados\r\nAcesso a métodos analíticos de ponta e ferramentas compartilhadas\r\ninternacionalmente - não só pelo uso de pacotes, mas sobretudo, usando\r\nfóruns e tutoriais.\r\n\r\nR in Hydrology , Slater, et al., Hydrol. Earth Syst. Sci., 23,\r\n2939–2963, 2019.\r\nInstalação do programa\r\n\r\n\r\n\r\nDownload de 2 programas: R e\r\nRStudio\r\n R \r\n\r\n\r\n R Studio\r\n\r\n\r\n\r\nRStudio é uma plataforma com inúmeras ferramentas\r\núteis e que roda a linguagem R. É possível usar só o R por sua\r\ninterface, mas só é possível usar o RStudio com o R instalado na\r\nmáquina.\r\nInterface do R e RStudio\r\nAbaixo temos a interface do R quando o baixamos. Ele\r\né de fato o programa que rodamos e programamos com ele.\r\n\r\nBaixamos também o RStudio, ele é uma IDE\r\n(Integrated Development Environment). Isso nada mais é do que\r\num facilitador para usar o R, trazendo uma interface\r\nmais amigável para utilização dessa linguagem e algumas facilidades.\r\n\r\nO layout é ajustável em\r\nview -> Panes -> Pane Layout\r\n\r\nPrimeiros passos, comandos no\r\nR\r\nAntes de tudo, é importante saber onde se está trabalhando! Para isso\r\no R precisa saber em qual diretório está o programa e\r\nos possíveis dados que você for utilizar. Pra isso a gente tem os\r\ncomandos: - getwd(): vai informar qual diretório se está\r\nmexendo; - setwd(): vai definir um diretório para usar no\r\nseu script; - dir(): vai informar quais arquivos\r\ntem nesse diretório; - source(): vai puxar e rodar um\r\narquivo R com esse nome que está no diretório;\r\n\r\n\r\n#getwd()\r\n#setwd(\"C:/cursoR\")\r\n#dir()\r\n#source(\"soma.R\")\r\n\r\n\r\nO R é utilizável como uma calculadora, com os\r\noperadores aritméticos que se conhece. Para multiplicação utilizamos\r\n*, para divisão /, para expoentes\r\n^ e para raiz quadrada usamos sqrt() - do\r\ninglês square root.\r\n\r\n\r\n1 + 2\r\n\r\n[1] 3\r\n\r\n\r\n\r\n12 * 5\r\n\r\n[1] 60\r\n\r\n\r\n\r\n2 / 2\r\n\r\n[1] 1\r\n\r\n\r\n\r\n12 ^ 4\r\n\r\n[1] 20736\r\n\r\n\r\n\r\nsqrt(9)\r\n\r\n[1] 3\r\n\r\nO R trabalha igualmente com vetores e escalares\r\n\r\n\r\nc(1, 3, 5, 7, 9) + c(2, 4, 6, 8, 10)\r\n\r\n[1]  3  7 11 15 19\r\n\r\nA função c() é usada para concatenar valores, criando vetores de\r\nvalores da mesma classe.\r\nAo usar o operador multiplicativo * o R\r\nentende que será feita a operação elemento a elemento. Para\r\nmultiplicação de matrizes, o operador correto é %*%.\r\nImportante na vetorização!\r\n\r\n\r\nc(1, 3, 5, 7) * t(c(2, 4, 6, 8))\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    2   12   30   56\r\n\r\n\r\n\r\nc(1, 3, 5, 7) %*% t(c(2, 4, 6, 8))\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    2    4    6    8\r\n[2,]    6   12   18   24\r\n[3,]   10   20   30   40\r\n[4,]   14   28   42   56\r\n\r\nCriação de\r\nvariáveis e atribuição de valores\r\nA forma de se atribuir um valor a um elemento/objeto é utilizando o\r\noperador <-, da forma que deve ester algo dos dois lados\r\ndessa seta - de um o nome do objeto que irá receber o valor e do outro\r\nlado o próprio valor. Também é possível usar o operador =\r\npara fazer isso, porém não é recomendado.\r\n\r\n\r\nx <- 2\r\nx\r\n\r\n[1] 2\r\n\r\nSe usarmos novamente o x para atribuir algum outro\r\nvalor, esse será salvo por cima. Também podemos trocar a direção da\r\nseta, mas ela sempre deve apontar para o nome do objeto que vai receber\r\no valor.\r\n\r\n\r\n-8 -> x\r\nx\r\n\r\n[1] -8\r\n\r\nPode-se atribuir, por exemplo, um valor não numérico a\r\nx.\r\n\r\n\r\nx <- \"teste\"\r\nx\r\n\r\n[1] \"teste\"\r\n\r\nAlguns dos operadores que existem no R são: <-,\r\n= e ==. Como já comentado, os operadores\r\n<- e = podem ser usados para atribuir\r\nvalores a variáveis/objetos, mas recomendamos utilizar smepre o\r\n<- porque o = também serve para outras\r\ncoisas (falaremos disso mais a frente quando formos criar funções!). Já\r\no símbolo == funciona para avaliar uma igualdade e não de\r\natribuir um valor a um elemento do R e retorna uma variável lógica,\r\npodendo ser TRUE ou FALSE. Por exemplo:\r\n\r\n\r\nx = 2\r\nx == 2\r\n\r\n[1] TRUE\r\n\r\n\r\n\r\nx == 3\r\n\r\n[1] FALSE\r\n\r\nOutros operadores que resultam em lógicos são:\r\n\r\n\r\nx != 2\r\n\r\n[1] FALSE\r\n\r\n\r\n\r\nx < 3\r\n\r\n[1] TRUE\r\n\r\n\r\n\r\nx >= 2\r\n\r\n[1] TRUE\r\n\r\nObjetos do R\r\nExistem diversas classes de objetos dentro do\r\nR, alguns dos principais tipos são:\r\nCaractere (letras);\r\nNumérico (real);\r\nInteiro;\r\nComplexo;\r\nFator (classes);\r\nLógico (TRUE/FALSE).\r\nPara sabermos qual classe cada objeto é, podemos utilizar uma função\r\ninterna ao R chamada class(). Usualmente,\r\nas funções vão sempre terminar com um parêntesis (), sendo\r\nque dentro dele botamos os argumentos da função - o que ela precisa\r\n(nesse caso, o objeto). Mais a frente falaremos com maiores detalhes\r\nsobre esses argumentos, funções em geral e até como criar uma sua.\r\n\r\n\r\nx <- 2\r\nclass(x)\r\n\r\n[1] \"numeric\"\r\n\r\ny <- \"oi\"\r\nclass(y)\r\n\r\n[1] \"character\"\r\n\r\nz <- TRUE\r\nclass(z)\r\n\r\n[1] \"logical\"\r\n\r\nA forma mais básica de armazenar objetos dessas classes é na forma de\r\nvetor e os vetores podem ser criados, com a função c() já\r\nutilizada antes. A regra geral é que os vetores só armazenam objetos de\r\nmesma classe. Para criarmos um objeto contendo vários tipos de classes\r\ndiferentes, podemos utilizar objetos do tipo list e\r\ndataframe, como veremos mais à frente.\r\nVia de regra, o R enverga números quando se utiliza um valor\r\nnumérico. Para se criar uma variável do tipo inteiro\r\n(integer), deve-se acrescentar a letra L ao\r\nfinal:\r\n\r\n\r\nx <- 2L\r\nclass(x)\r\n\r\n[1] \"integer\"\r\n\r\nClasses de vetores\r\nVetores só podem conter variáveis de um tipo. Abaixo colocamos três\r\nexemplos para três tipos de classes diferentes (numérico, lógico e\r\ncaractere).\r\n\r\n\r\nx <- c(1, 2, 3, 4)\r\nclass(x)\r\n\r\n[1] \"numeric\"\r\n\r\n\r\n\r\ny <- c(FALSE, TRUE, T, F)\r\ny\r\n\r\n[1] FALSE  TRUE  TRUE FALSE\r\n\r\nprint(y)\r\n\r\n[1] FALSE  TRUE  TRUE FALSE\r\n\r\nclass(y)\r\n\r\n[1] \"logical\"\r\n\r\n\r\n\r\nx <- c(\"ola\", \"bom\", \"dia\", \"programadores\")\r\nx\r\n\r\n[1] \"ola\"           \"bom\"           \"dia\"           \"programadores\"\r\n\r\nclass(x)\r\n\r\n[1] \"character\"\r\n\r\nFatores\r\nO factor é uma importante classe de elemento no R para\r\ndefinir variáveis categóricas. São úteis em modelos de regressão linear\r\ncom variáveis categóricas de entrada (estações do ano, classes de solo,\r\ncotas de alerta hidrológico etc.):\r\n\r\n\r\nx <- factor(c(\"normal\", \"atenção\", \"alerta\", \"inundação\",\r\n              \"inundação severa\", \"inundação\", \"atenção\",\r\n              \"normal\", \"inundação\", \"normal\", \"alerta\"))\r\nx\r\n\r\n [1] normal           atenção          alerta          \r\n [4] inundação        inundação severa inundação       \r\n [7] atenção          normal           inundação       \r\n[10] normal           alerta          \r\nLevels: alerta atenção inundação inundação severa normal\r\n\r\ntable(x)\r\n\r\nx\r\n          alerta          atenção        inundação inundação severa \r\n               2                2                3                1 \r\n          normal \r\n               3 \r\n\r\nCoerção de variáveis\r\nQuando se tem diferentes tipos de classes dentro de um vetor, é feita\r\numa coerção automática para que tudo fique com a mesma classe. Dessa\r\nforma, ao criar um vetor contendo dados do tipo caractere e numérico, o\r\nR supõe que todas as informações eram para ser do tipo\r\ncaractere:\r\n\r\n\r\nx <- c(\"ola\", 1, \"dia\", 2)\r\nx\r\n\r\n[1] \"ola\" \"1\"   \"dia\" \"2\"  \r\n\r\nclass(x)\r\n\r\n[1] \"character\"\r\n\r\nPodemos forçar uma coerção no R, a chamada\r\nCoerção explícita. Fazemos isso utilizando funções do\r\ntipo:\r\nas.numeric();\r\nas.character();\r\nas.logical();\r\nas.factor();\r\nas.complex().\r\nCom elas o R vai transformar o vetor (ou objeto) em\r\nquestão no tipo que você definiu. Isso pode ser uma tarefa simples ou\r\ncomplicada pro programa. No exemplo abaixo, transformar tudo em\r\ncaractere é relativamente fácil, o R apenas assume que\r\no número é um string (um caractere). Dessa forma não\r\nconseguimos fazer operações aritméticas com ele, mas conseguimos fazer\r\nalguns tratamentos utilizados em texto.\r\n\r\n\r\nx <- as.character(3)\r\nx\r\n\r\n[1] \"3\"\r\n\r\nclass(x)\r\n\r\n[1] \"character\"\r\n\r\nx + 1\r\n\r\nError in x + 1: argumento não-numérico para operador binário\r\n\r\nPdemos fazer a mesma coerção para que o vetor seja numérico. Assim\r\niremos transformar tudo dentro do vetor como classe numérico. Nesse\r\ncaso, a tarefa pro R é complicada.. afinal, como\r\ntransformar “ola” em um número? Nesses casos, no lugar é retornado um\r\nvalor NA (Not Available):\r\n\r\n\r\nx <- as.numeric(c(\"ola\", 1, \"dia\", 2))\r\n\r\nWarning: NAs introduzidos por coerção\r\n\r\nx\r\n\r\n[1] NA  1 NA  2\r\n\r\nclass(x)\r\n\r\n[1] \"numeric\"\r\n\r\nSequências\r\nPara criar vetores sequenciais podemos fazer manualmente.\r\n\r\n\r\nx <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\r\nx\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\nTambém podemos utilizar o símboblo : para facilitar.\r\nAssim a sequência é gerada somando um a um.\r\n\r\n\r\nx <- c(1:10)\r\nx\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\nExiste também funções para isso, como a função seq().\r\nCom o primeiro valor sendo em qual número começamos a sequência e o\r\nsegundo sendo até onde a sequêcia deve ir, sempre indo de 1 em 1.\r\n\r\n\r\nx <- seq(1, 10)\r\nx\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\nEssa função pode utilizar 3 valores. O terceiro é o tamanho do passo\r\na ser dado, abaixo é feita uma sequência de 1 a 10, andando de 4 em 4.\r\nEle não vai retornar 10 porque a sequência não passa por ele (ela seria\r\n1, 5, 9, 13, 17…), mas vai retornar o maior número antes do segundo\r\ncolocado dentro do seq().\r\n\r\n\r\nx <- seq(1, 10, 4)\r\nx\r\n\r\n[1] 1 5 9\r\n\r\nIndexing\r\nPara selecionar um valor específico dentro de um vetor, se usa\r\ncolchetes []. Assim, se quiser o primeiro elemento do vetor\r\nx eu escrevo x[1]. O mesmo vale para\r\nselecionar o primeiro, segundo e quinto elemento, escreveria\r\nx[c(1, 2, 5)].\r\n\r\n\r\nx <- c(11:20)\r\nx\r\n\r\n [1] 11 12 13 14 15 16 17 18 19 20\r\n\r\nx[1]\r\n\r\n[1] 11\r\n\r\nx[c(1, 2, 5)]\r\n\r\n[1] 11 12 15\r\n\r\nOperações em ou com vetores\r\nPodemos fazer operações com vetores igual faziamos com números no\r\ncomeço. Os mesmos operadores são utilizados aqui. Por exemplo, se\r\nquisermos dobrar os valores de um vetor, podemos simplesmente fazer\r\n2* esse vetor. Em geral as operações aritméticas feitas em\r\num vetor são feitas elementos a elementos. Para realizar operações\r\nmatriciais a notação muda um pouco.\r\n\r\n\r\nx <- c(1:5)\r\n2*x\r\n\r\n[1]  2  4  6  8 10\r\n\r\n\r\n\r\nsqrt(2*x/4)\r\n\r\n[1] 0.7071068 1.0000000 1.2247449 1.4142136 1.5811388\r\n\r\nÉ possível inclusive fazer operações entre vetores. Porém, caso os\r\nvetores não sejam do mesmo tamanho teremos um problema ao fazer a\r\noperação elemento a elemento (vai acabar faltando algum). O\r\nR, nesse caso, vai fazer a operação até onde ele\r\nconseguir e irá retornar uma mensagem de aviso (Warning) - mas\r\na conta será feita! Abaixo tentamos somar os vetores x e\r\ny. Como o vetor y tem um elemento a menos que\r\nx, a soma vai ser feita normalmente para os primeiros 4\r\nelementos de x, ao fazer o quinto, porém, o\r\nR vai voltar ao inicio do y - somando\r\nentão o quinto elemento de x com o primeiro do\r\ny.\r\n\r\n\r\ny <- c(1:4)\r\nx + y\r\n\r\n[1] 2 4 6 8 6\r\n\r\nPodemos misturar essas operações com o indexing comentado\r\nanteriormente. Por exemplo, se quisermos saber quais valores do vetor\r\nx são maiores que 6 posso escrever como abaixo. É retornado\r\napenas uma sequência de valores TRUE ou FALSE\r\npara cada elemento do vetor.\r\n\r\n\r\nx > 6\r\n\r\n[1] FALSE FALSE FALSE FALSE FALSE\r\n\r\nSe quiser saber quantos valores dentro do meu vetor são maiores do\r\nque 6, ao invés de contar na mão posso usar a função sum()!\r\nIsso acontece porque os valores lógicos também funcionam como número,\r\nvalores TRUE são equivalentes a 1 e valores\r\nFALSE são iguais a 0. Assim somando os valores\r\nTRUE, conseguimos saber quantos números dentro do vetor\r\nx são maiores que 6.\r\n\r\n\r\nsum(x > 6)\r\n\r\n[1] 0\r\n\r\nAbaixo, fazemos quais são os valores desse vetor que são maiores do\r\nque 6.\r\n\r\n\r\nx[x > 6]\r\n\r\ninteger(0)\r\n\r\nOutros\r\ntipos de dados (Data Frames, matrizes e listas)\r\nData Frames\r\nmatrix: todos os elementos são da mesma classe;\r\nlist: cada elemento pode pertencer a uma classe\r\ndiferente.\r\ndata.frame: dentro de cada coluna, os objetos pertencem\r\nà mesma classe, mas diferentes colunas podem pertencer a diferentes\r\nclasses;\r\nQuando são lidos objetos externos (planilhas excel, arquivos .txt ou\r\n.csv), usando as funções do R read.table() ou\r\nread.csv(), por exemplo, o objeto criado é um\r\ndata.frame.\r\nA classe de data.frame é muito utilizada em R. É o que\r\nse utiliza para dados tabulados. Além disso, todos os elementos do\r\ndata.frame têm o mesmo comprimento.\r\n\r\n\r\nDF <- data.frame(x = c(1:3), coluna_2 = c(\"A\", \"B\", \"C\"))\r\nDF\r\n\r\n  x coluna_2\r\n1 1        A\r\n2 2        B\r\n3 3        C\r\n\r\nclass(DF)\r\n\r\n[1] \"data.frame\"\r\n\r\nCoerção de classe para data.frame.\r\n\r\n\r\nm <- matrix(c(1:9), nrow = 3)\r\nm <- as.data.frame(m)\r\nm\r\n\r\n  V1 V2 V3\r\n1  1  4  7\r\n2  2  5  8\r\n3  3  6  9\r\n\r\nCoerção de classe para data.frame.\r\n\r\n\r\nm <- matrix(c(1:9), nrow = 3); attributes(m)\r\n\r\n$dim\r\n[1] 3 3\r\n\r\nattributes(as.data.frame(m))\r\n\r\n$names\r\n[1] \"V1\" \"V2\" \"V3\"\r\n\r\n$class\r\n[1] \"data.frame\"\r\n\r\n$row.names\r\n[1] 1 2 3\r\n\r\nMatrizes\r\nMatrizes são objetos objetos semelhantes a vetores, entretanto, com o\r\natributo dimensão dim.\r\n\r\n\r\nm <- matrix(nrow = 2, ncol = 3); m\r\n\r\n     [,1] [,2] [,3]\r\n[1,]   NA   NA   NA\r\n[2,]   NA   NA   NA\r\n\r\nattributes(m)\r\n\r\n$dim\r\n[1] 2 3\r\n\r\nMatrizes podem ser criadas a partir de vetores, adicionando o\r\natribuito dimensão.\r\n\r\n\r\nm <- matrix(x, nrow = 2, ncol = 5); m\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    3    5    2    4\r\n[2,]    2    4    1    3    5\r\n\r\nm <- matrix(x, nrow = 2, ncol = 5, byrow = TRUE); m\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    2    3    4    5\r\n[2,]    1    2    3    4    5\r\n\r\nPara selecionar elementos de uma matriz, é necessário especificar as\r\nduas dimensões:\r\n\r\n\r\nm <- matrix(1:4, nrow = 2); m\r\n\r\n     [,1] [,2]\r\n[1,]    1    3\r\n[2,]    2    4\r\n\r\nm[2,2]\r\n\r\n[1] 4\r\n\r\nSelecionar elementos de matrizes quadradas:\r\n\r\n\r\nlower.tri(m)\r\n\r\n      [,1]  [,2]\r\n[1,] FALSE FALSE\r\n[2,]  TRUE FALSE\r\n\r\nupper.tri(m)\r\n\r\n      [,1]  [,2]\r\n[1,] FALSE  TRUE\r\n[2,] FALSE FALSE\r\n\r\nSelecionar elementos de matrizes quadradas:\r\n\r\n\r\nm[lower.tri(m)] <- NA; m\r\n\r\n     [,1] [,2]\r\n[1,]    1    3\r\n[2,]   NA    4\r\n\r\ndiag(m) <- NA; m\r\n\r\n     [,1] [,2]\r\n[1,]   NA    3\r\n[2,]   NA   NA\r\n\r\nVetores podem ser unidos a fim de criar uma matriz:\r\n\r\n\r\nx <- c(1:10)\r\ny <- rnorm(10, 10, 5)\r\nuniao <- cbind(x, y)\r\nuniao\r\n\r\n       x         y\r\n [1,]  1 16.650557\r\n [2,]  2 13.995728\r\n [3,]  3  7.994728\r\n [4,]  4  8.026533\r\n [5,]  5 11.203624\r\n [6,]  6 -1.213850\r\n [7,]  7 12.287441\r\n [8,]  8  7.361899\r\n [9,]  9  6.755540\r\n[10,] 10  7.629407\r\n\r\ndim(uniao)\r\n\r\n[1] 10  2\r\n\r\nA função cbind() adiciona colunas as matrizes.\r\nVetores podem ser unidos a fim de criar uma matriz:\r\n\r\n\r\nx <- c(1:10)\r\ny <- rnorm(10, 20, 5)\r\nuniao <- rbind(x, y)\r\nuniao\r\n\r\n     [,1]     [,2]     [,3]     [,4]    [,5]     [,6]     [,7]\r\nx  1.0000  2.00000  3.00000  4.00000  5.0000  6.00000  7.00000\r\ny 23.5646 13.81363 13.09557 25.19093 13.9108 21.07327 22.57734\r\n      [,8]     [,9]    [,10]\r\nx  8.00000  9.00000 10.00000\r\ny 20.58697 16.11471 23.45043\r\n\r\ndim(uniao)\r\n\r\n[1]  2 10\r\n\r\nA função rbind() adiciona linhas as matrizes.\r\nListas\r\nListas são elementos importantes na programação em R. Uma das\r\nvantagens de se saber utilizar bem esse tipo de elemento é que nelas é\r\npossível armazenar elementos de diferentes tipos (caracter, número real,\r\ninteiro, complexo, lógico).\r\nElas são diferentes dos vetores que, via de regra, só armazenam\r\nobjetos de mesma classe.\r\nPara criar uma lista:\r\n\r\n\r\nx <- list(1, \"Ola\", 1+5i, TRUE, 4L)\r\nx\r\n\r\n[[1]]\r\n[1] 1\r\n\r\n[[2]]\r\n[1] \"Ola\"\r\n\r\n[[3]]\r\n[1] 1+5i\r\n\r\n[[4]]\r\n[1] TRUE\r\n\r\n[[5]]\r\n[1] 4\r\n\r\nPara selecionar dados de listas, utiliza-se o duplo cochete\r\n[[]]:\r\n\r\n\r\nx <- list(c(1,2,3), c(\"Ola\", \"Mundo\"), 1+5i, TRUE, 4L)\r\nx[[1]]\r\n\r\n[1] 1 2 3\r\n\r\nx[[2]][2]\r\n\r\n[1] \"Mundo\"\r\n\r\nx[[5]] + 6\r\n\r\n[1] 10\r\n\r\nProgramação Básica\r\nFunções\r\nUma coisa essencial em qualquer linguagem de programação é a criação\r\ne utilização de funções. O R (assim como outras\r\nlinguagens) já vem com diversas funções instaladas nele mesmo - chamamos\r\nisso de R base. Por exemplo, se quisermos calcular o\r\nlog de algum valor, podemos utilizar a função\r\nlog() colocando dentro do parênteses o valor que\r\nqueremos.\r\n\r\n\r\nlog(10)\r\n\r\n[1] 2.302585\r\n\r\nPara saber o que é preciso colocar dentro dos parênteses, ou seja,\r\nquais os argumentos (inputs) que cada função toma, podemos\r\nutilizar a função args(). Usando ela com o log (dessa vez\r\nsem parênteses) dentro, podemos ver que a função toma dois argumentos: o\r\nx (valor em que se calcula o logaritmo) e a\r\nbase que já vem com um valor definido de exponencial. Para\r\nse ter mais informações sobre alguma função, podemos, além de usar\r\nargs() utilizar uma interrogação anterior ao nome da função\r\n(sem parêntesis), ou usar a função help(). Essas duas\r\núltimas opções são equivalentes e nos mostram a documentação feita para\r\nessa função no R.\r\n\r\n\r\nargs(log)\r\n?log\r\nhelp(log)\r\n\r\n\r\nO segundo argumento do log() pode ser modificado, basta\r\ndeixar ele explícito ao chamar a função. Não precisamos escrever qual\r\nargumento estamos utilizando desde que se siga a ordem da função\r\n(mostrada anteriormente). Caso se queira escrever os argumentos em outra\r\nordem, é possível, mas é necessário escrever cada um deles. Veja melhor\r\no exemplo abaixo. O primeiro não definimos a base, portanto é usada a\r\npré definida (exponencial). No segundo log feito, não escrevemos qual a\r\nbase e qual o número que queremos o logaritmo, portanto o\r\nR assume que estamos escrevendo na ordem da função, que\r\ntoma como primeiro argumento o valor e o segundo argumento a base. No\r\nterceiro exemplo trocamos as ordens dos argumentos, mas para isso\r\nprecisamos deixar explícito (escrito) quem é cada um.\r\n\r\n\r\nlog(100)\r\n\r\n[1] 4.60517\r\n\r\nlog(100, 10)\r\n\r\n[1] 2\r\n\r\nlog(base = 10, x = 100)\r\n\r\n[1] 2\r\n\r\nAgora vamos fazer nossa própria função dentro do R.\r\nPara isso, primeiro definimos um nome para ser o nome da função (como\r\nfizemos com criação de variáveis / objetos), por exemplo\r\n“fun_area_circulo”. Em seguida devemos dizer que vamos criar uma função\r\ne quais os argumentos que ela toma. Para fazer o exemplo, a área de um\r\ncírculo, precisamos apenas de uma informação - o raio desse círculo.\r\nPodemos fazer quantas operações quisermos dentro da função, no final o\r\núltimo valor será retornado por ela (podemos deixar isso explícito\r\nescrevendo return) nela. Depois chamamos ela como qualquer\r\noutra função!\r\n\r\n\r\nfun_area_circulo <- function(raio){\r\n  x <- 2*pi*raio\r\n  return(x)\r\n}\r\n\r\nfun_area_circulo(5)\r\n\r\n[1] 31.41593\r\n\r\nEstruturas condicionais\r\n(ifelse)\r\nEm programação, algo extremamente importante e útil são os comandos\r\nif e else (e / se). Com\r\nesses comandos, é possível rodar um código apenas se uma condição for\r\ncumprida. Esse comando no R funciona similar a uma\r\nfunção, sendo então o ifelse() (tudo junto!), e toma três\r\nargumentos - um lógico (uma condição), o que fazer se o lógico for\r\nTRUE e o que fazer se o lógico for FALSE.\r\nAbaixo fazemos um exemplo utilizando o ifelse para\r\nverificar se o X é maior ou menor do que 100.\r\n\r\n\r\nx <- 10\r\nifelse(x < 100, \"X é menor que 100\", \"X é maior ou igual a 100\")\r\n\r\n[1] \"X é menor que 100\"\r\n\r\n\r\n\r\nx <- 1000\r\nifelse(x < 100, \"X é menor que 100\", \"X é maior ou igual a 100\")\r\n\r\n[1] \"X é maior ou igual a 100\"\r\n\r\nÉ possível usar também só o if como um comando. Em\r\nseguida rodamos um código para que, se o X for um número não inteiro,\r\narredondamos ele e em seguida o transformamos em inteiro.\r\n\r\n\r\nx <- 3.7\r\nif(class(x) != \"integer\") x <- as.integer(round(x))\r\nclass(x)\r\n\r\n[1] \"integer\"\r\n\r\nLoops (for e while)\r\nA última coisa a se falar do R “básico” é a\r\nconstrução de loops. Eles são utilizados quando queremos\r\nrepetir a mesma coisa várias vezes.\r\nfor\r\nO for() utiliza 2 argumentos. O primeiro fala qua objeto\r\nvai ser iterado várias vezes, e o outro a faixa de valores (quantas\r\nvezes ele vai ser iterado praticamente). No exemplo abaixo vamos por\r\nexemplo variar o i (criado dentro do próprio loop)\r\nna sequência de 1 até 5. Isso é o mais importante desse tipo de\r\nloop, precisamos saber quantas vezes\r\n(1:5) iterar essa variável (nesse caso i). O\r\nresto da função é simplesmente o que vai ser iterado. No exemplo abaixo\r\napenas printamos o valor de i quando ele varia de 1 a\r\n5.\r\n\r\n\r\nfor(i in 1:5){\r\n  print(i)\r\n}\r\n\r\n[1] 1\r\n[1] 2\r\n[1] 3\r\n[1] 4\r\n[1] 5\r\n\r\nwhile\r\nDiferente do for, utilizamos o while quando\r\nnão sabemos a priori quando queremos terminar nosso\r\nloop. Ou seja, vamos ficar repetindo o que foi feito até certa\r\ncondição ser cumprida. No exemplo abaixo, printamos na tela o valor de\r\ni, sendo que a cada “rodada” aumentamos o valor de\r\ni em uma unidade. Isso é feito até o i ser\r\nmenor ou igual a 5, por exemplo.\r\n\r\n\r\ni <- 0\r\n\r\nwhile(i <= 5){\r\n  print(i)\r\n  i <- i + 1\r\n}\r\n\r\n[1] 0\r\n[1] 1\r\n[1] 2\r\n[1] 3\r\n[1] 4\r\n[1] 5\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-23T15:38:56-03:00"
    },
    {
      "path": "data_explore.html",
      "title": "Análise exploratória dos dados",
      "description": "Como obter uma visão geral dos dados",
      "author": [],
      "contents": "\r\n\r\nContents\r\nPacotes\r\nCarcaterização numérica\r\nCaracterização gráfica\r\n\r\nPacotes\r\nCarcaterização numérica\r\nCaracterização gráfica\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-23T15:38:57-03:00"
    },
    {
      "path": "data_manip.html",
      "title": "Manipulação dos dados",
      "description": "Como organizar as informações para facilitar as análises",
      "author": [],
      "contents": "\r\n\r\nContents\r\nPacotes\r\nPuxar arquivo anterior e\r\nanalisar ele\r\nManipulações básicas nos\r\ndados\r\nDados em\r\nBranco (NA)\r\nAno\r\nhidrológico\r\nTabela\r\nResumo\r\nTabela final\r\n(loop)\r\n\r\n\r\nPacotes\r\nNessa seção vamos usar mecanismos de pacotes já feitos no\r\nR. Existem inúmeros pacotes, cada um com suas funções\r\ne/ou bancos de dados para diferentes assuntos. Eles podem, inclusive,\r\nser apenas um aglomerado de diferentes pacotes para não precisar baixar\r\ntodos um por um. A primeira etapa de utilizar um pacote é a sua\r\ninstalação, isso é feito com o comando install.packages()\r\ncom o nome do pacote estando entre aspas (““) dentro dos parêntesis.\r\nAssim podemos fazer com todos que se encontram no CRAN (repositório que\r\ncontém o que queremos). Na aula de hoje utilizaremos apenas o\r\ntidyverse, que é um agregado de pacotes extremamente\r\npopulares hoje para manipulação e análise de dados.\r\n\r\n\r\ninstall.packages(\"tidyverse\")\r\n\r\n\r\nPara que o R não fique muito pesado, todos os\r\npacotes baixados precisam ser carregados na sua seção do\r\nR - isso é feito com o comando library()\r\ncom o pacote estando detro do parêntesis sem aspas.\r\nPodemos notar que ao carregar o pacote dentro da nossa seção primeiro\r\nvemos quais outros pacotes que foram carregados e suas respectivas\r\nversões. Nesse exemplo, ao carregar o tidyverse, ele\r\ncontém o ggplot2, purrr,\r\ntibble, dplyr, tidyr,\r\nstringr, readr e\r\nforcats. Além disso, aparece uma mensagem mostrando\r\n“conflitos”. Esses conflitos são quando diferentes pacotes utilizam\r\nfunções de mesmo nome (as vezes para fazer coisas diferentes), assim o\r\nR te avisa quais funções são iguais e quais serão as\r\nutilizadas normalmente no programa. É possível usar qualquer função se\r\ndeixarmos explícito de qual pacote queremos (por exemplo\r\nstats::filter())\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n── Attaching packages ───────────────────────────── tidyverse 1.3.1 ──\r\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\r\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\r\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\r\n✔ readr   2.1.2     ✔ forcats 0.5.1\r\n── Conflicts ──────────────────────────────── tidyverse_conflicts() ──\r\n✖ lubridate::as.difftime() masks base::as.difftime()\r\n✖ lubridate::date()        masks base::date()\r\n✖ dplyr::filter()          masks stats::filter()\r\n✖ lubridate::intersect()   masks base::intersect()\r\n✖ dplyr::lag()             masks stats::lag()\r\n✖ lubridate::setdiff()     masks base::setdiff()\r\n✖ lubridate::union()       masks base::union()\r\n\r\nPuxar arquivo anterior e\r\nanalisar ele\r\nPrimeiro vamos baixar apenas uma das estações que fizemos na última\r\naula. Ao final podemos repetir o que foi feito anteriormente e criar um\r\nloop para repetir para as outras 3 estações.\r\n\r\n\r\ndados_ANA <- read.table(file = \"dados/60435000.txt\",\r\n                        sep = \"\\t\",\r\n                        dec = \".\",\r\n                        header = T,\r\n                        fileEncoding = \"UTF-8\")\r\n\r\n\r\nApesar de termos mexido nesses dados na última aula, o\r\nR não sabe disso, ele baixa o arquivo como se fosse um\r\noutro qualquer, assim a coluna da estação é do tipo “inteiro” e a\r\nsegunda coluna (de data) está do tipo “caractere”. Vemos isso abaixo e\r\nem seguida corrigimos ambas para caractere e data, respectivamente.\r\n\r\n\r\nclass(dados_ANA$Cod_estacao)\r\n\r\n[1] \"integer\"\r\n\r\nclass(dados_ANA$Data)\r\n\r\n[1] \"character\"\r\n\r\ndados_ANA$Cod_estacao <- as.character(dados_ANA$Cod_estacao)\r\ndados_ANA$Data <- as.Date(dados_ANA$Data)\r\n\r\n\r\nManipulações básicas nos\r\ndados\r\nAgora que temos um arquivo do jeito que queríamos (diferente do que\r\npegamos diretamente do servidor da ANA), fazer algumas análises podem\r\nser bem fáceis. Se quisermos saber de quando a quando essa estação tem\r\ndados, basta vermos os valores mínimos e máximos da Data.\r\n\r\n\r\nmin(dados_ANA$Data)\r\n\r\n[1] \"1978-05-01\"\r\n\r\n\r\n\r\nmax(dados_ANA$Data)\r\n\r\n[1] \"2021-11-30\"\r\n\r\nSe quisermos saber qual valor mínimo, máximo e médio de vazão podemos\r\ntambém, mas aparece um problema! Nesses valores temos dados em branco,\r\nou NA (Not Available). Dados faltantes sempre são\r\nproblemático e devem ser tratados quando possível. Para algumas funções\r\nnativas, como max(), min() e\r\nmean() temos a opção de apenas ignorar eles com o argumento\r\nna.rm = TRUE, assim os valores máximos, médios e mínimos\r\nsão calculados sem considerar os dados em branco.\r\n\r\n\r\nmax(dados_ANA$Vazao, na.rm = T)\r\n\r\n[1] 37.4633\r\n\r\nmin(dados_ANA$Vazao, na.rm = T)\r\n\r\n[1] 0.0539\r\n\r\nmean(dados_ANA$Vazao, na.rm = T)\r\n\r\n[1] 2.096619\r\n\r\nDados em Branco (NA)\r\nAntes mesmo de começar a fazer essas avaliações é interessante e\r\nimportante entender melhor os dados em branco. Primeiro, quantos\r\nexistem? Para isso podemos usar a função is.na(), vamos\r\nrodar ela apenas para os primeiros 15 dados de vazão para mostrar na\r\ntela.\r\n\r\n\r\nis.na(dados_ANA$Vazao)[1:15]\r\n\r\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\r\n[12] FALSE FALSE FALSE FALSE\r\n\r\nEssa função retorna um dado TRUE ou FALSE\r\npara cada valor avaliado. Como dados lógicos também são\r\nbinários/numéricos (TRUE = 1 e FALSE =\r\n0), podemos somar esses valores para ver quantos dados em\r\nbranco temos no total. Temos então\r\nsum(is.na(dados_ANA[,3])) dados em branco.\r\n\r\n\r\nsum(is.na(dados_ANA$Vazao))\r\n\r\n[1] 87\r\n\r\nPara saber quais as datas que tem o valor de vazão em branco basta\r\naplicarmos esse is.na() na coluna de datas.\r\n\r\n\r\ndados_ANA$Data[is.na(dados_ANA$Vazao)]\r\n\r\n [1] \"1978-05-01\" \"1978-05-02\" \"1978-05-03\" \"1978-05-04\" \"1978-05-05\"\r\n [6] \"1978-05-06\" \"1978-05-07\" \"1978-05-08\" \"1978-05-09\" \"1978-05-10\"\r\n[11] \"1978-05-11\" \"2008-12-01\" \"2008-12-02\" \"2008-12-03\" \"2008-12-04\"\r\n[16] \"2008-12-05\" \"2008-12-06\" \"2008-12-07\" \"2008-12-08\" \"2008-12-09\"\r\n[21] \"2008-12-10\" \"2008-12-11\" \"2008-12-12\" \"2008-12-13\" \"2008-12-14\"\r\n[26] \"2008-12-15\" \"2008-12-16\" \"2008-12-17\" \"2008-12-18\" \"2008-12-19\"\r\n[31] \"2008-12-20\" \"2008-12-21\" \"2008-12-22\" \"2008-12-23\" \"2008-12-25\"\r\n[36] \"2008-12-26\" \"2008-12-27\" \"2008-12-28\" \"2008-12-29\" \"2008-12-30\"\r\n[41] \"2008-12-31\" \"2009-01-01\" \"2009-01-02\" \"2009-01-03\" \"2009-01-04\"\r\n[46] \"2009-01-05\" \"2009-01-06\" \"2009-01-07\" \"2009-01-08\" \"2009-01-09\"\r\n[51] \"2009-01-10\" \"2009-01-11\" \"2009-01-12\" \"2009-01-13\" \"2009-01-14\"\r\n[56] \"2009-01-15\" \"2019-08-01\" \"2019-08-02\" \"2019-08-03\" \"2019-08-04\"\r\n[61] \"2019-08-05\" \"2019-08-06\" \"2019-08-07\" \"2019-08-08\" \"2019-08-09\"\r\n[66] \"2019-08-10\" \"2019-08-11\" \"2019-08-12\" \"2019-08-13\" \"2019-08-14\"\r\n[71] \"2019-08-15\" \"2019-08-16\" \"2019-08-17\" \"2019-08-18\" \"2019-08-19\"\r\n[76] \"2019-08-20\" \"2019-08-21\" \"2019-08-22\" \"2019-08-23\" \"2019-08-24\"\r\n[81] \"2019-08-25\" \"2019-08-26\" \"2019-08-27\" \"2019-08-28\" \"2019-08-29\"\r\n[86] \"2019-08-30\" \"2019-08-31\"\r\n\r\nE se quiser o último (a última data com vazão em branco), podemos\r\nfazer o max() dessas datas todas.\r\n\r\n\r\nmax(dados_ANA$Data[is.na(dados_ANA$Vazao)])\r\n\r\n[1] \"2019-08-31\"\r\n\r\nO que fazer com cada dado em branco vai depender do que se quer com\r\nos dados. Como completar essas falhas é uma temática extremamente\r\nrelevante e difícil de responder até mesmo hoje. Pararemos por hora de\r\nfalar desses valores, e não entraremos muito a fundo sobre o que fazer\r\ncom eles (até porque depende do que se quer fazer) nesse curso.\r\nAno hidrológico\r\nEm hidrologia estatística, é muito comum utilizarmos o ano\r\nhidrológico ao invés do calendário “normal” (janeiro a dezembro) para\r\nfazer análises estatísticas. Onde começa o ano hidrológico também não é\r\ntão simples, mas a via de regra é: entre as secas e cheias.\r\nFaremos aqui uma função para transformar nossa data em ano\r\nhidrológico, assim conseguiremos fazer algumas análises anuais\r\ninteressantes. A função, chamada aqui de fun_ano_hidro()\r\ntomará 2 argumentos: um sendo as datas que queremos transformar e o\r\noutro em que mês que se inicia o ano hidrológico, aqui deixamos\r\npré-definido como 8, mas se quiser mudar isso, basta alterar o argumento\r\nna hora de chamar ela (assim não ficamos preso a esse número)! Primeiro\r\ndevemos garantir que as datas estão no formato certo, portanto fazemos\r\nessa transformação no começo da função. Em seguida definimos qual será o\r\nano hidrológico. O que fazemos é avaliar se o mês em questão é menor ou\r\nmaior do que o começo do ano hidrológico definido pela função. Se for\r\nmaior, significa que já entramos em outro ano hidrológico, portanto o\r\nano em questão é o seguinte (o mês 8, Agosto, de 2000 entra para o ano\r\nhidrológico de 2001 e assim por diante).\r\n\r\n\r\nfun_ano_hidro <- function(datas,\r\n                          comeco_ano_hidro = 8){\r\n \r\n  # Se não tiver no formato de datas, fazer essa correção\r\n  datas <- as.Date(datas)\r\n  \r\n  # Se vai pular (deslocar) um ano ou não\r\n  desloc_ano <- ifelse(month(datas) < comeco_ano_hidro, 0, 1)\r\n  \r\n  # Ano Hidro\r\n  ano_hidro <- year(datas) + desloc_ano\r\n  \r\n  return(ano_hidro)\r\n}\r\n\r\n\r\nAbaixo testamos ela fazendo uma nova coluna no nosso\r\ndataframe.\r\n\r\n\r\ndados_ANA$ano_hidro <- fun_ano_hidro(dados_ANA$Data)\r\n\r\nhead(dados_ANA)\r\n\r\n  Cod_estacao       Data Vazao ano_hidro\r\n1    60435000 1978-05-01    NA      1978\r\n2    60435000 1978-05-02    NA      1978\r\n3    60435000 1978-05-03    NA      1978\r\n4    60435000 1978-05-04    NA      1978\r\n5    60435000 1978-05-05    NA      1978\r\n6    60435000 1978-05-06    NA      1978\r\n\r\nTabela Resumo\r\nAqui introduzimos um novo conceito do pacote\r\nmagrittr (ele está internamente no\r\ntiyverse). Esse conceito se chama pipe\r\noperator e é dado pelo símbolo %>%. Basicamente\r\no que ele faz é tomar o que está na esquerda dele, e usar como argumento\r\nda função a direita. Assim ao invés de escrever as funções umas dentro\r\ndas outras, podemos deixar o código mais limpo e fácil de entender. Olhe\r\no exemplo abaixo. Nele estamos tirando o log das vazões, com a função\r\nlog(), depois calculando as diferenças desse log em um\r\npasso de tempo com diff(), calculamos o exponencial disso\r\ncom exp(), em seguimas calculamos a média desses valores e\r\ndepois arredondamos isso para ter apenas 2 casas decimais.\r\n\r\n\r\nround(mean(exp(diff(log(dados_ANA$Vazao))), na.rm = T), 2)\r\n\r\n[1] 1.03\r\n\r\nÉ fácil se perder lendo isso pois no R normalmente\r\nlemos de dentro para fora das funções (e portanto da direita para a\r\nesquerda) e é mais fácil ainda confundir qual argumento entra em qual\r\nfunção. Usando o pipe operator, dado por\r\n%>%, o código fica mais facilmente interpretável.\r\nSelecionamos a vazão e em seguida tiramos o log, depois a diferença,\r\ndepois o expoente… Quando uma função tem diversos argumentos podemos\r\nescrever explicitamente onde que o objeto a esquerda do pipe\r\nvai entrar colocando um ponto no lugar dele, não precisando que ele\r\nsempre entre no primeiro argumento da função.\r\n\r\n\r\ndados_ANA$Vazao %>%\r\n  log() %>%\r\n  diff() %>%\r\n  exp() %>%\r\n  mean(., na.rm = T) %>%\r\n  round(digits = 2, x = .)\r\n\r\n[1] 1.03\r\n\r\nAgora que temos o ano hidrológico para cada data, podemos fazer a\r\nnossa série de máximos, mínimos e médias anuais a partir dos dados\r\ndiários. Primeiro cria-se um dataframe vazio com as colunas\r\npara cada ano, uma coluna para os máximos, outra para os mínimos e outra\r\npara as médias anuais. Podemos também criar uma quarta coluna para o\r\nnúmero de valores NA nesse período.\r\nJá iremos fazer isso no formato de função, para que possamos replicar\r\npara as outras estações também! A função tomará como argumento a tabela\r\noriginal de dados (dados_ANA), e irá rodar a função\r\nfun_ano_hidro() internamente. Assim teremos uma nova coluna\r\ncriada com a função mutate(). Em seguida agrupamos os dados\r\npor estação (se tivesse mais de uma por exemplo) e por ano hidrológico\r\nusando o group_by e falamos o que faremos ao juntar esses\r\ndados com o summarise(). Um problema é se o ano hidrológico\r\nestiver todo com falha, nesses casos as funções usadas retornarão\r\nInf (infinito), -Inf ou NaN\r\n(Not a Number), portanto depois de agruparmos, iremos trocar\r\nqualquer valor não-finito na tabela por NA.\r\nRodar uma outra função internamente requer alguns cuidados. Por\r\nexemplo, aqui assumimos que a tabela virá com uma coluna chamada “Data”.\r\nCaso isso não aconteca a nossa função não irá funcionar.\r\n\r\n\r\nfun_resumo_ano <- function(dados_hidro){\r\n  \r\n  tabela_resumo <-\r\n    dados_hidro %>%\r\n    mutate(ano_hidro = fun_ano_hidro(Data)) %>%\r\n    group_by(Cod_estacao, ano_hidro) %>%\r\n    summarise(maxima = max(Vazao, na.rm = T),\r\n              minima = min(Vazao, na.rm = T),\r\n              media = mean(Vazao, na.rm = T),\r\n              NAs = sum(is.na(Vazao)))\r\n  \r\n  tabela_resumo[!is.finite(tabela_resumo$maxima), c(3, 4, 5)] <- NA\r\n  \r\n  return(tabela_resumo)\r\n}\r\n\r\n\r\nTabela final (loop)\r\nAgora podemos aplicar essa função diretamente aos\r\ndados_ANA da última aula. Na realidade, podemos fazer um\r\nloop para abrir cada uma das 4 estações, rodar essa função e\r\njuntar essas tabelas em uma só com a função rbind() - essa\r\nfunção junta diferentes dataframes pelas mesmas colunas,\r\ncolocando um embaixo do outro. Abaixo rodamos o loop de outra\r\nmaneira, definindo antes quais os códigos das estações e rodando o\r\nfor() variando de 1 a 4. Primeiro lemos a primeira estação\r\ne, se for a primeira iteração, salvamos ela em um objeto chamado\r\ntabela_final. Se não for a primeira iteração, juntamos elas com\r\no rbind().\r\n\r\n\r\nestacoes_cod <- c(60435000, 60436000, 60436190, 60443000)\r\n\r\nfor(i in 1:4){\r\n  dados_proxy <- read.table(file = paste0(\"dados/\", estacoes_cod[i],\".txt\"),\r\n                            sep = \"\\t\",\r\n                            dec = \".\",\r\n                            header = T,\r\n                            fileEncoding = \"UTF-8\")\r\n  \r\n  dados_proxy <- fun_resumo_ano(dados_proxy)\r\n  \r\n  if(i == 1) tabela_final <- dados_proxy\r\n  if(i != 1) tabela_final <- rbind(tabela_final, dados_proxy)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-23T15:39:10-03:00"
    },
    {
      "path": "frequency_analysis.html",
      "title": "Análise de frequência de cheias",
      "description": "Exemplo de análise local com dados reais",
      "author": [],
      "contents": "\r\n\r\nContents\r\nObjetivos da atividade\r\nSeleção das vazões máximas\r\nanuais\r\nObtenção da série de vazões\r\ndiárias\r\nExtração da série de\r\nvazões máximas anuais\r\nVisualização da série\r\nde máximos anuais\r\n\r\nConstrução da curva\r\nde frequência amostral\r\nPosição\r\nde plotagem\r\n\r\nAjuste de\r\numa distribuição teórica de probabilidades\r\nA distribuição lognormal\r\nQuantis de cheia da\r\nlognormal\r\nMétodo de\r\najuste\r\nAjuste da\r\nlognormal e estimativa dos quantis\r\nDeterminação dos quantis de\r\ncheia\r\n\r\nDescrição das incertezas\r\nLógica\r\nda construção de intervalos de confiança aproximados\r\n\r\nInferência\r\nCálculo dos momentos-L\r\nDiagrama de momentos-L\r\nEstimativa dos\r\nparâmetros da distribuição\r\nCálculo dos quantis de\r\ncheia\r\n\r\nConstrução da curva de\r\nfrequência\r\nDescrição das\r\nincertezas (intervalo de confiança)\r\nCurva de frequência final\r\nDetalhes\r\ntécnicos\r\nDistribuição de\r\nprobabilidades\r\n\r\nDetalhamento de posição de\r\nplotagem\r\nPassos a serem executados\r\n\r\nObjetivos da atividade\r\nO objetivo desta atividade é realizar uma análise de frequência de\r\ncheias a nível local. Isso significa que iremos relacionar a magnitude\r\ndas vazões máximas anuais com a probabilidade da mesma ser excedida. A\r\nanálise a nível local siginifca que utilizaremos apenas as informações\r\nde vazão observadas na estação fluviométrica de interesse, sem fazer uso\r\nde informações sobre as vazões máximas anuais que teham acontecido em\r\noutras estações fluviométricas localizadas na região.\r\nAlém de construirmos a relação entre a magnitude das vazões máximas\r\nanuais e a respectiva probabilidade de excedência, é importante saber\r\nestimar também o grau de incerteza nessas estimativas. Essas incertezas\r\nsão usualmente representadas por intervalos de confiança, como veremos\r\nmais adianate.\r\nAlém de calcular essas quantidades, a curva de frequência, e suas\r\nrespectivas incertezas, são representadas graficamente, como na figura\r\nabaixo, que mostra os resultados para um estudo de cheias numa seção do\r\nRio Salado, localizada na província de Santa Fé, na Argentina, onde em\r\n2003 ocorreu o rompimento de um dique que resultou em perde de vidas\r\nhumanas e elevados prejuízos.\r\nContruiremos aqui no curso uma figura semelhante a esta, onde no\r\neixo-x temos o tempo de recorrência e no eixo-y a magnitude das vazões\r\nmáximas anuais. O tempo de recorrência apresentado no eixo-x é uma\r\nmaneira de representar a probabilidade de excedência. A linha cheia em\r\nvermelho representa o valor esperado dos valores da vazão máxima anual\r\nem função do tempo de recorrência, enquanto as linhas tracejadas\r\nrepresentam os intervalos de confiança de 95%, ilustrando as incertezas\r\nenvolvidas nessas estimativas. Os círculos azuis escuros representam as\r\nvazões máximas anuais registradas no passado, enquanto o círculo azul\r\nclaro mostra a cheia destruidora de 2003.\r\n\r\n\r\n\r\n(#fig:curva_freq)Curva de frequência do cheias do Rio Salado, na\r\nArgentina.\r\n\r\n\r\n\r\nSeleção das vazões máximas\r\nanuais\r\nO primeiro passo de nossa atividade consiste em obter a série de\r\nmáximos anuais que desejamos analisar. A obtenção da série de máximos\r\nanuais será realizada em duas etapas. Primeiro vamos obter a séries de\r\nvazões diárias, e para isso utilizaremos a mesma função de obtenção de\r\nséries diárias de vazão que aprendemos na segunda aula deste curso. Com\r\na série de vazões diárias em mãos, passaremos para a segunda etapa, que\r\né a de extrair a vazão máxima de cada ano hidrológico.\r\nObtenção da série de vazões\r\ndiárias\r\nA função abaixo permite obter a série de vazões diárias de uma\r\nestação fluviométrica. O único argumento desta função é o código da\r\nestação. Quando chamamos esta função, ela retorna um dataframe com 3\r\ncolunas: o código da estação, a data, e o valor da vazão diária.\r\nComo já estudamos esta função anteriormente, a uitlizaremos aqui sem\r\nentrar em qualqer detalhes sobre seu funcionamento.\r\n\r\n\r\n# Função para obter série histórica de vazão de uma determinada estação ####\r\ndados_serie_ANA <- function(cod_estacao = NA,\r\n                            data_inicio = \"01/01/1800\",\r\n                            data_fim = Sys.Date(),\r\n                            tipo_dados = 3,\r\n                            nivel_consist = 1){\r\n  \r\n  # Pegar dados a partir do url e transformar em um dataframe\r\n  url_base <-\r\n    paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/\",\r\n           \"HidroSerieHistorica?\",\r\n           \"codEstacao=\", cod_estacao,\r\n           \"&dataInicio=\", data_inicio,\r\n           \"&dataFim=\", data_fim,\r\n           \"&tipoDados=\", tipo_dados,\r\n           \"&nivelConsistencia=\", nivel_consist)\r\n  \r\n  url_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n  node_doc <- XML::getNodeSet(url_parse, \"//SerieHistorica\")\r\n  dados_estacao <- XML::xmlToDataFrame(nodes = node_doc)\r\n  \r\n  # Por algum motivo o hidroweb não está filtrando os dados pela consistencia\r\n  dados_estacao <- filter(dados_estacao, NivelConsistencia == nivel_consist)\r\n  \r\n  # Separar data e hora\r\n  dados_estacao$Data <- as.Date(substr(dados_estacao$DataHora, 1, 10))\r\n  dados_estacao$Hora <- substr(dados_estacao$DataHora, 12, 19)\r\n  \r\n  # Fazer um dataframe só com datas e valores de vazão\r\n  datas_dia <- seq.Date(from = min(dados_estacao$Data),\r\n                        to = max(dados_estacao$Data) %m+% months(1) - 1,\r\n                        by = \"day\")\r\n  \r\n  tabela_final <- data.frame(Cod_estacao = dados_estacao$EstacaoCodigo[1],\r\n                             Data = as.character(datas_dia),\r\n                             Vazao = as.numeric(NA))\r\n  \r\n  \r\n  for(i in 1:nrow(tabela_final)){\r\n    # Dia em análise\r\n    dia <- as.numeric(substr(tabela_final$Data[i], 9, 10))\r\n    \r\n    # Mês e ano em análise\r\n    mes_ano <- as.Date(paste0(substr(tabela_final$Data[i], 1, 8), \"01\"))\r\n    \r\n    # Olhar a linha do mes e ano e escolher a coluna pelo dia + 15\r\n    linha_dado <- which(dados_estacao$Data == mes_ano)\r\n    \r\n    # Se não tiver o mês nos dados da estação, colocar valor NA\r\n    ifelse(length(linha_dado) == 0,\r\n           tabela_final$Vazao[i] <- NA,\r\n           tabela_final$Vazao[i] <-\r\n             as.numeric(dados_estacao[linha_dado, (dia + 15)]))\r\n    \r\n  }\r\n  \r\n  return(tabela_final)\r\n}\r\n\r\n\r\nPrecisamos escolher uma estação fluviométrica para realizar nossa\r\nanálise. SUgiro utilizar a estação 60435000, localizada\r\nna bacia do Rio Descoberto, que drena uma área de \\(113.2 km^2\\), mas vocês têm a indepedência\r\nde escolhar qualquer outras estação que esteja no banco de dados da\r\nAgência Nacional de Águas.\r\nPara obter a série diária da estação escolhida, basta chamar a função\r\nacima passando o argumento necessário, que é simplesmente o código da\r\nestação desejada. A função devolve um dataframe com a série de máximos\r\nanuais.\r\nPara fins de visualização, utilizamos a função\r\nhead(nome_do_dataframe) do R, como mostrado abaixo, que nos\r\nmostra as primeiras 6 linhas do dataframe.\r\n\r\n\r\ndados_60435000 <- dados_serie_ANA(cod_estacao = 60435000)\r\nindex_falha_diario <- which(is.na(dados_60435000[,3]==TRUE))\r\ndias_falha <- dados_60435000[index_falha_diario,2:3]\r\nhead(dados_60435000)\r\n\r\n  Cod_estacao       Data Vazao\r\n1    60435000 1978-05-01    NA\r\n2    60435000 1978-05-02    NA\r\n3    60435000 1978-05-03    NA\r\n4    60435000 1978-05-04    NA\r\n5    60435000 1978-05-05    NA\r\n6    60435000 1978-05-06    NA\r\n\r\nAlém disso, é sempre importante visualizar os dados para que se teha\r\numa ideia geral da faixa de variação das vazões, sazonalidade e outras\r\npadrões que possa ser percebidos num gráfico.\r\nAqui, nós plotaremos a série completa das vazões diárias da estação\r\n60435000 utilizando o código abaixo, que emprega o\r\nchamado R-base, ao invés de pacote ggplot2.\r\n\r\n\r\ntime <- as.Date(dados_60435000$Data)\r\nplot(time,dados_60435000$Vazao,type=\"l\",\r\n     main = \"Vazões diárias - estação 60435000\",\r\n     xlab = \"Anos\",ylab = \"Q (m3/s)\")\r\n# Adiciona grid horizontal apenas\r\ngrid(nx = NA, ny = NULL,\r\n     lty = 2,      # Grid line type\r\n     col = \"gray\", # Grid line color\r\n     lwd = 2)      # Grid line width\r\n\r\n\r\n\r\nPode-se notar que nos seis primeiros dias dos dados, que se inicia em\r\nmaio de 1978, não temos valores registrados de vazão.\r\nExtração da série de\r\nvazões máximas anuais\r\nCom a série de vazões diárias, passamos ao segundo passo que é o de\r\nconstruir a série de máximos anuais com base no ano hidrológico. Para\r\nisso, utilizaremos uma outra função, que é apresentada abaixo. Veja que\r\na função internamente considera o ano hidrológico com início no mês de\r\nagosto. O mês de início do ano hidrológico pode ser facilmente alterado,\r\nse for o desejo do analista. Uma outra solução seria reesecrever a\r\nfunção incluindo como argumento o mês de início do ano hidrológico.\r\n\r\n\r\n# Contrução da série de máximos anuais a partir de um ano hidrológico ####\r\nfun_max_ano <- function(tabela = NA,\r\n                        comeco_ano_hidro = 8){\r\n  \r\n  # Transformar a coluna Data em \"Dates\" (caso esteja em character)\r\n  tabela$Data <- as.Date(tabela$Data)\r\n  \r\n  # Definir se o mês em questão entra no ano atual ou no próximo ano\r\n  desloc_ano <- ifelse(month(tabela$Data) < comeco_ano_hidro, 0, 1)\r\n  \r\n  # Ano Hidro\r\n  tabela$ano_hidro <- year(tabela$Data) + desloc_ano\r\n  \r\n  # Fazer uma tabela final apenas com os máximos anuais\r\n  max_anuais <-\r\n    tabela %>%\r\n    group_by(Cod_estacao, ano_hidro) %>%\r\n    summarise(maxima = max(Vazao))\r\n}\r\n\r\n\r\nPara finalmente obtermos a série de máximos anuais, basta chamar a\r\nfunção fornecendo o arquivo que contém as séries diárias de vazão, que\r\nno nosso caso é o dados_60435000. Mais uma vez, podemos\r\nutilizar a função head para dar uma leve espiada nas\r\ninformoações contidas no dataframe.\r\n\r\n\r\nQ_max <- fun_max_ano(dados_60435000)\r\nhead(Q_max)\r\n\r\n# A tibble: 6 × 3\r\n# Groups:   Cod_estacao [1]\r\n  Cod_estacao ano_hidro maxima\r\n  <chr>           <dbl>  <dbl>\r\n1 60435000         1978   NA  \r\n2 60435000         1979   16.1\r\n3 60435000         1980   28.9\r\n4 60435000         1981   11.1\r\n5 60435000         1982   12.8\r\n6 60435000         1983   25.3\r\n\r\nA função fun_max_ano foi escrita de forma que qualquer\r\nfalha na série de vazões diárias num dado ano hidrológico resulta numa\r\nfalha na série de máximos anuais. Isso nem semrpe é necessário, já que\r\nfalhas no período de estiagem não indicam falhas nas séries de máximos,\r\nmas creio que a função nos serve bem para este curso.\r\nPodemos notar a presença de um NA na nossa plotagem\r\nacima. É interessante verificar o número total de anos disponíveis com\r\ndados diários de vazão, bem como o número de anos com falaha na série de\r\nmáximos anuais.\r\nO número de anos com dados de vazões diárias pode ser obtidos\r\nsimplemente identificando o número de linhas no dataframe\r\nQ_max, e para isso utilizamos o código abaixo,\r\n\r\n\r\nn_anos <- nrow(Q_max)\r\nn_anos\r\n\r\n[1] 45\r\n\r\nMas já sabemos que o ano de 1978 não contém o valor de vazão máxima\r\nporque a série de vazões diárias não estava complete. Será que há outros\r\nanos no histórico com esse problema. Para identificar se há falha em\r\noutros anos, utilizaremos duas funções do R de forma conjunta,\r\nis.na e which. A função is.na\r\nidentifica se o elemento é um NA ou não, retornando um\r\nvalor lógico, TRUE ou FALSE, enquanto a função\r\nwhich permite identificar a posição de uma dada condição. O\r\ncódigo abaixo permite identificar em quais anos ocorrem falhas na série\r\nde máximos anuais,\r\n\r\n\r\nindex <- which(is.na(Q_max[,3]==TRUE))\r\nanos_falha <- Q_max[index,2:3]\r\nanos_falha\r\n\r\n# A tibble: 3 × 2\r\n  ano_hidro maxima\r\n      <dbl>  <dbl>\r\n1      1978     NA\r\n2      2009     NA\r\n3      2020     NA\r\n\r\nA primeira linha de código identifica as posições em que há a\r\npresença de NA na terceira coluna do dataframe, que é a\r\ncoluna com as informações sobre as vazões máximas de cada ano\r\nhidrológico, e associa à variável index. Na linha seguinte,\r\ncriamos um novo dataframe com a informação dos anos em que temos falhas\r\nnos dados.\r\nÉ verdade que poderíamos ter escrito o código acima de uma forma mais\r\ncompacta, porém ficaria mais difícil de entender. Veja o que vocÊ\r\nacha?\r\n\r\n\r\nanos_falha <- Q_max[which(is.na(Q_max[,3]==TRUE)),2:3]\r\nanos_falha\r\n\r\n# A tibble: 3 × 2\r\n  ano_hidro maxima\r\n      <dbl>  <dbl>\r\n1      1978     NA\r\n2      2009     NA\r\n3      2020     NA\r\n\r\nMais à frente, quando tivermos que fazer os cálculos necessários para\r\nrealizar a naálise de frequência, teremos que nos livrar desses anos com\r\nfalhas. Mas por enquanto vamos deixá-los ocmo estão, e passemos a etapa\r\nseguinte que é a de visualizar a série de máximos anuais.\r\nVisualização da série\r\nde máximos anuais\r\nAgora já podemos visualizar a série de máximos anuais que serivirão\r\nde base para a nossa análise de frequência. Essa visaulização pode ser\r\nfeita com o código abaixo, que utiliza apenas o R-base.\r\n\r\n\r\nplot(Q_max$ano_hidro,Q_max$maxima,type = \"o\",\r\n     main = \"Máximos anuais - 60435000\",\r\n     xlab = \"Anos\",ylab = \"Q_max (m3/s)\",lwd = 2)\r\n# Adiciona grid\r\ngrid(nx = NULL, ny = NULL,\r\n     lty = 2,      # Grid line type\r\n     col = \"gray\", # Grid line color\r\n     lwd = 1)      # Grid line width\r\n\r\n\r\n\r\nConstrução da curva\r\nde frequência amostral\r\nPosição de plotagem\r\nPara que possamos plotar os círculos azuis escuros da Figura\r\napresentada anteriormente, para o caso do Rio Salado, que representam as\r\nvazões máximas anuais observadas na série histórica, precisamos\r\ndeterminar as chamadas posição de plotagem, que para a referida Figura é\r\no tempo de recorrência estimado para cada um desses valores.\r\nPara que seja possível entender esta etapa, vale a pena investir um\r\ncerto tempo do curso em alguns conceitos básicos.\r\nO tempo de recorrência associado a uma determinada magnitude de\r\nvazão, \\(T_r(q)\\), é um conceito\r\nhidrológico bastante conhecido, de forma que não dedicaremos muito tempo\r\npara discutí-lo aqui. Por definição, o tempo de recorrência de um\r\nevento, cuja magnitude vale \\(q\\), é\r\nigual ao inverso da probabilidade da vazão máxima anual exceder esse\r\nvalor,\r\n\\[T_r(q) =\r\n\\frac{1}{P(Q>q)}\\]\r\nPor exemplo, se a probabilidade da vazão máxima anual ultrapassar um\r\ndado valor \\(q\\) for igual a 0.10,\r\ndizemos que o tempo de recorrência dessa vazão \\(q\\) é de 10 anos. Da mesma forma, se \\(P(Q>q)=0.01\\), dizemos que o tempo de\r\nrecorrência de \\(q\\) vale 100 anos.\r\nPortanto, para que possamos incluir as vazões observadas na nossa\r\ncurva de frequência, será preciso determinar a probabilidade de\r\nexcedência de cada uma das observações contidas na série de vazões\r\nmáximas anuais da localidade de interesse. Como o intuito neste primeiro\r\nmomento é plotar as vazões observadas na curva de frequência, nos\r\nbasearemos na chamada distribuição empírica de frequência.\r\nA distribuição empírica de frequência relaciona cada valor de vazão\r\nmáxima observada na série histórica, denominada aqui de \\(q_i\\), com sua frequência relativa\r\nacumulada, \\(\\hat{F}_Q(q_i)\\), que\r\nrepresenta a nossa estimativa para a probabilidade da variável de\r\ninteresse, \\(Q\\), ser menor ou igual ao\r\nvalor amostral, \\(q_i\\),\r\n\\[\\hat{F}_Q(q_i) = \\hat{P}(Q \\le\r\nq_i)\\]\r\nem que \\(\\hat{F}_Q\\) é a estimativa\r\nda frequência relativa acumulada da variável aleatória \\(Q\\) baseada na amostra, enquanto \\(q_i\\) reprenta o valor de uma dada\r\nobservação \\(i\\). O uso do acento\r\ncircunflexo na equação acima é uma convenção utilizada em estatística\r\npara mostrar que estamos nos referindo a uma estimativa da grandeza em\r\nquestão baseada na amostra que se tem em mãos.\r\nBem, quando falamos em \\(T_r(q)\\),\r\nnos referimos à probabilidade de excedência, que é na verdade o\r\ncomplemento de \\(\\hat{F}_Q(q_i)\\), ou\r\nseja,\r\n\\[\\hat{P}(Q \\gt q_i) = 1 - \\hat{P}(Q \\le\r\nq_i)\\] de forma que\r\n\\[\\hat{T}_r(q_i) = \\frac{1}{1-\\hat{P}(Q\r\n\\le q_i)}\\]\r\nPode parecer estranho se você estiver vendo isso pela primeira vez,\r\nmas a verdade é que há diferentes maneiras de se estimar a distribuição\r\nempírica de frequência das observações de uma amostra,\\(\\hat{P}(Q\\le q_i)\\), ou seu complemento,\r\n\\(\\hat{P}(Q\\gt q_i)\\).\r\nUma maneira bem comum de estimar tais probabilidades, quando se tem\r\numa amostra de tamanho \\(n\\), consiste\r\nem ordenar a série em ordem decrescente e determinar a probabilidade de\r\nexcedência utilizando a seguinte fórmula,\r\n\\[\\hat{P}(Q > q_{(i)}) = 1 -\r\n\\hat{F}_Q(q_{(i)}) = \\frac{i}{n+1}\\]\r\nem que \\(q_{(i)}\\) representa a\r\nchamada estatística de ordem \\(i\\), em\r\nque \\(q_{(1)}\\gt q_{(2)}\\gt \\ldots \\gt\r\nq_{(n)}\\), de forma que \\(q_{(1)}\\) e \\(q_{(n)}\\) são, respectivamente, a maior e a\r\nmenor observações da amostra. De acordo com essa expressão, por exemplo,\r\nnuma amostra de tamanho 49, a probabilidade da vazão máxima anual ser\r\nmaior do que a maior observação da amostra vale \\(P(Q>q_{(1)})=0.02\\)), o que resulta num\r\ntempo de recorrência de \\(T_r(q_{(1)})=50\\) anos.\r\nNão se preocupe tanto se esse conceito de posição de plotagem não\r\nficou totalmente claro. Basta saber que plotaremos os valores de máximos\r\nanuais da amostra na curva de frequência utilizando a posição de\r\nplotagem de Weibull.\r\nNa verdade, utilizaremos o tempo de recorrência, \\(T_r\\), para plotagem, lembrando que o \\(T_r\\) é simplemenste o inverso da\r\nprobabilidade de excedência, representada pela posição de plotagem de\r\nWeibull.\r\nO código para o cálculo do \\(Tr\\) é\r\napresentado abaixo. Para facilitar a compreenção de como o cálculo é\r\nfeito, criaram-se três novas colunas ao dataframe que contém as vazões\r\nmáximas anuais. Mas antes disso, efetuou-se o ordenamento das vazões\r\nmáximas em ordem decrescente, ou seja, o primeiro valor de vazão da nova\r\nsérie ordenada é o maior da amostra.\r\nAs três novas colunas são, respectivamente, o índice das vazões,\r\ncomeçando de 1 indo até o número total de valores, a posição de plotagem\r\nde Weilbull, que expressa a probabilidade de excedência, e por último o\r\ntempo de recorrência, \\(Tr\\).\r\n\r\n\r\n# Remoção dos anos com falha\r\nQ_max <- na.omit(Q_max)\r\n# Ordenamento decrescente do dataframe\r\nQ_max_ord <- Q_max[order(Q_max$maxima, decreasing = TRUE), ]\r\n# Inclusão de Três novas colunas: index, posição de plotagem de Weibull, e Tr\r\nQ_max_ord$index <- seq(from = 1,to = nrow(Q_max_ord))\r\nQ_max_ord$weibull <- Q_max_ord$index/(nrow(Q_max_ord) + 1)\r\nQ_max_ord$Tr <- 1/Q_max_ord$weibull\r\n\r\n\r\nComo já fizemos antes, podemos dar uma espiada nesse novo dataframe\r\ncom as vazões máximas anuais ordenada utilizando a função\r\nhead(dataframe_name),\r\n\r\n\r\nhead(Q_max_ord)\r\n\r\n# A tibble: 6 × 6\r\n# Groups:   Cod_estacao [1]\r\n  Cod_estacao ano_hidro maxima index weibull    Tr\r\n  <chr>           <dbl>  <dbl> <int>   <dbl> <dbl>\r\n1 60435000         2004   37.5     1  0.0233 43   \r\n2 60435000         1980   28.9     2  0.0465 21.5 \r\n3 60435000         1983   25.3     3  0.0698 14.3 \r\n4 60435000         1994   19.3     4  0.0930 10.8 \r\n5 60435000         2016   17.8     5  0.116   8.6 \r\n6 60435000         1988   17.1     6  0.140   7.17\r\n\r\nA última coluna de Q_max_ord contém o valor do tempo de\r\nrecorrência de cada uma das observações contidas na amostra. Vale notar\r\nque as observações em Q_max_ord estão ordenadas em ordem\r\ndecrescente.\r\nPodemos agora criar uma Figura, similar àquela apresentada para o\r\nestudo do Rio Salado. Porém, nesta etapa de nossa análise, apenas os\r\nvalores amostrais das vazões máximas serão apresentados.\r\n\r\n\r\nplot(Q_max_ord$Tr,Q_max_ord$maxima,type = \"p\", pch = 19,cex = 1.5,col = \"blue\",\r\n     log = \"x\",main = \"Curva de frequência de cheias - 60435000\",\r\n     xlab = \"Tr (anos)\",ylab = \"Q_max (m3/s)\",\r\n     xlim = c(1, 100),   # X-axis limits\r\n     ylim = c(1, 50))\r\n# Adiciona grid horizontal\r\naxis(1, at = c(seq(1,10,by=1),seq(10,100,by=10),seq(200,1000,by=100)),\r\n     tck = 1, lty = 2, col = \"gray\")\r\n# Adiciona grid vertical\r\naxis(2, tck = 1, lty = 2, col = \"gray\")\r\n\r\n\r\n\r\nAjuste de\r\numa distribuição teórica de probabilidades\r\nA distribuição lognormal\r\nSe considerarmos que as vazões máximas anuais \\((Q)\\) possuem uma distribuição lognormal,\r\nentão os logaritmos de \\(Q\\), chamados\r\naqui de \\(Y = ln(Q)\\), terão, por\r\ndefinição, uma distribuição normal,\r\n\\[\r\nY = ln(Q) \\sim N(\\mu_Y,\\sigma_Y^2)\r\n\\] o que significa dizer que os logarítmicos das vazões máximas\r\nanuais são bem representados por uma distribuição Normal com parâmetros\r\n\\(\\mu_Y\\) e \\(\\sigma_Y^2\\), que, para quem não lembra,\r\nrepresentam a média e a variância populacionais.\r\nO adjetivo populacional utilizado aqui é para lembrarmos que essas\r\ncaracerísticas da distribuição são, na verdade, desconhecidas. A única\r\npista que temos sobre o valor desses parâmetros está contida na amostra\r\nque temos, formada por um conjunto de vazões máximas anuais. A maneira\r\nque utilizaremos a amostra para tentar compreender essa distribuição é o\r\nassunto da próxima seção.\r\nQuantis de cheia da\r\nlognormal\r\nÉ muito provável que vocês não se recordem, mas a distribuição Normal\r\npossui uma caracterísitca bastante interessante. Se aplicarmos uma\r\ntransformação linear numa variável normalmente distribuída, a nova\r\nvariável continua sendo normalmente distribuída, porém com diferentes\r\nvalores para os parâmetros da distribuição.\r\nUma transformação bastante útil é aquela em que a variável é\r\ntransformada numa variável normal-padrão, usualmente representada pela\r\nletra \\(Z\\). A variável normal-padrão\r\n\\(Z\\) possui média zero e variância\r\nunitária, \\(Z \\sim N(0,1)\\). Qualquer\r\nvariável que possui distribuiçao Normal pode ser transformada numa\r\nvariável normal-padrão, bastando subtrair sua média e dividir pelo seu\r\ndesvio-padrão,\r\n\\[\r\nZ = \\frac{Y-\\mu_Y}{\\sigma_Y}\\sim N(0,1)\r\n\\]\r\nEssa transformação é bastate útil aqui, pois utilizaremos o quantil\r\nda variável normal-padrão, \\(Z_p\\),\r\npara escrever o quantil de \\(Y\\), \\(Y_p\\), e também o quantil de cheia, \\(Q_p\\).\r\nQuantil de uma variável aleatória, para quem não se lembra, é o valor\r\nda variável associado a uma dada probabilidade de não-excedência. Por\r\nexemplo, por definição, a probabilidade da variável aleatória \\(X\\) ser menor ou igual ao quantil \\(x_p\\) é igual a p,\r\n\\[\r\nP(X\\le x_p)=p\r\n\\] Portanto, a probabilidade da variável normal-padrão, \\(Z\\), ser menor do que os quantis \\(Z_{0.10}\\), \\(Z_{0.50}\\) e \\(Z_{0.90}\\) é, respectivamente, 0.10, 0.50 e\r\n0.90.\r\nComo \\(Z = (Y-\\mu_Y)/\\sigma_Y\\),\r\npodemos dizer que \\(Z_p =\r\n(Y_p-\\mu_Y)/\\sigma_Y\\), de forma que\r\n\\[\r\nY_p = \\mu_Y + Z_p\\sigma_Y\r\n\\] E como \\(Y=ln(Q)\\), podemos\r\nafirmar que\r\n\\[\r\nQ_p = exp(\\mu_Y + Z_p\\sigma_Y)\r\n\\] em que \\(Q_p\\) é o quantil\r\npopulacional da variável aleatória \\(Q\\), que representa as vazões máximas\r\nanuais. Da mesma for que \\(\\mu_y\\) e\r\n\\(\\sigma_Y\\) são desconhecidos, \\(Q_p\\) também é. A única maneira de estimar\r\n\\(Q_p\\) é por meio das estimativas de\r\n\\(\\mu_Y\\) e de \\(\\sigma_Y\\).\r\nMétodo de ajuste\r\nExistem diversos métodos para ajustar uma distribuição teórica de\r\nprobabilidades aos dados que se tem em mãos. Para o caso da distribuição\r\nlognormal com 2 parâmetros, sabe-se que a forma mais eficiente de\r\nestimar os parâmetros \\(\\mu_Y\\) e \\(\\sigma_Y^2\\) é por meio do método dos\r\nmomentos, que será explicado na sequência.\r\nCom base numa série de vazões máximas anuais \\(\\{Q_1,Q_2,\\ldots,Q_n\\}\\), determinamos uma\r\nnova série com base no logarítmos da série original, \\(Y = \\{Y_1,Y_2,\\ldots,Y_n\\}\\).\r\nEm seguida, aplicamos o métodos dos momentos para estimar \\(\\mu_Y,\\sigma_Y^2\\), o que consiste em igual\r\nesses parâmetros aos seus valores amostrias, ou seja,\r\n\\[\r\n\\hat{\\mu}_Y = \\bar{Y} = \\frac{\\sum_1^n y_i}{n}\r\n\\] e\r\n\\[\r\n\\hat{\\sigma}_Y^2 = \\frac{\\sum_{i=1}^n (y_i - \\bar{Y})^2}{n-1}\r\n\\] Vale notar mais uma vez que \\(\\hat{\\mu}_Y\\) e \\(\\hat{\\sigma}_Y^2\\) possuem um acento\r\ncircunflexo para indicar que eles são os estimadores amostrais dos\r\nparâmetros populacionais \\(\\mu_Y\\) e\r\n\\(\\sigma_Y^2\\).\r\nCom os valores de \\(\\hat{\\mu}_Y\\) e\r\n\\(\\hat{\\sigma}_Y^2\\), podemos estimar\r\nos quantis de \\(Y\\) e de \\(Q\\),\r\n\\[\r\n\\hat{Y}_p = \\hat{\\mu}_Y + Z_p\\hat{\\sigma}_Y\r\n\\] e\r\n\\[\r\n\\hat{Q}_p = exp(\\hat{\\mu}_Y + Z_p\\hat{\\sigma}_Y)\r\n\\]\r\nAjuste da\r\nlognormal e estimativa dos quantis\r\nEntão, vamos ao que interessa. Temos basicamente que realizar três\r\netapas para determinar os quantis de cheia com base na distribuição\r\nlognormal,\r\nConstruir a série \\(Y =\r\nln(Q)=\\{Y_1,Y_2,\\ldots,Q_n\\}\\)\r\nEstimar os parâmetros \\(\\mu_y\\) e\r\n\\(\\sigma_Y^2\\) por meio dos estimadores\r\n\\(\\hat{\\mu}_Y\\) e \\(\\hat{\\sigma}_Y^2\\)\r\nEstimar os quantis de cheia, \\(Q_p\\), por meio do estimador \\(\\hat{Q}_p = exp(\\hat{\\mu}_Y +\r\nZ_p\\hat{\\sigma}_Y)\\)\r\nO código para realizar esse ajuste segue abaixo,\r\n\r\n\r\n# Determinar a nova série Y = ln(Q)\r\nQ_max_ord$Y <- log(Q_max_ord$maxima)\r\n\r\n# Estimar os parâmetros da distribuição Normal, sabendo que Y ~ N(mu_y,sigma2_Y)\r\nmu_Y_hat <- mean(Q_max_ord$Y)\r\nsigma2_hat <- var(Q_max_ord$Y)\r\n\r\n# Estimar os quantis de Y e de Q\r\np <- seq(from = 0.01,to = 0.99,by = 0.01)     # define valores de p que serão empregados para os quantis\r\nTr <- 1/(1-p)                                 # Calcula os tempos de recorrência para cada valro de p\r\nz_p <- qnorm(p, 0, 1)                         # quantil da normal-padrão\r\ny_p_hat <- mu_Y_hat + z_p*sqrt(sigma2_hat)    # estimativa do quantil de Y\r\nq_p_hat <- exp(y_p_hat)                       # estimativa do quantil de Q\r\n\r\n# Criação de um dataframe com os quantis de cheia\r\nQuantis_Q <- data.frame(q_p_hat,Tr)\r\n\r\n\r\nPodemos dar uma espiada no dataframe que contém os quantis de cheia\r\nutilizando a função head(dataframe.name),\r\n\r\n\r\nhead(Quantis_Q)\r\n\r\n   q_p_hat       Tr\r\n1 3.603989 1.010101\r\n2 4.101790 1.020408\r\n3 4.452708 1.030928\r\n4 4.736340 1.041667\r\n5 4.980326 1.052632\r\n6 5.197874 1.063830\r\n\r\nPodemos perceber que os seis primeiros valores dos quantis estimados\r\nnão são tão interessantes, pois eles estão associados a tempos de\r\nrecorrência muito baixos. Existe uma outra função no função no\r\nR que permite espiar a parte final do dataframe, ao invés\r\nda parte inicial. Essa função é chamada de\r\ntail(dataframe.name).\r\n\r\n\r\ntail(Quantis_Q,5)\r\n\r\n    q_p_hat        Tr\r\n95 23.73313  20.00000\r\n96 24.95571  25.00000\r\n97 26.54536  33.33333\r\n98 28.81638  50.00000\r\n99 32.79664 100.00000\r\n\r\nO número 5 no código acima serve para especificar\r\nquantas linhas eu estou interessado em ver.\r\n\r\n\r\nplot(Q_max_ord$Tr,Q_max_ord$maxima,type = \"p\", pch = 19,cex = 1.5,col = \"blue\",\r\n     log = \"x\",main = \"Curva de frequência de cheias - 60435000\",\r\n     xlab = \"Tr (anos)\",ylab = \"Q_max (m3/s)\",\r\n     xlim = c(1, 100),   # X-axis limits\r\n     ylim = c(1, 50))\r\n\r\n# Adiciona a LN2\r\nlines(Quantis_Q$Tr,Quantis_Q$q_p_hat,\r\n      col = \"red\",\r\n      lwd = 2)\r\n\r\n# Adiciona grid horizontal\r\naxis(1, at = c(seq(1,10,by=1),seq(10,100,by=10),seq(200,1000,by=100)),\r\n     tck = 1, lty = 2, col = \"gray\")\r\n# Adiciona grid vertical\r\naxis(2, tck = 1, lty = 2, col = \"gray\")\r\n\r\n\r\n\r\nDeterminação dos quantis de\r\ncheia\r\nDescrição das incertezas\r\nQuando realizamos uma análise de frequência, além da estimativa dos\r\nquantis de cheia, precisamos ter uma ideia doo quão confiantes estamos\r\nem relação aos valores estimados. Sendo assim, precisamos entender como\r\ncalcular a precisão dessas estimativas.\r\nNormalmente, a maneira que empregamos para descrever as incertezas\r\nnas estiamtovas dos quantis de cheias é por meio de intervalos de\r\nconfiança.Neste nosso exercício aqui, aprenderemos como calcular\r\nintervalos de confiança associados à distribuição lognormal, que é a\r\ndistribuição que está sendo utilizados por nós para construir a curva de\r\nfrequência.\r\nExistem duas maneiras de se calcular intervaloes de confiança para a\r\ndistribuição lognormal,\r\nintervalos aproximados\r\nintervalos exatos\r\nAqui aprenderemos como determinar intervalos de confiança aproximados\r\npara os quantis de cheia oriundos da distribuição lognormal.\r\nLógica\r\nda construção de intervalos de confiança aproximados\r\nSuponha que tenhamos uma estimador qualquer denominado \\(\\hat{W}_p\\). Estou usando a variável \\(W\\) apenas para reforçar a ideia de que não\r\nprecisa ser aquele estimador apresentado anteriormente, que chamamos de\r\n\\(\\hat{Q}_p\\), embora possa ser.\r\nPara a quase totalidade de possíveis estimadores, quando \\(n\\rightarrow \\infty\\), ou em outras\r\npalavras, à medida que a amostra aumenta e passa a ter um número bem\r\ngrande de observações, esses estimadores tendem a ter uma distribuição\r\nNormal. Como um estimador depende da amostra que se tem em mãos, ele é\r\ntambém uma variável aleatória. E como toda variável aleatória, seu\r\ncomportamento pode se descrito por uma distribuição teórica de\r\nprobabilidades.\r\nBem, se \\(\\hat{W}_p\\) possui\r\ndistribuição Normal e variância \\(V(\\hat{W}_p)\\), então\r\n\\[\r\nZ = \\frac{\\hat{W}_p-E[\\hat{W}_p]}{\\sqrt{V(\\hat{W}_p)}}\r\n\\] Como \\(Z\\sim N(0,1)\\),\r\npodemos afirmar que\r\n\\[\r\nP(z_{\\alpha/2}\\le Z \\le z_{1-\\alpha/2}) = \\alpha\r\n\\] Se substituirmos \\(Z\\) da\r\nequação acima pela equação anterior, obtemos\r\n\\[\r\nP\\Bigg(z_{\\alpha/2}\\le\r\n\\frac{\\hat{W}_p-E[\\hat{W}_p]}{\\sqrt{V(\\hat{W}_p)}} \\le\r\nz_{1-\\alpha/2}\\Bigg) = \\alpha\r\n\\] Depois de algumas manipulações algébricas, e admitindo que o\r\nestimador _p é não-tendencioso, o que significa dizer que \\(E[\\hat{W}_p]=W_p\\), chegamos à afirmação\r\nabaixo,\r\n\\[\r\nP\\Bigg(\\hat{W}_p - z_{1-\\alpha/2}\\sqrt{V(\\hat{W}_p)} \\le W_p \\le\r\n\\hat{W}_p + z_{1-\\alpha/2}\\sqrt{V(\\hat{W}_p)}\\Bigg) = \\alpha\r\n\\] que em bom português diz que a probabilidade do valor\r\npopulacional de \\(W_p\\) estar entre\r\nesses dois limites, \\(\\hat{W}_p \\pm\r\nz_{1-\\alpha/2}\\sqrt{V(\\hat{W}_p)}\\) é igual à \\(\\alpha\\). É essa afirmação matemática que\r\nnos permite estabelecer o intervalo de confiança de \\(100(1-\\alpha)\\%\\) para \\(W_p\\), apresentado abaixo,\r\n\\[\r\n\\Bigg[\\hat{W}_p - z_{1-\\alpha/2}\\sqrt{V(\\hat{W}_p)};\\hat{W}_p +\r\nz_{1-\\alpha/2}\\sqrt{V(\\hat{W}_p)}\\Bigg]\r\n\\]\r\nSendo assim, podemos construir o intervalo de confiança aproximado de\r\n\\(Y_p=ln(Q_p)\\) e de \\(Q_p\\), que é o que de fato nos\r\ninteressa.\r\nPrimeiro, constuímos o intervalo de confiança aproximado de \\(Y_p\\),\r\n\\[\r\n\\Bigg[\\hat{Y}_p - z_{1-\\alpha/2}\\sqrt{V(\\hat{Y}_p)};\\hat{Y}_p +\r\nz_{1-\\alpha/2}\\sqrt{V(\\hat{Y}_p)}\\Bigg]\r\n\\]\r\nO problema aqui é que ainda precisamos saber quem é \\(V(\\hat{Y}_p)\\). Este não é um curso de\r\nestatística, mas sim de R aplicado à Hidrologia. Por isso,\r\ndeixarei a explicação de como determinar \\(V(\\hat{Y}_p)\\) num local separado,\r\n\r\nThere is a lot of information within this practical book and\r\nwe do not expect you to read everything we link to. You\r\nshould attend each lecture, go through every practical and do some\r\nassociated reading.\r\nThis is a 15 credit module, equivalent to 150 hours of study\r\n(including the taught sessions). Outside of our lectures and practical\r\nsessions (3 hours a week) you should be spending an extra 12\r\nhours a week on this module.\r\n\\[\r\n\\begin{align}\r\nV(\\hat{Y}_p) &= V(\\hat{\\mu}_y + z_p\\hat{\\sigma}_Y)\\\\\r\n             &= V(\\hat{\\mu}_y) + V(z_p\\hat{\\sigma}_Y)\\\\\r\n             &= V(\\hat{\\mu}_y) + z_p^2V(\\hat{\\sigma}_Y)\\\\\r\n             &= \\frac{\\hat{\\sigma}_Y^2}{n} + z_p^2V(\\hat{\\sigma}_Y)\r\n\\end{align}\r\n\\]\r\n\r\n\\[\r\n\\begin{align}\r\nV(\\hat{Y}_p) &= V(\\hat{\\mu}_y + z_p\\hat{\\sigma}_Y)\\\\\r\n             &= V(\\hat{\\mu}_y) + V(z_p\\hat{\\sigma}_Y)\\\\\r\n             &= V(\\hat{\\mu}_y) + z_p^2V(\\hat{\\sigma}_Y)\\\\\r\n             &= \\frac{\\hat{\\sigma}_Y^2}{n} + z_p^2V(\\hat{\\sigma}_Y)\r\n\\end{align}\r\n\\] Pode-se mostrar que \\(V(\\sigma_Y)\\approx \\hat{\\sigma}_Y^2/(2n)\\),\r\no que resulta na seguinte expressão para \\(V(\\hat{Y}_p)\\),\r\n\\[\r\nV(\\hat{Y}_p) \\approx\r\n\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_p^2\\Bigg)\r\n\\]\r\nDessa forma, o intervalo de confiança de \\(100(1-\\alpha)\\%\\) para \\(Y_p\\) pode ser descrito como\r\n\\[\r\n\\Bigg[\\hat{Y}_p -\r\nz_{1-\\alpha/2}\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_p^2\\Bigg)};\\hat{Y}_p\r\n+\r\nz_{1-\\alpha/2}\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_p^2\\Bigg)}\\Bigg]\r\n\\]\r\nPara determinar o o intervalo de confiança de \\(100(1-\\alpha)\\%\\) para \\(Q_p\\), basta exponenciar o intervalo\r\nacima,\r\n\\[\r\n\\begin{align}\r\nIC_{(1-\\alpha)}(Q_p) &= exp\\Bigg[\\hat{Y}_p \\pm\r\nz_{1-\\alpha/2}\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_p^2\\Bigg)}\\Bigg]\\\\\r\n               &= exp\\Bigg[(\\hat{\\mu}_Y+z_p\\hat{\\sigma}_y) \\pm\r\nz_{1-\\alpha/2}\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_p^2\\Bigg)}\\Bigg]\r\n\\end{align}\r\n\\]\r\nPor exemplo, suponha que queiramos estabelecer o intervalo de\r\nconfiança de 95% para o quantil \\(Q_99\\), equivalente à cheia de 100 anos de\r\nrecorrência. Nesse caso, \\(\\alpha =\r\n0.05\\) e \\(p=0.99\\), o que leva\r\na seguinte intervalo de confiança,\r\n\\[\r\n\\begin{align}\r\nIC_{.95}(Q_{0.99}) &= exp\\Bigg[(\\hat{\\mu}_Y+z_{.99}\\hat{\\sigma}_y)\r\n\\pm\r\nz_{.975}\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_{.99}^2\\Bigg)}\\Bigg]\\\\\r\n                    &=exp\\Bigg[(\\hat{\\mu}_Y+2.326\\hat{\\sigma}_y) \\pm\r\n1.96\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}2.326^2\\Bigg)}\\Bigg]\r\n\\end{align}\r\n\\]\r\n\r\n\r\nalpha <- 0.05\r\nvar_yp <- sigma2_hat/nrow(Q_max_ord)*(1 + z_p^2/2)\r\n\r\nlower_IC <- exp((mu_Y_hat + z_p*sqrt(sigma2_hat)) - qnorm(1-alpha/2,0,1)*sqrt(var_yp))\r\nupper_IC <- exp((mu_Y_hat + z_p*sqrt(sigma2_hat)) + qnorm(1-alpha/2,0,1)*sqrt(var_yp))\r\n\r\n\r\n\r\n\r\nplot(Q_max_ord$Tr,Q_max_ord$maxima,type = \"p\",           # plota apenas pontos\r\n     pch = 19,col = \"blue\", cex = 1.5,                   # círculos azuis de tamanho 1.5 \r\n     log = \"x\",                                          # escala logaritmica no eixo-x\r\n     main = \"Curva de frequência de cheias - 60435000\",  # título \r\n     xlab = \"Tr (anos)\",ylab = \"Q_max (m3/s)\",           # nome dos eixos\r\n     xlim = c(1, 100),                                   # limites od eixo-x              \r\n     ylim = c(1, 50))                                    # limites do eixo-y\r\n\r\n# Adiciona a LN2\r\nlines(Quantis_Q$Tr,Quantis_Q$q_p_hat,\r\n      col = \"red\",\r\n      lwd = 2)\r\n\r\n# Adiciona IC\r\nlines(Quantis_Q$Tr,lower_IC,\r\n      col = \"red\",lty = 2,\r\n      lwd = 2)\r\n\r\nlines(Quantis_Q$Tr,upper_IC,\r\n      col = \"red\",lty = 2,\r\n      lwd = 2)\r\n\r\n# Adiciona grid horizontal\r\naxis(1, at = c(seq(1,10,by=1),seq(10,100,by=10),seq(200,1000,by=100)),\r\n     tck = 1, lty = 2, col = \"gray\")\r\n# Adiciona grid vertical\r\naxis(2, tck = 1, lty = 2, col = \"gray\")\r\n\r\n\r\n\r\nInferência\r\nCálculo dos momentos-L\r\nDiagrama de momentos-L\r\nEstimativa dos\r\nparâmetros da distribuição\r\nCálculo dos quantis de cheia\r\nConstrução da curva de\r\nfrequência\r\nDescrição das\r\nincertezas (intervalo de confiança)\r\nCurva de frequência final\r\nDetalhes técnicos\r\nDistribuição de\r\nprobabilidades\r\nPara que servem?\r\nO uso de uma distribuição teórica de probabilidades se justifica por\r\ntrês motivos,\r\npermite a extrapolação da curva, ou seja, torna possível a\r\nestimativa de uma vazão com 50 anos tempo de retorno mesmo quando temos\r\napenas 20 anos de dados;\r\npode ser utilizada como um interpolador de quantis de cheia, já que\r\no uso da frequência amostral só permite estimar quantis para um número\r\ndiscreto, e nem sempre desejado, de períodos de retorno.\r\né uma maneira de armazenar as infomações relevantes da série de\r\nmáximos de maneira compacta, visto que basta guardar o valor dos\r\nparâmetro da distribuição para obter qualquer quantil de cheia que se\r\ntenha interesse.\r\nDetalhamento de posição de\r\nplotagem\r\nEmbora não seja o objetivo aqui deste curso entender os detalhes\r\ndeste procedimento, mas vale a pena dizer o seguinte: como a\r\ndistribuição empírica de frequência depende da amostra que se tem em\r\nmãos, ela é na verdade uma variável aleatória, ou seja, ela pode variar\r\nde amostra para amostra, de modo que é razoável imaginar que ela possui\r\numa distribuição de probabilidades.\r\nSuponha que fosse possível obter diversas amostras independentes da\r\nvariável de interesse, todas de tamanho \\(n\\) e oriundas de uma mesma distribuição de\r\nprobabilidades. Vale lembrar que na prática apenas uma amostra está\r\ndisponível. Embora não seja apresentado aqui o porquê, é possível\r\nmostrar que a probabilidade de não-excedência da estatística de ordem\r\n$X_{(i)}, \\(Q_i = P(X \\gt x_{(i)})\\) é\r\ntambém uma variável aleatória, pois depende da amostra. A distribuição\r\nde \\(Q_i\\) é uma Beta (i.e., possui uma\r\ndistribuição Beta) com valor esperado\r\n\\[E[Q_i] = \\frac{i}{n + 1}\\]\r\ne variância\r\n\\[V[Q_i] =\r\n\\frac{n-i+1}{(n+1)^2(n+2)}\\] independetente da dsitribuiçao da\r\nvariável de interesse.\r\nIsso significa, por exemplo, que numa amostra com 19 observações, o\r\nvalor esperado da probabilididade da variável de interesse ser maior do\r\nque a segunda maior observação da referida amostra, \\(Q_{(2)}\\), é igual a\r\n\\[E[Q_{(2)}]=\\frac{2}{20}=0.10\\]\r\nda mesma forma que o valor esperado da probabilididade da variável de\r\ninteresse ser maior do que a maior observação da referida amostra, \\(Q_{(1)}\\), é igual a\r\n\\[E[Q_{(1)}]=\\frac{1}{20}=0.05\\]\r\nPodemos concluir, portanto, que se estimarmos \\(F_X(x_{(i)})\\) utilizando a expressão \\(i/(n+1)\\), em média, utilizando várias\r\namostras, a média das estimativas de \\(F_X(x_{(i)})\\) seria bem próxima do valor\r\npopulacional, e o grau de proximidade aumenta com o tamanho da\r\namostra.\r\nPorém, é importanter deixar claro que quando há apenas uma amostra,\r\nnão é possível ter certeza de que a estimativa é correta, mas é\r\nintuitivo pensar que um estimador, que em média está correto, é de fato\r\num bom estimador. Mais à frente na aula, retornaremos à discussão sobre\r\nestimadores e suas características. Mas vale introduzir o conceito de\r\nestimador não tendencioso, que é aquele que na média, ao longo de várias\r\namostras, seu valor é igual ao valor populacional.\r\nPortanto, por se tratar de um estimador não-tendencioso da\r\nprobabilidade de não-excedência da estatística de ordem de uma amostra,\r\na expressão apresentada anteriormente é uma forte candidata a ser\r\nutilizada na construção da curva de distribuição empírica de frequência.\r\nPorém, como já mencionado anteriormente, há outras formas de se estimar\r\n\\(F_X(x_{(i)})\\), sendo que todas\r\nseguem a seguinte expressão, com diferença apenas para o valor do\r\nparâmetro \\(a\\).\r\n\\[P(X \\lt x_{(i)}) =\r\n\\frac{i-a}{n+1-2a}\\]\r\nA Tabela abaixo apresenta diversas expressões para o estimador de\r\n\\(F_X(x_{(i)})\\), incluindo a motivação\r\nde cada alternativa.\r\nNome\r\nFórmula\r\n\\(a\\)\r\n\\(T_n\\)\r\nMotivação\r\nWeibull\r\n\\(\\frac{i}{n+1}\\)\r\n0\r\n\\(n+1\\)\r\nEst. não-tendenciosa da Prob. de não-excedência para qualquer\r\ndistribuição teórica\r\nMediana\r\n\\(\\frac{i-0.3175}{n+0.365}\\)\r\n0.3175\r\n\\(1.47n+0.5\\)\r\nMediana das probabilidades\r\nAPL\r\n\\(\\frac{i-0.35}{n}\\)\r\n\\(~0.35\\)\r\n\\(1.54n\\)\r\nEstimador baseado em momentos probabilísticos\r\nBlom\r\n\\(\\frac{i-3/8}{n+1/4}\\)\r\n0.375\r\n\\(1.60n+0.4\\)\r\nQuantis normais não-tendenciosos\r\nCunnane\r\n\\(\\frac{i-0.40}{n+0.2}\\)\r\n0.40\r\n\\(1.67n+0.3\\)\r\nQuantis aproximadamente não-tendenciosos\r\nGrigorten\r\n\\(\\frac{i-0.44}{n+0.12}\\)\r\n0.44\r\n\\(1.79n+0.2\\)\r\nOtimizada para distribuição Gumbel\r\nHazen\r\n\\(\\frac{i-0.5}{n}\\)\r\n0.50\r\n\\(2n\\)\r\nEscolha tradicional\r\nQuais são as\r\ndistribuições mais usadas?\r\nComo avaliar a\r\ndistribuição mais indicada?\r\nAjuste dos parâmetros da\r\ndistribuição\r\nEstimativa dos quantis de\r\ncheia\r\nDescrição das incertezas\r\nPassos a serem executados\r\nVisualizar os dados\r\nEscolha da estação fluviométrica\r\nObtenção da série de máximos anuais\r\nCálculo das posições de plotagem\r\nConstrução de figura utilizando valores amostrais apenas\r\n\r\nInferência\r\nCálculo dos momentos-L para fins de verificação da distribuição\r\nteórica de probabilidades\r\nPlotagem do diagrama de momentos-L das distribuições teóricas\r\nAjuste dos parâmetros da distribuição teórica de probabilidades\r\nLognormal\r\nGeneralizada de valores extremos\r\n\r\nCálculo dos quantis de cheia\r\n\r\nCurva de frequência sem incertezas\r\nEstimativa dos intervalos de confiança para a distribuição\r\nLognormal\r\nCurva de frequência com intervalos de confiança\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-24T13:49:56-03:00"
    },
    {
      "path": "get_data.html",
      "title": "Obtenção de dados hidrológicos na web",
      "description": "Conceitos básicos",
      "author": [],
      "contents": "\r\n\r\nContents\r\nRepositório de dados\r\nObtenção de dados\r\n“tradicional”\r\nObtenção via webservice\r\nLista das Estações\r\nTelemétricas da ANA\r\nDados Hidrometeorológicos da\r\nANA\r\nSérie\r\nHistórica\r\nSalvar\r\narquivos\r\nSalvar um arquivo único\r\nSalvar em um\r\nloop\r\n\r\n\r\nRepositório de dados\r\nExistem inúmeros repositórios contendo dados hidrológicos no mundo e\r\nno Brasil. Alguns exemplos são:\r\nHidroWeb da ANA;\r\nSéries históricas do ONS;\r\nDados do CPRM;\r\nDados do INMET.\r\nObtenção de dados\r\n“tradicional”\r\nUma maneira de obter dados é simplesmente baixando eles de algum site\r\noficial. Geralmente o arquivo baixado está no formato .csv,\r\n.txt ou .xls (excel) - esse último sendo menos\r\ncomum. No próprio portal da ANA tem a opção de baixar os dados\r\ndiretamente se souber a estação em questão ou utilizando um mapa\r\ndinâmico. Fazemos o exemplo abaixo para a estação 60435000. Ao baixar o\r\narquivo, é importante entender como ele está salvo, para isso podemos\r\nabrir o arquivo pelo bloco de notas por exemplo. O arquivo em questão é\r\nmostrado na figura abaixo\r\n\r\n\r\n\r\nÉ possível perceber alguns detalhes importantes. As primeiras 13\r\nlinhas contém informações sobre o sistema em sí e a estação, mas os\r\ndados medidos começam de fato na linha 14. O separador de cada coluna é\r\num ; e os decimais são separados por ,. Agora\r\njá temos as informações necessárias para acessar esses dados pelo\r\nR. Usamos aqui a função read.table(),\r\ntambém é possível utilizar a função read.csv(), ambas fazem\r\na mesma coisa, apenas alteram os argumentos pré definidos (que podem ser\r\ntrocados).\r\n\r\n\r\ndados_ANA <- read.table(file = \"dados/vazoes_T_60435000.txt\",\r\n                        skip = 13,\r\n                        header = T,\r\n                        sep = \";\",\r\n                        dec = \",\")\r\n\r\n\r\nAgora podemos ver quais colunas existem nesse dataframe dentro do\r\npróprio R e tentar entender ele melhor também!\r\n\r\n\r\ncolnames(dados_ANA)\r\n\r\n [1] \"EstacaoCodigo\"        \"NivelConsistencia\"   \r\n [3] \"Data\"                 \"Hora\"                \r\n [5] \"MediaDiaria\"          \"MetodoObtencaoVazoes\"\r\n [7] \"Maxima\"               \"Minima\"              \r\n [9] \"Media\"                \"DiaMaxima\"           \r\n[11] \"DiaMinima\"            \"MaximaStatus\"        \r\n[13] \"MinimaStatus\"         \"MediaStatus\"         \r\n[15] \"MediaAnual\"           \"MediaAnualStatus\"    \r\n[17] \"Vazao01\"              \"Vazao02\"             \r\n[19] \"Vazao03\"              \"Vazao04\"             \r\n[21] \"Vazao05\"              \"Vazao06\"             \r\n[23] \"Vazao07\"              \"Vazao08\"             \r\n[25] \"Vazao09\"              \"Vazao10\"             \r\n[27] \"Vazao11\"              \"Vazao12\"             \r\n[29] \"Vazao13\"              \"Vazao14\"             \r\n[31] \"Vazao15\"              \"Vazao16\"             \r\n[33] \"Vazao17\"              \"Vazao18\"             \r\n[35] \"Vazao19\"              \"Vazao20\"             \r\n[37] \"Vazao21\"              \"Vazao22\"             \r\n[39] \"Vazao23\"              \"Vazao24\"             \r\n[41] \"Vazao25\"              \"Vazao26\"             \r\n[43] \"Vazao27\"              \"Vazao28\"             \r\n[45] \"Vazao29\"              \"Vazao30\"             \r\n[47] \"Vazao31\"              \"Vazao01Status\"       \r\n[49] \"Vazao02Status\"        \"Vazao03Status\"       \r\n[51] \"Vazao04Status\"        \"Vazao05Status\"       \r\n[53] \"Vazao06Status\"        \"Vazao07Status\"       \r\n[55] \"Vazao08Status\"        \"Vazao09Status\"       \r\n[57] \"Vazao10Status\"        \"Vazao11Status\"       \r\n[59] \"Vazao12Status\"        \"Vazao13Status\"       \r\n[61] \"Vazao14Status\"        \"Vazao15Status\"       \r\n[63] \"Vazao16Status\"        \"Vazao17Status\"       \r\n[65] \"Vazao18Status\"        \"Vazao19Status\"       \r\n[67] \"Vazao20Status\"        \"Vazao21Status\"       \r\n[69] \"Vazao22Status\"        \"Vazao23Status\"       \r\n[71] \"Vazao24Status\"        \"Vazao25Status\"       \r\n[73] \"Vazao26Status\"        \"Vazao27Status\"       \r\n[75] \"Vazao28Status\"        \"Vazao29Status\"       \r\n[77] \"Vazao30Status\"        \"Vazao31Status\"       \r\n[79] \"X\"                   \r\n\r\nA seguir puxaremos o mesmo dado porém diretamente da internet,\r\nutilizando o que chamamos de webservice. Isso facilita muito a\r\ncriação de códigos mais automatizados em que não é necessário ficar\r\nbaixando os dados um a um.\r\nObtenção via webservice\r\nSer capaz de obter informações hidrológicas de forma gratuita\r\ndiretamente da internet, algo conhecido como “webscraping”, representa\r\num ganho significativo de eficiência no desenvolvimento de estudos e\r\nprojetos de hidrologia, recursos hídricos, e áreas afins.\r\nEssa possibilidade vem se tornando cada vez mais comum nos dias de\r\nhoje. Por exemplo, a Agência Nacional de Águas e Saneamento Básico\r\n(ANA), o Operador Nacional do Sistema Elétrico (ONS), e outras\r\ninstituições no Brasil e no exterior disponibilizam alguns de seus dados\r\npor meio do chamado webservice.\r\nEm essência, o webservice é apenas um site que contém os dados.\r\nPorém, esses dados estão organizados de uma maneira bem específica, de\r\nforma que para que seja possível obtê-los de forma eficiente, é\r\nimprescindível que essa organização seja bem entedida. Aqui neste curso\r\nintrodutório, vamos focar nossas atividades no webservice da ANA, que se\r\nencontra disponível por meio do url http://telemetriaws1.ana.gov.br/ServiceANA.asmx.\r\nQuando acessamos esse endereço, somos levados para a página\r\nabaixo,\r\n\r\n\r\n\r\nSe dermos um zoom na figura, podemos verificar todas as informações\r\nque estão disponíveis no webservice, tais como “dados\r\nhidrometeorológicos”, “dados hidrometeorológicos gerais”, “lista de\r\nestações telemétricas”, “Cotas”, “inventário”, “rios”, “série\r\nhistórica”, entre outras.\r\nNesse mesmo site, pode-se acessar um arquivo em formato pdf com\r\ndetalhes sobre o sistema como um todo, e com o que se pode obter dentro\r\ndele http://telemetriaws1.ana.gov.br/Telemetria1ws.pdf! Esse\r\narquivo é essencial para entendermos como os dados estão disponíveis e\r\ncomo podemos acessá-los.\r\nEsse documento nos informa que os dados hidrológicos da ANA estão\r\ndisponibilizados no formato XML (“Extended Markup Language”), de forma\r\nque precisamos aprender como acessar e manipular as informações\r\ndisponibilizados nesse formato. Mas discutiremos apenas o básico neste\r\ncurso, sem nos profundarmos muito. Porém se você deseja saber mais sobre\r\nwebscraping e usufruir de várias de suas possibilidade, sugerimos que\r\nprocure se aprofundar mais nesse tema.\r\nLista das Estações\r\nTelemétricas da ANA\r\nComeçaremos nossas atividades acessando os dados das estações\r\ntelemétricas desse sistema. Pode-se perceber olhando para o próprio\r\nsite, que são necessários dois parâmetros para pesquisar as estações. O\r\nprimiero chama-se “statusEstacoes”, que pode ser 0, que significa\r\nestação ativa, ou 1, que representa estação em manutenção. O segundo\r\nparâmetro é chamado de “Origem”, podendo variar entre 0 e 5. Se olharmos\r\no arquivo em formato pdf mencioando acima, vamos ver que se deixarmos o\r\n“statusEstacoes” em branco, serão retornadas as informações de todas as\r\nestações do sistema, que é exatamente o que queremos agora.\r\nSendo assim, se colocarmos no nosso navegador o seguinte url: http://telemetriaws1.ana.gov.br/ServiceANA.asmx/ListaEstacoesTelemetricas?statusEstacoes=&origem=,\r\nteremos acesso ao arquivo XML com a informação de todas as estações\r\ntelemétricas.\r\n\r\n\r\n\r\nPara que tenhamos cesso a essas informações nesse mesmo formato no\r\nRStudio, teremos que fazer uso de um pacote chamado “XML”, que contém a\r\nfunção denominada xmlParse(). Essa função é capaz de ler um arquivo do\r\ntipo XML e gerar uma estrutura no R similar ao que aparece na imagem\r\nacima (formato de “árvore”). A função exige que informemos um argumento\r\nobrigatório, que é o url a ser utilizado, e permite ainda que passemos\r\num argumento opcional, que é a codificação do arquivo (do inglês\r\nencoding). Usualmente no Brasil, utilizamos o “UTF-8” para poder\r\nutilizar nossos acentos (mas lembre-se que essa parte é um outro mundo\r\nno R e não entraremos com maiores detalhamentos).\r\n\r\n\r\nstatus_codigo <- \"\"\r\norigem_codigo <- \"\"\r\n\r\nurl_base <- paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/ListaEstacoesTelemetricas?\",\r\n                   \"statusEstacoes=\", status_codigo, \"&origem=\", origem_codigo)\r\nurl_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n\r\n\r\nOlha o nosso código um pouco. Percebe que invés de digitar\r\ndiretamente o url para acesso, quebramos ele em várias partes e juntamos\r\ncom a função paste0(). Fizemos isso para ficar mais fácil de mudar algo\r\ndepois. Caso quisermos utilizar outro valor em “statusEstacoes” ou em\r\n“Origem”, basta mudarmos os objetos criados e o resto do código continua\r\nigual! Ao chamar o url_parse no console, verá uma imagem similar ao site\r\nquando abrimos o url.\r\nPara puxar agora as informações dessas estações, precisamos entender\r\nmelhor o arquivo original no formato XML. De maneira resumida, arquivos\r\nno formato XML ou HTML possuem estruturas que são definidas entre “<\r\n>”. Ao mexer no url que nos dá todas as estações, percebe-se que\r\ntodos os dados de cada estação são precedidos por um elemento chamado\r\n“Table” (dentro do “<>”). Porém, queremos os nodes que estão\r\nassociados a esses “Tables” (tabelas). Para isso, samos a função\r\ngetNodeSet(). Com os argumentos dessa função sendo primeiro o objeto\r\ncriado no R depois de ter feito um xmlParse() e o segundo argumento\r\nsendo “//Table” (lembrar de colocar essas duas barras)\r\n\r\n\r\n\r\nA próxima etapa agora é transformar esse arquivo em algo que estamos\r\nmais acostumados a mexer dentro do R. Boas opções são dataframes e\r\nlistas. Como não aprendemos a mexer muito com listas, vamos transformar\r\nnosso objeto em um dataframe. Para isso utilizamos a função\r\nxmlToDataFrame().\r\n\r\n\r\nnodes_doc <- XML::getNodeSet(url_parse, \"//Table\")\r\ncadastro_estacoes <- XML::xmlToDataFrame(nodes = nodes_doc)\r\n\r\n\r\nAgora podemos fazer as manipulações que já aprendemos anteriormente\r\n(com dataframe ficou fácil!). Por exemplo, se quisermos selecionar\r\napenas as estações de Brasília, escrevemos o código abaixo. O\r\n“Municipio-UF” é apenas uma das colunas do dataframe, podemos filtrar\r\ncom base em qualquer outra também.\r\n\r\n\r\n(estacoes_bsb <- dplyr::filter(cadastro_estacoes, `Municipio-UF` == \"BRASÍLIA-DF\"))\r\n\r\n                                    NomeEstacao CodEstacao Bacia\r\n1                        ANA SEDE (COTA ONLINE)   01547032     6\r\n2                        ANA SEDE - TELEMÉTRICA   01547079     6\r\n3                            RIBEIRÃO PALMEIRAS   20000950     2\r\n4                                        SONHEM   20001050     2\r\n5                             CONTAGEM - VC 201   20001200     2\r\n6                           RIBEIRÃO SANTA RITA   42450050     4\r\n7                               RIBEIRÃO JACARÉ   42450300     4\r\n8                  RIO PRETO - MONTANTE EXTREMA   42450360     4\r\n9                             LAGOINHA - DF 105   42450370     4\r\n10                             EXTREMA - DF 100   42450510     4\r\n11                  RIO PRETO - FAZENDA ITAPETI   42450600     4\r\n12                              JARDIM - DF 260   42450740     4\r\n13                    JARDIM - MONTANTE LAMARÃO   42450770     4\r\n14                       RIBEIRÃO JARDIM DF-100   42450900     4\r\n15                             RIO SÃO BERNARDO   42454000     4\r\n16            DESCOBERTO JUS. CAPTAÇÃO BARROCÃO   60434600     6\r\n17                      DESCOBERTO - CHACARA 89   60435000     6\r\n18                            RODEADOR - DF 435   60435200     6\r\n19                          RIBEIRÃO DAS PEDRAS   60435405     6\r\n20                        DESCOBERTO - BARRAGEM   60435500     6\r\n21                                     MELCHIOR   60436185     6\r\n22                               RIO DESCOBERTO   60436186     6\r\n23                                   PONTE ALTA   60443830     6\r\n24                                      ALAGADO   60444035     6\r\n25                                    PIPIRIPAU   60472235     6\r\n26                          RIBEIRÃO SOBRADINHO   60474300     6\r\n27                BARTOLOMEU - MONTANTE PARANOÁ   60476155     6\r\n28                       SANTA MARIA - BARRAGEM   60477100     6\r\n29         RIBEIRÃO TORTO JUSANTE CÓRREGO URUBÚ   60477380     6\r\n30                  UHE PARANOÁ CÓRREGO BANANAL   60477607     6\r\n31                      RIACHO FUNDO VILA CAUHY   60478185     6\r\n32 MONTANTE ZOOLÓGICO - EPIA 003 - RIACHO FUNDO   60478200     6\r\n33                                ESTAÇÃO TESTE   60478250     6\r\n34                                ESTAÇÃO TESTE   60478250     6\r\n35                              ESTAÇÃO TESTE 1   60478251     6\r\n36                       RIBEIRÃO MARIA PEREIRA   60478477     6\r\n37                           CÓRREGO SAIA VELHA   60478481     6\r\n38                                      FAL-UNB   60478482     6\r\n39                              CÓRREGO TAQUARA   60478493     6\r\n40                             RIBEIRÃO DO GAMA   60478520     6\r\n41          UHE PARANOÁ CÓRREGO CABEÇA DE VEADO   60478610     6\r\n42                        BARRAGEM LAGO PARANOÁ   60479230     6\r\n43                       UHE PARANOÁ BARRAMENTO   60479270     6\r\n44                          UHE PARANOÁ JUSANTE   60479280     6\r\n45                                       TABOCA   60480310     6\r\n46                                       PAPUDA   60480550     6\r\n47                                 CACHOEIRINHA   60491000     6\r\n48                                      SANTANA   60492000     6\r\n   SubBacia\r\n1        60\r\n2        60\r\n3        20\r\n4        20\r\n5        20\r\n6        42\r\n7        42\r\n8        42\r\n9        42\r\n10       42\r\n11       42\r\n12       42\r\n13       42\r\n14       42\r\n15       42\r\n16       60\r\n17       60\r\n18       60\r\n19       60\r\n20       60\r\n21       60\r\n22       60\r\n23       60\r\n24       60\r\n25       60\r\n26       60\r\n27       60\r\n28       60\r\n29       60\r\n30       60\r\n31       60\r\n32       60\r\n33       60\r\n34       60\r\n35       60\r\n36       60\r\n37       60\r\n38       60\r\n39       60\r\n40       60\r\n41       60\r\n42       60\r\n43       60\r\n44       60\r\n45       60\r\n46       60\r\n47       60\r\n48       60\r\n                                                          Operadora\r\n1                          00001 - ANA - Agência Nacional de Águas \r\n2                          00001 - ANA - Agência Nacional de Águas \r\n3  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n4  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n5  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n6  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n7               00082 - CPRM - Cia de Pesquisa de Recursos Minerais\r\n8  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n9  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n10 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n11 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n12 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n13 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n14 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n15              00082 - CPRM - Cia de Pesquisa de Recursos Minerais\r\n16                                            00077 - CAESB - CAESB\r\n17                                            00077 - CAESB - CAESB\r\n18                                            00077 - CAESB - CAESB\r\n19 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n20                                            00077 - CAESB - CAESB\r\n21 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n22 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n23 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n24 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n25              00082 - CPRM - Cia de Pesquisa de Recursos Minerais\r\n26 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n27 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n28                                            00077 - CAESB - CAESB\r\n29 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n30                                   00133 - CEB - CEB Geração S.A.\r\n31 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n32                                            00077 - CAESB - CAESB\r\n33                         00001 - ANA - Agência Nacional de Águas \r\n34                         00001 - ANA - Agência Nacional de Águas \r\n35                         00001 - ANA - Agência Nacional de Águas \r\n36 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n37 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n38                           00250 - UNB - Universidade de Brasília\r\n39                           00250 - UNB - Universidade de Brasília\r\n40 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n41                                   00133 - CEB - CEB Geração S.A.\r\n42 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n43                                   00133 - CEB - CEB Geração S.A.\r\n44                                   00133 - CEB - CEB Geração S.A.\r\n45 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n46 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n47 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n48 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n                                                        Responsavel\r\n1                          00001 - ANA - Agência Nacional de Águas \r\n2                          00001 - ANA - Agência Nacional de Águas \r\n3  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n4  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n5  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n6  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n7                          00001 - ANA - Agência Nacional de Águas \r\n8  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n9  00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n10 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n11 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n12 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n13 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n14 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n15                         00001 - ANA - Agência Nacional de Águas \r\n16                                            00077 - CAESB - CAESB\r\n17                                            00077 - CAESB - CAESB\r\n18                                            00077 - CAESB - CAESB\r\n19 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n20                                            00077 - CAESB - CAESB\r\n21 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n22 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n23 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n24 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n25                         00001 - ANA - Agência Nacional de Águas \r\n26 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n27 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n28                                            00077 - CAESB - CAESB\r\n29 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n30                                   00133 - CEB - CEB Geração S.A.\r\n31 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n32                                            00077 - CAESB - CAESB\r\n33                         00001 - ANA - Agência Nacional de Águas \r\n34                         00001 - ANA - Agência Nacional de Águas \r\n35                         00001 - ANA - Agência Nacional de Águas \r\n36 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n37 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n38                         00001 - ANA - Agência Nacional de Águas \r\n39                         00001 - ANA - Agência Nacional de Águas \r\n40 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n41                                   00133 - CEB - CEB Geração S.A.\r\n42 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n43                                   00133 - CEB - CEB Geração S.A.\r\n44                                   00133 - CEB - CEB Geração S.A.\r\n45 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n46 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n47 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n48 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n   Municipio-UF  Latitude Longitude Altitude   CodRio\r\n1   BRASÍLIA-DF -15.81805 -47.94500  1150.00        0\r\n2   BRASÍLIA-DF -15.81810 -47.94500  1150.00        0\r\n3   BRASÍLIA-DF -15.52810 -47.74190     0.00 20003000\r\n4   BRASÍLIA-DF -15.52310 -47.81580     0.00 20030000\r\n5   BRASÍLIA-DF -15.50080 -47.85420     0.00 20050000\r\n6   BRASÍLIA-DF -15.58560 -47.33330   870.00 42250100\r\n7   BRASÍLIA-DF -15.64060 -47.35670     0.00 42250300\r\n8   BRASÍLIA-DF -15.83720 -47.36890     0.00 42250000\r\n9   BRASÍLIA-DF -15.77250 -47.39890     0.00 42250350\r\n10  BRASÍLIA-DF -15.84580 -47.38530     0.00 42250500\r\n11  BRASÍLIA-DF -15.94280 -47.36360     0.00 42250000\r\n12  BRASÍLIA-DF -15.85970 -47.47560     0.00 42250800\r\n13  BRASÍLIA-DF -15.94750 -47.44580     0.00 42250800\r\n14  BRASÍLIA-DF -15.97390 -47.39860     0.00 42250800\r\n15  BRASÍLIA-DF -16.03580 -47.41500     0.00 42252000\r\n16  BRASÍLIA-DF -15.63440 -48.18420  1094.00 60315000\r\n17  BRASÍLIA-DF -15.70890 -48.23390  1034.00 60315000\r\n18  BRASÍLIA-DF -15.72500 -48.16830  1035.00 60315400\r\n19  BRASÍLIA-DF -15.76220 -48.15940     0.00 60315800\r\n20  BRASÍLIA-DF -15.77780 -48.23140  1032.00 60315000\r\n21  BRASÍLIA-DF -15.92670 -48.25890     0.00 60314500\r\n22  BRASÍLIA-DF -15.93110 -48.25750     0.00 60315000\r\n23  BRASÍLIA-DF -16.03720 -48.13610     0.00 60317515\r\n24  BRASÍLIA-DF -16.04670 -48.08220     0.00 60317500\r\n25  BRASÍLIA-DF -15.61440 -47.54560  1008.00 60320100\r\n26  BRASÍLIA-DF -15.72720 -47.69670     0.00 60320800\r\n27  BRASÍLIA-DF -15.80940 -47.70060     0.00 60320000\r\n28  BRASÍLIA-DF -15.66890 -47.95360  1075.00 60321060\r\n29  BRASÍLIA-DF -15.72190 -47.86810     0.00 60321040\r\n30  BRASÍLIA-DF -15.72830 -47.91000  1003.00 60321120\r\n31  BRASÍLIA-DF -15.87530 -47.96610  1019.00 60321180\r\n32  BRASÍLIA-DF -15.85940 -47.94190  1005.00 60321180\r\n33  BRASÍLIA-DF -15.81670 -47.95000     0.00 60321180\r\n34  BRASÍLIA-DF -15.81670 -47.95000     0.00 60321180\r\n35  BRASÍLIA-DF -15.81940 -47.95560     0.00 60321180\r\n36  BRASÍLIA-DF -16.04220 -47.84860     0.00 60322510\r\n37  BRASÍLIA-DF -16.04970 -47.93780     0.00 60323000\r\n38  BRASÍLIA-DF -15.94500 -47.93830  1066.00 60321270\r\n39  BRASÍLIA-DF -15.91110 -47.90890     0.00 60321300\r\n40  BRASÍLIA-DF -15.85830 -47.87390     0.00 60321260\r\n41  BRASÍLIA-DF -15.85580 -47.85750  1003.96 60321340\r\n42  BRASÍLIA-DF -15.79720 -47.78420     0.00 60321020\r\n43  BRASÍLIA-DF -15.79750 -47.78390  1000.00 60321000\r\n44  BRASÍLIA-DF -15.79110 -47.76220   895.00 60321000\r\n45  BRASÍLIA-DF -15.87530 -47.72280     0.00 60321380\r\n46  BRASÍLIA-DF -15.89250 -47.72280     0.00 60321400\r\n47  BRASÍLIA-DF -16.03560 -47.68530     0.00 60103050\r\n48  BRASÍLIA-DF -16.05080 -47.74420     0.00 60321800\r\n                         NomeRio              Origem StatusEstacao\r\n1                                         CotaOnline         Ativo\r\n2                                                RHN         Ativo\r\n3             RIBEIRÃO PALMEIRAS Setor de Saneamento         Ativo\r\n4                     RIO SONHEM Setor de Saneamento         Ativo\r\n5           RIBEIRÃO DA CONTAGEM                 RHN         Ativo\r\n6            RIBEIRÃO SANTA RITA                 RHN         Ativo\r\n7  CÓRREGO BURITI GRANDE/ JACARÉ                 RHN         Ativo\r\n8                      RIO PRETO Setor de Saneamento         Ativo\r\n9               CÓRREGO LAGOINHA Setor de Saneamento         Ativo\r\n10              RIBEIRÃO EXTREMA                 RHN         Ativo\r\n11                     RIO PRETO                 RHN         Ativo\r\n12               RIBEIRÃO JARDIM Setor de Saneamento         Ativo\r\n13               RIBEIRÃO JARDIM Setor de Saneamento         Ativo\r\n14               RIBEIRÃO JARDIM                 RHN         Ativo\r\n15         RIBEIRÃO SÃO BERNARDO                 RHN         Ativo\r\n16                RIO DESCOBERTO                 RHN         Ativo\r\n17                RIO DESCOBERTO                 RHN         Ativo\r\n18                  RIO RODEADOR                 RHN         Ativo\r\n19           RIBEIRÃO DAS PEDRAS Setor de Saneamento         Ativo\r\n20                RIO DESCOBERTO                 RHN         Ativo\r\n21                  RIO MELCHIOR Setor de Saneamento         Ativo\r\n22                RIO DESCOBERTO Setor de Saneamento         Ativo\r\n23           RIBEIRÃO PONTE ALTA Setor de Saneamento         Ativo\r\n24                   RIO ALAGADO Setor de Saneamento         Ativo\r\n25                 RIO PIPIRIPAU                 RHN         Ativo\r\n26           RIBEIRÃO SOBRADINHO Setor de Saneamento         Ativo\r\n27            RIO SÃO BARTOLOMEU Setor de Saneamento         Ativo\r\n28              LAGO SANTA MARIA                 RHN         Ativo\r\n29             RIBEIRÃO DO TORTO                 RHN         Ativo\r\n30               CÓRREGO BANANAL      Setor Elétrico         Ativo\r\n31                  RIACHO FUNDO Setor de Saneamento         Ativo\r\n32                  RIACHO FUNDO                 RHN         Ativo\r\n33                  RIACHO FUNDO                 RHN         Ativo\r\n34                  RIACHO FUNDO                 GDH         Ativo\r\n35                  RIACHO FUNDO                 RHN         Ativo\r\n36        RIBEIRÃO MARIA PEREIRA Setor de Saneamento         Ativo\r\n37                RIO SAIA VELHA Setor de Saneamento         Ativo\r\n38             CORREGO CAPETINGA                 RHN         Ativo\r\n39               CÓRREGO TAQUARA                 RHN         Ativo\r\n40              RIBEIRÃO DO GAMA Setor de Saneamento         Ativo\r\n41       CÓRREGO CABEÇA DE VEADO      Setor Elétrico         Ativo\r\n42               LAGO DO PARANOÁ                 RHN         Ativo\r\n43                   RIO PARANOÁ      Setor Elétrico         Ativo\r\n44                   RIO PARANOÁ      Setor Elétrico         Ativo\r\n45            RIBEIRÃO DA TABOCA Setor de Saneamento         Ativo\r\n46             CÓRREGO DA PAPUDA Setor de Saneamento         Ativo\r\n47                 CÓRREGO VIÚDA Setor de Saneamento         Ativo\r\n48              RIBEIRÃO SANTANA Setor de Saneamento         Ativo\r\n\r\nLembrando que isso tudo nos dá apenas a lista com informações sobre\r\nas estações telemétricas. Para de fato termos acesso aos dados dessas\r\nestações, precisamos acessar outro url e fazer mais alguns códigos!\r\nIdealmente, se a gente quiser ficar sempre puxando diferentes\r\ninformações e não ficar precisando rodar linha por linha de código,\r\npodemos juntar tudo isso em uma função. Para a nossa função, deixaremos\r\no processo um pouco melhor. Primeiro definiremos que a função precisa de\r\n3 parâmetros (o status da estação, a origem e qual Unidade Federativa do\r\nBrasil queremos). Após puxar os dados em XML e transformar tudo em um\r\ndataframe, fazemos aqui algo novo - criamos uma coluna chamada “UF”\r\ncontendo apenas as últimas duas letras do Município (isos porque no\r\narquivo original, as duas últimas letras são as siglas da UF).\r\n\r\n\r\nANA_info <- function(status_codigo = \"\",\r\n                     origem_codigo = \"\",\r\n                     UF_fun = \"DF\"){\r\n\r\n  # Essas etapas foram vistas anteriormente\r\n  url_base <- paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/ListaEstacoesTelemetricas?\",\r\n                     \"statusEstacoes=\", status_codigo,\r\n                     \"&origem=\", origem_codigo)\r\n  url_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n  nodes_doc <- XML::getNodeSet(url_parse, \"//Table\")\r\n  cadastro_estacoes <- XML::xmlToDataFrame(nodes = nodes_doc)\r\n  \r\n  # Aqui criamos uma coluna no dataframe apenas com nomes das UFs\r\n  cadastro_estacoes$UF <- substr(cadastro_estacoes$`Municipio-UF`,\r\n                                 nchar(cadastro_estacoes$`Municipio-UF`) - 1,\r\n                                 nchar(cadastro_estacoes$`Municipio-UF`))\r\n                                 \r\n  estacoes_UF <- dplyr::filter(cadastro_estacoes, `UF` == UF_fun)\r\n\r\n  return(estacoes_UF)\r\n}\r\n\r\n\r\nPodemos simplesmente testar essa função criada chamando a função e\r\natribuindo para um objeto qualquer (chamamos aqui de “teste”) seu\r\nresultado. Em seguida falamos para o R printar as colunas desse\r\ndataframe.\r\n\r\n\r\n# Testar a função feita!\r\nteste <- ANA_info()\r\ncolnames(teste)\r\n\r\n [1] \"NomeEstacao\"   \"CodEstacao\"    \"Bacia\"         \"SubBacia\"     \r\n [5] \"Operadora\"     \"Responsavel\"   \"Municipio-UF\"  \"Latitude\"     \r\n [9] \"Longitude\"     \"Altitude\"      \"CodRio\"        \"NomeRio\"      \r\n[13] \"Origem\"        \"StatusEstacao\" \"UF\"           \r\n\r\nDados Hidrometeorológicos da\r\nANA\r\nPara acessar os dados hidrometeorológicos nesse webservice, temos\r\noutro url: http://telemetriaws1.ana.gov.br/ServiceANA.asmx?op=DadosHidrometeorologicos.\r\nNele, vemos que são necessárias agora três parâmetros para fazermos uma\r\nbusca: o “codEstacao” (que a gente pegou na parte anterior!), a\r\n“dataInicio” e a “dataFim”. Do mesmo jeito de antes, vamos definir um\r\nobjeto para cada parâmetro e depois criar um url baseado nesses\r\nparâmetros. Em seguida fazemos um xmlParse() e pegamos as informações\r\ncontidas nos nodes com o getNodeSet(). Por último, transformamos isso em\r\num dataframe. Dessa vez, podemos fazer a função direto ja!\r\n\r\n\r\ndados_ANA <- function(cod_estacao = \"\",\r\n                      data_inicio = \"01/01/2020\",\r\n                      data_fim = Sys.Date()){\r\n\r\n  # Puxar dados do url e transformar em dataframe\r\n  url_base <- paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/DadosHidrometeorologicos?\",\r\n                     \"codEstacao=\", cod_estacao,\r\n                     \"&dataInicio=\", data_inicio,\r\n                     \"&dataFim=\", data_fim)\r\n  url_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n  node_doc <- XML::getNodeSet(url_parse, \"//DadosHidrometereologicos\")\r\n  dados_estacao <- XML::xmlToDataFrame(nodes = node_doc)\r\n  \r\n  return(dados_estacao)\r\n}\r\n\r\n\r\nA partir da função que criamos anteriormente, para puxar as\r\ninformações das estações, podemos ver os códigos de todas as estações.\r\nUm exemplo é a FAL, da própria UnB. Seu código é 60478482 - podemos usar\r\nele na nossa nova função “dados_ANA”. Para ver o que essa função criada\r\nretorna, podemos pedir ao R as primeiras 6 linhas desse dataframe.\r\n\r\n\r\ndados_FAL <- dados_ANA(cod_estacao = 60478482)\r\nhead(dados_FAL)\r\n\r\n  CodEstacao             DataHora Vazao Nivel Chuva\r\n1   60478482 2022-07-04 23:00:00        27.00  0.00\r\n2   60478482 2022-07-04 22:45:00        27.00  0.00\r\n3   60478482 2022-07-04 22:30:00        27.00  0.00\r\n4   60478482 2022-07-04 22:15:00        27.00  0.00\r\n5   60478482 2022-07-04 22:00:00        27.00  0.00\r\n6   60478482 2022-07-04 21:45:00        27.00  0.00\r\n\r\nPercebemos aqui um “problema”. A data e a hora estão na mesma coluna\r\ne idealmente queremos deixar em colunas separadas (uma contendo a data e\r\noutra contendo as horas). Então iremos adicionar dentro da nossa função,\r\nmais um comando para fazer essa separação. Um jeito simples (mas não o\r\núnico) de fazer isso é selecionando os primeiros 10 caracteres como\r\nsendo os de data e os últimos 8 como sendo de hora - porque a data\r\nsempre vai estar no formato “dia/mes/ano” e o horário em\r\n“hora:minuto:segundo”. Podemos também reorganizar as colunas do jeito\r\nque quisermos. Abaixo está essa nova função mais organizada.\r\n\r\n\r\ndados_ANA <- function(cod_estacao = \"\",\r\n                      data_inicio = \"01/01/2020\",\r\n                      data_fim = Sys.Date()){\r\n\r\n  # Puxar dados do url e transformar em dataframe\r\n  url_base <- paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/DadosHidrometeorologicos?\",\r\n                     \"codEstacao=\", cod_estacao,\r\n                     \"&dataInicio=\", data_inicio,\r\n                     \"&dataFim=\", data_fim)\r\n  url_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n  node_doc <- XML::getNodeSet(url_parse, \"//DadosHidrometereologicos\")\r\n  dados_estacao <- XML::xmlToDataFrame(nodes = node_doc)\r\n  \r\n  # Separar data e hora\r\n  dados_estacao$Data <- substr(dados_estacao$DataHora, 1, 10)\r\n  dados_estacao$Hora <- substr(dados_estacao$DataHora, 12, 19)\r\n\r\n  # Re-organizar a ordem das colunas do dataframe dados_estacao\r\n  dados_estacao <- dados_estacao[,c(1, 6, 7, 3, 4, 5)]\r\n  \r\n  return(dados_estacao)\r\n}\r\n\r\n\r\nChamamos novamente essa função (agora atualizada) para rodar a\r\nestação da FAL. Em seguida printamos no R apenas as primeiras 6 linhas\r\ndesse dataframe.\r\n\r\n\r\n# Rodar a função para a estação da FAL\r\ndados_FAL <- dados_ANA(cod_estacao = 60478482)\r\nhead(dados_FAL)\r\n\r\n  CodEstacao       Data     Hora Vazao Nivel Chuva\r\n1   60478482 2022-07-04 23:00:00       27.00  0.00\r\n2   60478482 2022-07-04 22:45:00       27.00  0.00\r\n3   60478482 2022-07-04 22:30:00       27.00  0.00\r\n4   60478482 2022-07-04 22:15:00       27.00  0.00\r\n5   60478482 2022-07-04 22:00:00       27.00  0.00\r\n6   60478482 2022-07-04 21:45:00       27.00  0.00\r\n\r\nAqui rodamos a função apenas para uma estação. Mas se quisermos rodar\r\npara várias estações, basta utilizar um loop (for) ou até mesmo a função\r\nlapply do R (mais rápido!).\r\nSérie Histórica\r\nOutro local do HidroWeb da ANA que possui dados hidrológicos\r\nrelevantes é na seção de série histórica. Para puxar o arquivo dentro do\r\nR é possível fazer algo similar ao feito acima. Nessa\r\nseção, porém, são necessários 5 argumentos: - codEstacao (código da\r\nestação); - dataInicio (primeira data em que se quer os dados); -\r\ndataFim (última data em que se quer os dados); - tipoDados (podendo ser\r\ncotas, 1, chuvas, 2, ou vazões, 3); - nivelConsistencia (podendo ser\r\nBruto, 1, ou consistido, 2).\r\nPrimeiro então criamos objetos contendo essas informações necessárias\r\npara entrar no url da série histórica.\r\n\r\n\r\ncod_estacao <- 60435000\r\ndata_inicio <- \"01/01/1800\"\r\ndata_fim <- Sys.Date()\r\ntipo_dados <- 3\r\nnivel_consist <- 1\r\n\r\n\r\nEm seguida, esses objetos são utilizados para criar um url\r\npara podermos acessar os dados do HidroWeb. Após é feito o mesmo que a\r\ncima em outros portais dentro do portal da ANA, fazendo então um\r\nXML::xmlParse(), seguido por um\r\nXML::getNodeSet() e XML::xmlToDataFrame().\r\nAssim como anteriormente, faz-se também a separação da coluna de data em\r\nduas, uma contendo a data e outra contendo a hora. Na coluna de Data é\r\nfeita a transformação de caractere para Date de modo que possamos fazer\r\nalgumas operações com ela depois.\r\nobs: Por algum motivo o hidroweb não está filtrando os dados pela\r\nconsistencia, sendo necessária essa etapa abaixo (um filtro).\r\n\r\n\r\n# Puxar dados do url e transformar em dataframe\r\nurl_base <-\r\n  paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/\",\r\n         \"HidroSerieHistorica?\",\r\n         \"codEstacao=\", cod_estacao,\r\n         \"&dataInicio=\", data_inicio,\r\n         \"&dataFim=\", data_fim,\r\n         \"&tipoDados=\", tipo_dados,\r\n         \"&nivelConsistencia=\", nivel_consist)\r\n         \r\nurl_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\nnode_doc <- XML::getNodeSet(url_parse, \"//SerieHistorica\")\r\ndados_estacao <- XML::xmlToDataFrame(nodes = node_doc)\r\n\r\n# Separar data e hora\r\ndados_estacao$Data <- as.Date(substr(dados_estacao$DataHora, 1, 10))\r\ndados_estacao$Hora <- substr(dados_estacao$DataHora, 12, 19)\r\n\r\n\r\nNesse arquivo temos a necessidade de uma nova etapa. Ao olhar um\r\npouco como os dados estão oganizados, percebemos que existem 78 colunas.\r\nAo invés dos dados de vazão estarem todos em uma mesma coluna, eles\r\nestão espaçados por coluna, contendo 1 mês completo para cada linha do\r\ndataframe. Isso é um pouco problemático, pois não podemos simplesmente\r\npuxar todas as colunas visto que cada mês vai ter datas diferentes\r\n(fevereiro podendo até mudar dependendo do ano bisexto). Para resolver\r\nisso, primeiro criamos um vetor/objeto contendo todas\r\nas datas desde o primeiro mês em questão, até o útimo dia do último\r\nmês.\r\n\r\n\r\ndatas_dia <- seq.Date(from = min(dados_estacao$Data),\r\n                      to = max(dados_estacao$Data) %m+% months(1) - 1,\r\n                      by = \"day\")\r\n\r\n\r\nEm seguida fazemos um dataframe vazio, contendo 3 colunas. A primeira\r\npossui o código da estação sendo avaliado (como repete para todas as\r\nlinhas, podemos pegar apenas o primeiro valor). A segunda as datas, no\r\nformato caracter (útil para manipulação de texto), e a\r\núltima sendo a coluna com os dados de vazão que está, por hora,\r\nvazio.\r\n\r\n\r\ntabela_final <- data.frame(Cod_estacao = dados_estacao$EstacaoCodigo[1],\r\n                           Data = as.character(datas_dia),\r\n                           Vazao = as.numeric(NA))\r\n\r\n\r\nAgora vamos preencher essa tabela com os dados de vazão do arquivo\r\nacessado. Uma maneira de fazer isso é fazendo um loop para cada\r\nlinha dessa tabela. Para cada linha, acessamos o dia em questão (o dia é\r\nsempre os últimos 2 caracteres da coluna data). Em seguida obtemos o mês\r\ne ano dessa data (os primeiros oito caracteres da coluna de data) e\r\nadicionamos o dia “-01” a eles (isso para sabermos em qual linha do\r\narquivo da ANA está o dado) - para isso criamos o objeto\r\nlinha_dado. Por último rodamos um ifelse() do\r\ntipo: se eu não tiver essa linha_dado, ou seja, se não houver\r\nmedição desse mês na ANA, eu coloco um NA (Not\r\nAvailable) na tabela final, caso o contrário é pego o valor na\r\nlinha definida e na coluna do dia + 15 (é somado 15 porque as colunas de\r\ndia começam a partir da coluna 16).\r\n\r\n\r\nfor(i in 1:nrow(tabela_final)){\r\n  # Dia em análise\r\n  dia <- as.numeric(substr(tabela_final$Data[i], 9, 10))\r\n    \r\n  # Mês e ano em análise\r\n  mes_ano <- as.Date(paste0(substr(tabela_final$Data[i], 1, 8), \"01\"))\r\n  \r\n  # Olhar a linha do mes e ano e escolher a coluna pelo dia + 15\r\n  linha_dado <- which(dados_estacao$Data == mes_ano)\r\n  \r\n  # Se não tiver o mês nos dados da estação, colocar valor NA\r\n  ifelse(length(linha_dado) == 0,\r\n         tabela_final$Vazao[i] <- NA,\r\n         tabela_final$Vazao[i] <-\r\n           as.numeric(dados_estacao[linha_dado, (dia + 15)]))\r\n    \r\n}\r\n\r\n\r\nPronto, agora podemos ver, por exemplo, as primeiras 5 medições que\r\nnão são NA\r\n\r\n\r\nhead(tabela_final[!is.na(tabela_final$Vazao),])\r\n\r\n   Cod_estacao       Data  Vazao\r\n12    60435000 1978-05-12 2.5342\r\n13    60435000 1978-05-13 2.5004\r\n14    60435000 1978-05-14 2.5004\r\n15    60435000 1978-05-15 2.4667\r\n16    60435000 1978-05-16 2.4667\r\n17    60435000 1978-05-17 2.5004\r\n\r\nAssim como feito nas outras etapas, podemos aqui fazer uma função\r\npara automatizar tudo que foi feito em várias etapas para deixar o\r\nprocesso mais automatizado e mais fácil quando quiser rodar o mesmo\r\nprocesso para outras estações.\r\n\r\n\r\ndados_serie_ANA <- function(cod_estacao = NA,\r\n                            data_inicio = \"01/01/1800\",\r\n                            data_fim = Sys.Date(),\r\n                            tipo_dados = 3,\r\n                            nivel_consist = 1){\r\n  \r\n  # Puxar dados do url e transformar em dataframe\r\n  url_base <-\r\n    paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/\",\r\n           \"HidroSerieHistorica?\",\r\n           \"codEstacao=\", cod_estacao,\r\n           \"&dataInicio=\", data_inicio,\r\n           \"&dataFim=\", data_fim,\r\n           \"&tipoDados=\", tipo_dados,\r\n           \"&nivelConsistencia=\", nivel_consist)\r\n  \r\n  url_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n  node_doc <- XML::getNodeSet(url_parse, \"//SerieHistorica\")\r\n  dados_estacao <- XML::xmlToDataFrame(nodes = node_doc)\r\n  \r\n  # Por algum motivo o hidroweb não está filtrando os dados pela consistencia\r\n  dados_estacao <- filter(dados_estacao, NivelConsistencia == nivel_consist)\r\n  \r\n  # Separar data e hora\r\n  dados_estacao$Data <- as.Date(substr(dados_estacao$DataHora, 1, 10))\r\n  dados_estacao$Hora <- substr(dados_estacao$DataHora, 12, 19)\r\n  \r\n  # Fazer um dataframe só com datas e valores de vazão\r\n  datas_dia <- seq.Date(from = min(dados_estacao$Data),\r\n                        to = max(dados_estacao$Data) %m+% months(1) - 1,\r\n                        by = \"day\")\r\n  tabela_final <- data.frame(Cod_estacao = dados_estacao$EstacaoCodigo[1],\r\n                             Data = as.character(datas_dia),\r\n                             Vazao = as.numeric(NA))\r\n  \r\n  \r\n  for(i in 1:nrow(tabela_final)){\r\n    dia <- as.numeric(substr(tabela_final$Data[i], 9, 10))\r\n    mes_ano <- as.Date(paste0(substr(tabela_final$Data[i], 1, 8), \"01\"))\r\n    linha_dado <- which(dados_estacao$Data == mes_ano)\r\n    ifelse(length(linha_dado) == 0,\r\n           tabela_final$Vazao[i] <- NA,\r\n           tabela_final$Vazao[i] <-\r\n             as.numeric(dados_estacao[linha_dado, (dia + 15)])) \r\n  } # fim do loop\r\n  return(tabela_final)\r\n}\r\n\r\n\r\nPara testar essa função basta utilizar a linha abaixo.\r\n\r\n\r\ndados_60435000 <- dados_serie_ANA(cod_estacao = 60435000)\r\ndados_60435000[10:15,]\r\n\r\n   Cod_estacao       Data  Vazao\r\n10    60435000 1978-05-10     NA\r\n11    60435000 1978-05-11     NA\r\n12    60435000 1978-05-12 2.5342\r\n13    60435000 1978-05-13 2.5004\r\n14    60435000 1978-05-14 2.5004\r\n15    60435000 1978-05-15 2.4667\r\n\r\nSalvar arquivos\r\nSalvar um arquivo único\r\nUma etapa tão importante quanto baixar os próprios dados que se\r\nprecisa é conseguir salvar eles antes ou depois de alguma manipulação\r\nfeita. Isso pode ser feito pelo R utilizando as funções\r\nwrite.table(), write.csv() ou variações delas\r\n- da mesma forma que haviam variações em read.table()\r\nread.csv().\r\nUma boa prática é deixar todos os argumentos mais importantes\r\nexplícitos, para que não tenha dúvidas de qua função usar ou como se irá\r\nsalvar. Assim deixa-se explícito abaixo o separador (tab), os\r\ndecimais (“.”), que não irá salvar o nome das linhas (elas não tem nome)\r\ne a codificação do arquivo (acentos e etc.).\r\n\r\n\r\nwrite.table(x = dados_60435000,\r\n            file = \"dados_60435000.txt\",\r\n            sep = \"\\t\",\r\n            dec = \".\",\r\n            row.names = FALSE,\r\n            fileEncoding = \"UTF-8\")\r\n\r\n\r\nSalvar em um loop\r\nA vantagem de utilizar funções e automatizações é fazer tudo que foi\r\nfeito acima para n estações, não apenas uma! Selecionamos já 4\r\nestações de uma mesma bacia para fazermos análises mais a frente. Os\r\ncódigos delas são:\r\n60435000 (feita);\r\n60436000;\r\n60436190;\r\n\r\n\r\nPara fazer isso, podemos rodar a nossa funão criada,\r\ndados_serie_ANA(), para cada uma dessas estações. Depois de\r\nrodar a função, podemos rodar também o código para salvar elas! Note que\r\no i interno ao for() não precisa ser uma\r\nsequência, ele apenas informa quais os valores que i\r\nvai tomar a cada iteração. Na hora de salvar usamos a função\r\npaste0() pois o nome vai variar com cada iteração.\r\n\r\n\r\nfor(i in c(60435000, 60436000, 60436190, 60443000)){\r\n  dados_proxy <- dados_serie_ANA(i)\r\n  \r\n  write.table(x = dados_proxy,\r\n              file = paste0(i, \".txt\"),\r\n              sep = \"\\t\",\r\n              dec = \".\",\r\n              row.names = FALSE,\r\n              fileEncoding = \"UTF-8\")\r\n}\r\n\r\n\r\nAgora temos 4 arquivos, um para cada estação que definimos, salvos em\r\nformato .txt do jeito que queremos - o que tornará a próxima\r\netapa de manipulação muito mais fácil. Ao invés de termos um arquivo\r\npara cada estação com 78 colunas e as vazões podendo estar em diferentes\r\nlinhas e colunas temos uma tabela bem simples, com apenas 3 colunas. Uma\r\ncontendo o código da estação, outra a data e a última o valor de vazão\r\nobservado.\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-23T15:41:09-03:00"
    },
    {
      "path": "index.html",
      "title": "Obtenção, manipulação e análise de dados hidrológicos com R: uma introdução para iniciantes",
      "description": "Uma iniciativa do grupo [Água e Modelagem](https://aguaemodelagem.wordpress.com) para a Semana Universitária da Universidade de Brasília de 2022\n",
      "author": [
        {
          "name": "Dirceu S. Reis Jr.",
          "url": "https://github.com/DirceuReis"
        },
        {
          "name": "Francisco Eustáquio Oliveira e Silva",
          "url": "https://github.com/fcoeustaquio"
        },
        {
          "name": "Pedro Luis Borges Chaffe",
          "url": "https://github.com/fcoeustaquio"
        },
        {
          "name": "Wilson dos Santos Fernandes",
          "url": "https://github.com/wsf-ehr"
        },
        {
          "name": "Thiago Lappicy",
          "url": "https://github.com/rich-iannone"
        },
        {
          "name": "Saulo AIres de Souza",
          "url": {}
        },
        {
          "name": "Luiz Felipe Pereira de Brito",
          "url": {}
        }
      ],
      "contents": "\r\n\r\nContents\r\nApresentação\r\nDatas e local do curso\r\nComo se\r\ninscrever\r\nAntes do\r\ncurso\r\nTópicos (em construção)\r\nNoções de R\r\nObtenção\r\ndos dados\r\nManipulação dos dados\r\nAnálise exploratória dos\r\ndados\r\nAnálise de frequência de\r\ncheias\r\n\r\n\r\nApresentação\r\nEste é um curso introdutório sobre a linguagem R para aqueles\r\ninteressados em realizar análises hidrológicas. Será oferecido pela\r\nprimeira vez durante a Semana\r\nUniversitária da Universidade de Brasília, que acontecerá entre os\r\ndias 29/08 e 02/09 de 2022.\r\nDurante o curso, os alunos irão aprender como utilizar a linguagem R\r\npara executar um conjunto de atividades que permitirão realizar uma\r\nanálise de frequência de cheias para uma estação fluviométrica, cujos\r\ndados serão automaticamente obtidos do webservice da Agência Nacional de\r\nÁguas. Ao final do curso, os alunos terão finalizado um estudo que\r\npermitirá relacionar a magnitude das vazões máximas anuais com sua\r\nprobabilidade de excedência, relação primoridal para dimensionameno de\r\ndiversas estrutaras de engenharia, gestão do risco de cheias e para o\r\noredenamento do uso e ocupação do solo.\r\nEste curso é o primeiro de um conjunto maior de cursos que estão\r\nsendo elaborados pelos seguintes professores do blog Água e Modelagem:\r\nDirceu S. Reis Jr.\r\nFrancisco Eustáquio\r\nPedro Chaffe\r\nWilson Fernandes\r\nDatas e local do curso\r\nO curso será dado na Sala 5 do Laboratório Central de Computação\r\nCientífica da Faculdade de Tecnologia da Universidade de Brasília (LCCC\r\nULEG-FT), que fica localizado no prédio da Unidade de Laboratórios de\r\nEnsino de Graduação da Faculdade de Tecnologia (ULEG/FT).\r\nO curso será dividido em 5 aulas de 2 horas cada, totalizando 10\r\nhoras. As aulas serão dadas nos seguintes horários:\r\n29/08 a 01/09 das 8h00 às 10h00\r\n02/09 das 12h00 às 14h00.\r\nComo se inscrever\r\nAs inscrições poderão ser feitas entre os dias 01 e 28 de agosto por\r\neste link\r\nda Semana Universitária. Vale notar que este curso só estará\r\ndisponível na lista fornecido pelo link acima a partir do dia 01 de\r\nagosto.\r\nComo o número de vagas é limitado, recomenda-se que a inscrição seja\r\nfeita o quanto antes.\r\nAntes do curso\r\nIncluiremos aqui um tutorial de como instalar o R, RStudio e os\r\ndiversos pacotes que serão utilizados no curso.\r\nR e RStudio\r\nPacotes\r\ntydiverse\r\n\r\nTópicos (em construção)\r\nNoções de R\r\nCriação de objetos e operações matemáticas básicas\r\nAbertura de arquivos de várias fontes (csv, excel, binário etc)\r\nDiscussão de Como lidar com a presença de “NA” no R com exemplos de\r\noperações\r\nApresentação de alguns pacotes (tidyverse: dplyr, ggplot2,\r\nlubridate)\r\nObtenção dos dados\r\nObtenção a partir de diversas fontes de informação\r\nAGência Nacional de Águas e Saneamento Básico (ANA)\r\nOperador Nacional do Sistema Elétrico (ONS)\r\nBases da dados internacionais\r\n\r\nProcedimentos para pré-selecionar estações\r\ncom base num Shapefile de uma bacia\r\n(IMPORTANTE: ir atrá disso) código Thiago: lat-lon -> trecho de\r\nrio -> trechos de montante -> estações flu\r\n\r\nObtenção de informações com bae em diferentes forms de filtros\r\n% falhas no ano\r\nnúmero mínimo de anos sem falhas]\r\nnúmero mínimo de anos sem falhas consecutivas\r\noutros\r\n\r\nManipulação dos dados\r\nReorganizar dados dependendo das especificidades do que se quer\r\nfazer\r\nGerar séries diárias, mensais e anuais (considerando ano\r\nhidrológico)\r\nGerar séries de Q7\r\nGerar séries de máximos anuais\r\nGerar séries acima de um determinado threshold (para análise\r\nPDS)\r\nDeterminação de veranicos (extensão e frequência) nos dados de\r\nchuva\r\noutros?\r\nAnálise exploratória dos\r\ndados\r\nRepresentação gráfica oriundas de um conjunto de estações\r\nem um mapa\r\nem um gráfico (e.g., boxplot)\r\n\r\nRepresentação gráfica de uma única estação\r\nRepresentação numérica\r\nMédia\r\ndesvio-padrão\r\ncorrelação temporal\r\ncorrelação espacial\r\n\r\nAnálise de frequência de\r\ncheias\r\nPosição de plotagem\r\nA distribuição de probabilidades\r\nAjuste da distribuição\r\nValores dos parâmetros\r\nDeterminação dos quantis de cheia\r\nDeterminação dos intervalos que descevem as incertezas na\r\nestimativa\r\nPlotagem\r\ncurva de frequência (Tr vs Q)\r\n\r\nTabelas com resutados\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-23T15:41:10-03:00"
    }
  ],
  "collections": []
}

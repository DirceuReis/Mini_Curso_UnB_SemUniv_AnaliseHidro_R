{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "description": "Some additional details about the website",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-23T15:38:51-03:00"
    },
    {
      "path": "colaboradores.html",
      "title": "Colaboradores",
      "description": "Exclusivo para a Semana Universitária",
      "author": [],
      "contents": "\r\n\r\nContents\r\nThiago\r\nLappicy\r\nSaulo\r\nAires de Souza\r\nLuiz Felipe Pereira de\r\nBrito\r\n\r\nApesar deste curso ser uma iniciativa do grupo Água e Modelagem,\r\ncontamos com a participação exclusiva para a Semana Universtária da UnB\r\nde dois integrantes:\r\nThiago Lappicy\r\nThiago Lappicy é aluno de mestrado do Programa de Engenharia Civil e\r\nAmbiental da Universidade de Brasília (PTARH/UnB).\r\nSaulo Aires de Souza\r\nSaulo é Coordenador de Estudos Hidrológicos da Agência Nacional de\r\nÁguas\r\nLuiz Felipe Pereira de Brito\r\nLuiz Felipe é aluno do curso de Engenharia Ambiental da Universidade\r\nde Brasília\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-23T15:38:52-03:00"
    },
    {
      "path": "conc_basic_R.html",
      "title": "Linguagem R",
      "description": "Conceitos básicos para o curso",
      "author": [],
      "contents": "\r\n\r\nContents\r\nVisão geral do R e RStudio\r\nO\r\nque é a linguagem R\r\nPorque usar o R em\r\nHidrologia?\r\nInstalação do programa\r\nInterface do R e RStudio\r\n\r\nPrimeiros passos e comandos no\r\nR\r\nCriação de\r\nvariáveis e atribuição de valores\r\n\r\nObjetos do R\r\nClasses de\r\nvetores\r\nFatores\r\nCoerção de variáveis\r\nSequências\r\nIndexing\r\nOperações em ou com\r\nvetores\r\n\r\nOutros\r\ntipos de dados (Data Frames, matrizes e listas)\r\nData Frames\r\nMatrizes\r\nListas\r\n\r\nProgramação Básica\r\nFunções\r\nEstruturas condicionais\r\n(ifelse)\r\nLoops (for e\r\nwhile)\r\n\r\n\r\nVisão geral do R e RStudio\r\nO que é a linguagem R\r\nExiste um grande número de publicações sobre a linguagem R, e muitas\r\ndelas podem ser obtidas de forma gratuita na internet, tudo dentro da\r\nlei, sem cometer qualquer violação de direitos autorais.\r\nO livro abaixo é uma dessas publicações, e por se tratar de um livro\r\ndigital, seu autor continua fazendo atualizações em seu conteúdo.\r\nTrata-se de uma excelente fonte de consulta, e ainda nos ensina um pouco\r\nsobre a história por detrás do desenvolvimento do R, e sua relação com a\r\nlinguagem S.\r\nR\r\nProgramming for Data Science, Roger D. Peng, 2019. Johns Hopkins\r\nBloomberg School of Public Health.\r\nPorque usar o R em\r\nHidrologia?\r\nSe você decidiu fazer este curso, você já deve ter uma ideia da\r\nimportância de dominar uma linguagem de programação que te permita\r\nrealizar suas próprias análises, aumentar sua produtividade, testar\r\nnovas metodologias, ou até escrever seus próprios pacotes para serem\r\ndistribuídos na internet de forma a facilitar a vida dos outros.\r\nMas por que o R especificamente? Para ser sincero, o mais importante,\r\nao meu ver, é ter o domínio de uma linguagem de programação. Mas me\r\nparece bastante razoável utilizar uma linguagem que se tornou bastante\r\npopular nos útimos anos, extrapolando os limites da estatística, área\r\ngenitora da linguagem.\r\nMas para não fugir da pergunta, seguem abaixo alguns motivos para\r\nusar a linguagem R na área de engenharia, e mais especificamente, na\r\nárea de Hidrologia,\r\nSimplicidade da linguagem (fácil de aprender)\r\nExcelente desempenho na manipulação de grandes bancos de\r\ndados\r\nAcesso a métodos estatísticos consolidados\r\nAcesso a diversas ferramentas de visualização de dados\r\nAcesso a métodos analíticos de ponta e ferramentas compartilhadas\r\ninternacionalmente - não só pelo uso de pacotes, mas sobretudo, usando\r\nfóruns e tutoriais.\r\n\r\nR in Hydrology , Slater, et al., Hydrol. Earth Syst. Sci., 23,\r\n2939–2963, 2019.\r\nInstalação do programa\r\nOs computadores da sala de aula do curso já têm instalado o\r\nR, assim como o RStudio. Entretanto,\r\npara que você possa se desenvolver rapidamente na linguagem, é muito\r\nimportante que você tenha acesso a esses programs fora do horário do\r\ncurso, ou apos a Semana Universitária.\r\nDessa forma, sugerimos que você instale os dois programas no seu\r\ncomputador pessoal seguindo as instruções fornecidas nos links\r\nabaixo.\r\n\r\n\r\n\r\nDownload de 2 programas: R e\r\nRStudio\r\n R \r\n\r\n\r\n R Studio\r\n\r\n\r\n\r\nRStudio é uma plataforma com inúmeras ferramentas\r\núteis e que roda a linguagem R. É possível usar só o R por sua\r\ninterface, mas só é possível usar o RStudio com o R instalado na\r\nmáquina.\r\nInterface do R e RStudio\r\nAbaixo temos a interface do R quando o baixamos. Ele\r\né de fato o programa que rodamos e programamos com ele.\r\n\r\nBaixamos também o RStudio, ele é uma IDE\r\n(Integrated Development Environment). Isso nada mais é do que\r\num facilitador para usar o R, trazendo uma interface\r\nmais amigável para utilização dessa linguagem e algumas facilidades.\r\n\r\nO layout é ajustável em\r\nview -> Panes -> Pane Layout\r\n\r\nPrimeiros passos e comandos no\r\nR\r\nAntes de tudo, vale dizer que organizar seu material de trabalho\r\nenqunto utiliza o R é muito importante. E para isso, é\r\nimportante que você saiba onde está trabalhando na árvore de diretórios\r\ndo seu computador.\r\nOs dois comandos abaixo ajudam nesse processo:\r\ngetwd(): informa em qual diretório você está fazendo\r\nsuas atividades;\r\nsetwd(): define um diretório de trabalho onde seus\r\nscripts ficarão alojados;\r\ndir(): informa quais arquivos estão contidos nesse\r\ndiretório;\r\nsource(): vai puxar e rodar um arquivo\r\nR com esse nome que está no diretório;\r\n\r\n\r\n#getwd()\r\n#setwd(\"C:/cursoR\")\r\n#dir()\r\n#source(\"soma.R\")\r\n\r\n\r\nO R pode ser utilizável como uma calculadora, com os\r\noperadores aritméticos que se conhece, embora os benefícios da linguagem\r\nvai mito além dos de uma simples calculadora.\r\nMAs vamos começar pelas operações básicas da matemática. Para\r\nmultiplicação utilizamos *, para divisão /,\r\npara expoentes ^ e para raiz quadrada usamos\r\nsqrt() - do inglês square root.\r\n\r\n\r\n1 + 2\r\n\r\n[1] 3\r\n\r\n\r\n\r\n12 * 5\r\n\r\n[1] 60\r\n\r\n\r\n\r\n2 / 2\r\n\r\n[1] 1\r\n\r\n\r\n\r\n12 ^ 4\r\n\r\n[1] 20736\r\n\r\n\r\n\r\nsqrt(9)\r\n\r\n[1] 3\r\n\r\nO R trabalha igualmente com vetores e escalares. ABaixo, criamos e\r\nsomamos dois vetores,\r\n\r\n\r\nc(1, 3, 5, 7, 9) + c(2, 4, 6, 8, 10)\r\n\r\n[1]  3  7 11 15 19\r\n\r\nA função c() é usada para concatenar valores, criando vetores de\r\nvalores da mesma classe. Falaremos mais especificamente de\r\nclasse mais à frente.\r\nAo usar o operador multiplicativo *, o\r\nR entende que será feita a operação elemento a elemento\r\ndentro do vetor.\r\n\r\n\r\nc(1, 3, 5, 7) * t(c(2, 4, 6, 8))\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    2   12   30   56\r\n\r\nSe o objetivo, por outro lado, for o de realizar uma multiplicação de\r\nmatrizes, o operador correto a ser usado é %*%, o que é\r\nmuito importante na vetorização!\r\n\r\n\r\nc(1, 3, 5, 7) %*% t(c(2, 4, 6, 8))\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    2    4    6    8\r\n[2,]    6   12   18   24\r\n[3,]   10   20   30   40\r\n[4,]   14   28   42   56\r\n\r\nCriação de\r\nvariáveis e atribuição de valores\r\nA forma de se atribuir um valor a um elemento/objeto é utilizando o\r\noperador <-, de forma que deve haver algo dos dois lados\r\ndessa seta. De uma lado o objeto que irá receber o valor, e do outro\r\nlado o valor propriamente dito.\r\n\r\n\r\nx <- 2\r\nx\r\n\r\n[1] 2\r\n\r\nTambém é possível usar o operador = para fazer isso,\r\nporém não é recomendado. Se atribuirmos algum outro valor à variável\r\nx, o valor antigo será perdido.\r\nVeja que o R aceita trocar trocar a direção da seta,\r\nmas ela sempre deve apontar para o nome do objeto que vai receber o\r\nvalor, como no exemplo abaixo,\r\n\r\n\r\n-8 -> x\r\nx\r\n\r\n[1] -8\r\n\r\nPode-se atribuir, por exemplo, um valor não-numérico a\r\nx.\r\n\r\n\r\nx <- \"teste\"\r\nx\r\n\r\n[1] \"teste\"\r\n\r\nAlguns dos operadores que existem no R são: <-,\r\n= e ==. Como já comentado, os operadores\r\n<- e = podem ser usados para atribuir\r\nvalores a variáveis/objetos, mas recomendamos utilizar smepre o\r\n<- porque o = também serve para outras\r\ncoisas (falaremos disso mais a frente quando formos criar funções!).\r\nJá o símbolo == funciona para avaliar uma igualdade e\r\nnão para atribuir um valor a um elemento do R. QUando utilizamos\r\n==, o R retorna uma variável lógica,\r\npodendo ser TRUE ou FALSE. Por exemplo:\r\n\r\n\r\nx = 2\r\nx == 2\r\n\r\n[1] TRUE\r\n\r\nA segunda linha de código acima pode ser interpretada como uma\r\npergunta que fazemos ao R, x é igual a 2?\r\nE ele responde em termos de TRUE ou FALSE.\r\nComo neste momento, x=2, se perguntarmos, x\r\né igua a 3? Qual deve ser a resposta?\r\n\r\n\r\nx == 3\r\n\r\n[1] FALSE\r\n\r\nMas existem outros operadores lógicos que também são muito úteis,\r\ncomo na linha de código abaixo em que queremos saber se x é\r\ndiferente de 2,\r\n\r\n\r\nx != 2\r\n\r\n[1] FALSE\r\n\r\nOs operadores matemáticos >, <,\r\n>= e <= também podem ser utilizados,\r\n\r\n\r\nx < 3\r\n\r\n[1] TRUE\r\n\r\n\r\n\r\nx >= 2\r\n\r\n[1] TRUE\r\n\r\nObjetos do R\r\nExistem diversas classes de objetos dentro do\r\nR, alguns dos principais tipos são:\r\nCaractere (letras);\r\nNumérico (real);\r\nInteiro;\r\nComplexo;\r\nFator (classes);\r\nLógico (TRUE/FALSE).\r\nPara sabermos qual classe cada objeto é, podemos utilizar uma função\r\ninterna ao R chamada class(). Usualmente,\r\nas funções vão sempre terminar com um parêntesis (), sendo\r\nque dentro dele botamos os argumentos da função - o que ela precisa\r\n(nesse caso, o objeto). Mais a frente falaremos com maiores detalhes\r\nsobre esses argumentos, funções em geral e até como criar uma sua.\r\n\r\n\r\nx <- 2\r\nclass(x)\r\n\r\n[1] \"numeric\"\r\n\r\ny <- \"oi\"\r\nclass(y)\r\n\r\n[1] \"character\"\r\n\r\nz <- TRUE\r\nclass(z)\r\n\r\n[1] \"logical\"\r\n\r\nA forma mais básica de armazenar objetos dessas classes é na forma de\r\nvetor e os vetores podem ser criados, com a função c() já\r\nutilizada antes. A regra geral é que os vetores só armazenam objetos de\r\nmesma classe. Para criarmos um objeto contendo vários tipos de classes\r\ndiferentes, podemos utilizar objetos do tipo list e\r\ndataframe, como veremos mais à frente.\r\nVia de regra, o R enverga números quando se utiliza um valor\r\nnumérico. Para se criar uma variável do tipo inteiro\r\n(integer), deve-se acrescentar a letra L ao\r\nfinal:\r\n\r\n\r\nx <- 2L\r\nclass(x)\r\n\r\n[1] \"integer\"\r\n\r\nClasses de vetores\r\nVetores só podem conter variáveis de um tipo. Abaixo colocamos três\r\nexemplos para três tipos de classes diferentes (numérico, lógico e\r\ncaractere).\r\n\r\n\r\nx <- c(1, 2, 3, 4)\r\nclass(x)\r\n\r\n[1] \"numeric\"\r\n\r\n\r\n\r\ny <- c(FALSE, TRUE, T, F)\r\ny\r\n\r\n[1] FALSE  TRUE  TRUE FALSE\r\n\r\nprint(y)\r\n\r\n[1] FALSE  TRUE  TRUE FALSE\r\n\r\nclass(y)\r\n\r\n[1] \"logical\"\r\n\r\n\r\n\r\nx <- c(\"ola\", \"bom\", \"dia\", \"programadores\")\r\nx\r\n\r\n[1] \"ola\"           \"bom\"           \"dia\"           \"programadores\"\r\n\r\nclass(x)\r\n\r\n[1] \"character\"\r\n\r\nFatores\r\nO factor é uma importante classe de elemento no R para\r\ndefinir variáveis categóricas. São úteis em modelos de regressão linear\r\ncom variáveis categóricas de entrada (estações do ano, classes de solo,\r\ncotas de alerta hidrológico etc.):\r\n\r\n\r\nx <- factor(c(\"normal\", \"atenção\", \"alerta\", \"inundação\",\r\n              \"inundação severa\", \"inundação\", \"atenção\",\r\n              \"normal\", \"inundação\", \"normal\", \"alerta\"))\r\nx\r\n\r\n [1] normal           atenção          alerta          \r\n [4] inundação        inundação severa inundação       \r\n [7] atenção          normal           inundação       \r\n[10] normal           alerta          \r\nLevels: alerta atenção inundação inundação severa normal\r\n\r\ntable(x)\r\n\r\nx\r\n          alerta          atenção        inundação inundação severa \r\n               2                2                3                1 \r\n          normal \r\n               3 \r\n\r\nCoerção de variáveis\r\nQuando se tem diferentes tipos de classes dentro de um vetor, é feita\r\numa coerção automática para que tudo fique com a mesma classe. Dessa\r\nforma, ao criar um vetor contendo dados do tipo caractere e numérico, o\r\nR supõe que todas as informações eram para ser do tipo\r\ncaractere:\r\n\r\n\r\nx <- c(\"ola\", 1, \"dia\", 2)\r\nx\r\n\r\n[1] \"ola\" \"1\"   \"dia\" \"2\"  \r\n\r\nclass(x)\r\n\r\n[1] \"character\"\r\n\r\nPodemos forçar uma coerção no R, a chamada\r\nCoerção explícita. Fazemos isso utilizando funções do\r\ntipo:\r\nas.numeric();\r\nas.character();\r\nas.logical();\r\nas.factor();\r\nas.complex().\r\nCom elas o R vai transformar o vetor (ou objeto) em\r\nquestão no tipo que você definiu. Isso pode ser uma tarefa simples ou\r\ncomplicada pro programa. No exemplo abaixo, transformar tudo em\r\ncaractere é relativamente fácil, o R apenas assume que\r\no número é um string (um caractere). Dessa forma não\r\nconseguimos fazer operações aritméticas com ele, mas conseguimos fazer\r\nalguns tratamentos utilizados em texto.\r\n\r\n\r\nx <- as.character(3)\r\nx\r\n\r\n[1] \"3\"\r\n\r\nclass(x)\r\n\r\n[1] \"character\"\r\n\r\nx + 1\r\n\r\nError in x + 1: non-numeric argument to binary operator\r\n\r\nPdemos fazer a mesma coerção para que o vetor seja numérico. Assim\r\niremos transformar tudo dentro do vetor como classe numérico. Nesse\r\ncaso, a tarefa pro R é complicada.. afinal, como\r\ntransformar “ola” em um número? Nesses casos, no lugar é retornado um\r\nvalor NA (Not Available):\r\n\r\n\r\nx <- as.numeric(c(\"ola\", 1, \"dia\", 2))\r\n\r\nWarning: NAs introduced by coercion\r\n\r\nx\r\n\r\n[1] NA  1 NA  2\r\n\r\nclass(x)\r\n\r\n[1] \"numeric\"\r\n\r\nSequências\r\nPara criar vetores sequenciais podemos fazer manualmente.\r\n\r\n\r\nx <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\r\nx\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\nTambém podemos utilizar o símboblo : para facilitar.\r\nAssim a sequência é gerada somando um a um.\r\n\r\n\r\nx <- c(1:10)\r\nx\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\nExiste também funções para isso, como a função seq().\r\nCom o primeiro valor sendo em qual número começamos a sequência e o\r\nsegundo sendo até onde a sequêcia deve ir, sempre indo de 1 em 1.\r\n\r\n\r\nx <- seq(1, 10)\r\nx\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\nEssa função pode utilizar 3 valores. O terceiro é o tamanho do passo\r\na ser dado, abaixo é feita uma sequência de 1 a 10, andando de 4 em 4.\r\nEle não vai retornar 10 porque a sequência não passa por ele (ela seria\r\n1, 5, 9, 13, 17…), mas vai retornar o maior número antes do segundo\r\ncolocado dentro do seq().\r\n\r\n\r\nx <- seq(1, 10, 4)\r\nx\r\n\r\n[1] 1 5 9\r\n\r\nIndexing\r\nPara selecionar um valor específico dentro de um vetor, se usa\r\ncolchetes []. Assim, se quiser o primeiro elemento do vetor\r\nx eu escrevo x[1]. O mesmo vale para\r\nselecionar o primeiro, segundo e quinto elemento, escreveria\r\nx[c(1, 2, 5)].\r\n\r\n\r\nx <- c(11:20)\r\nx\r\n\r\n [1] 11 12 13 14 15 16 17 18 19 20\r\n\r\nx[1]\r\n\r\n[1] 11\r\n\r\nx[c(1, 2, 5)]\r\n\r\n[1] 11 12 15\r\n\r\nOperações em ou com vetores\r\nPodemos fazer operações com vetores igual faziamos com números no\r\ncomeço. Os mesmos operadores são utilizados aqui. Por exemplo, se\r\nquisermos dobrar os valores de um vetor, podemos simplesmente fazer\r\n2* esse vetor. Em geral as operações aritméticas feitas em\r\num vetor são feitas elementos a elementos. Para realizar operações\r\nmatriciais a notação muda um pouco.\r\n\r\n\r\nx <- c(1:5)\r\n2*x\r\n\r\n[1]  2  4  6  8 10\r\n\r\n\r\n\r\nsqrt(2*x/4)\r\n\r\n[1] 0.7071068 1.0000000 1.2247449 1.4142136 1.5811388\r\n\r\nÉ possível inclusive fazer operações entre vetores. Porém, caso os\r\nvetores não sejam do mesmo tamanho teremos um problema ao fazer a\r\noperação elemento a elemento (vai acabar faltando algum). O\r\nR, nesse caso, vai fazer a operação até onde ele\r\nconseguir e irá retornar uma mensagem de aviso (Warning) - mas\r\na conta será feita! Abaixo tentamos somar os vetores x e\r\ny. Como o vetor y tem um elemento a menos que\r\nx, a soma vai ser feita normalmente para os primeiros 4\r\nelementos de x, ao fazer o quinto, porém, o\r\nR vai voltar ao inicio do y - somando\r\nentão o quinto elemento de x com o primeiro do\r\ny.\r\n\r\n\r\ny <- c(1:4)\r\nx + y\r\n\r\n[1] 2 4 6 8 6\r\n\r\nPodemos misturar essas operações com o indexing comentado\r\nanteriormente. Por exemplo, se quisermos saber quais valores do vetor\r\nx são maiores que 6 posso escrever como abaixo. É retornado\r\napenas uma sequência de valores TRUE ou FALSE\r\npara cada elemento do vetor.\r\n\r\n\r\nx > 6\r\n\r\n[1] FALSE FALSE FALSE FALSE FALSE\r\n\r\nSe quiser saber quantos valores dentro do meu vetor são maiores do\r\nque 6, ao invés de contar na mão posso usar a função sum()!\r\nIsso acontece porque os valores lógicos também funcionam como número,\r\nvalores TRUE são equivalentes a 1 e valores\r\nFALSE são iguais a 0. Assim somando os valores\r\nTRUE, conseguimos saber quantos números dentro do vetor\r\nx são maiores que 6.\r\n\r\n\r\nsum(x > 6)\r\n\r\n[1] 0\r\n\r\nAbaixo, fazemos quais são os valores desse vetor que são maiores do\r\nque 6.\r\n\r\n\r\nx[x > 6]\r\n\r\ninteger(0)\r\n\r\nOutros\r\ntipos de dados (Data Frames, matrizes e listas)\r\nData Frames\r\nmatrix: todos os elementos são da mesma classe;\r\nlist: cada elemento pode pertencer a uma classe\r\ndiferente.\r\ndata.frame: dentro de cada coluna, os objetos pertencem\r\nà mesma classe, mas diferentes colunas podem pertencer a diferentes\r\nclasses;\r\nQuando são lidos objetos externos (planilhas excel, arquivos .txt ou\r\n.csv), usando as funções do R read.table() ou\r\nread.csv(), por exemplo, o objeto criado é um\r\ndata.frame.\r\nA classe de data.frame é muito utilizada em R. É o que\r\nse utiliza para dados tabulados. Além disso, todos os elementos do\r\ndata.frame têm o mesmo comprimento.\r\n\r\n\r\nDF <- data.frame(x = c(1:3), coluna_2 = c(\"A\", \"B\", \"C\"))\r\nDF\r\n\r\n  x coluna_2\r\n1 1        A\r\n2 2        B\r\n3 3        C\r\n\r\nclass(DF)\r\n\r\n[1] \"data.frame\"\r\n\r\nCoerção de classe para data.frame.\r\n\r\n\r\nm <- matrix(c(1:9), nrow = 3)\r\nm <- as.data.frame(m)\r\nm\r\n\r\n  V1 V2 V3\r\n1  1  4  7\r\n2  2  5  8\r\n3  3  6  9\r\n\r\nCoerção de classe para data.frame.\r\n\r\n\r\nm <- matrix(c(1:9), nrow = 3); attributes(m)\r\n\r\n$dim\r\n[1] 3 3\r\n\r\nattributes(as.data.frame(m))\r\n\r\n$names\r\n[1] \"V1\" \"V2\" \"V3\"\r\n\r\n$class\r\n[1] \"data.frame\"\r\n\r\n$row.names\r\n[1] 1 2 3\r\n\r\nMatrizes\r\nMatrizes são objetos objetos semelhantes a vetores, entretanto, com o\r\natributo dimensão dim.\r\n\r\n\r\nm <- matrix(nrow = 2, ncol = 3); m\r\n\r\n     [,1] [,2] [,3]\r\n[1,]   NA   NA   NA\r\n[2,]   NA   NA   NA\r\n\r\nattributes(m)\r\n\r\n$dim\r\n[1] 2 3\r\n\r\nMatrizes podem ser criadas a partir de vetores, adicionando o\r\natribuito dimensão.\r\n\r\n\r\nm <- matrix(x, nrow = 2, ncol = 5); m\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    3    5    2    4\r\n[2,]    2    4    1    3    5\r\n\r\nm <- matrix(x, nrow = 2, ncol = 5, byrow = TRUE); m\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    2    3    4    5\r\n[2,]    1    2    3    4    5\r\n\r\nPara selecionar elementos de uma matriz, é necessário especificar as\r\nduas dimensões:\r\n\r\n\r\nm <- matrix(1:4, nrow = 2); m\r\n\r\n     [,1] [,2]\r\n[1,]    1    3\r\n[2,]    2    4\r\n\r\nm[2,2]\r\n\r\n[1] 4\r\n\r\nSelecionar elementos de matrizes quadradas:\r\n\r\n\r\nlower.tri(m)\r\n\r\n      [,1]  [,2]\r\n[1,] FALSE FALSE\r\n[2,]  TRUE FALSE\r\n\r\nupper.tri(m)\r\n\r\n      [,1]  [,2]\r\n[1,] FALSE  TRUE\r\n[2,] FALSE FALSE\r\n\r\nSelecionar elementos de matrizes quadradas:\r\n\r\n\r\nm[lower.tri(m)] <- NA; m\r\n\r\n     [,1] [,2]\r\n[1,]    1    3\r\n[2,]   NA    4\r\n\r\ndiag(m) <- NA; m\r\n\r\n     [,1] [,2]\r\n[1,]   NA    3\r\n[2,]   NA   NA\r\n\r\nVetores podem ser unidos a fim de criar uma matriz:\r\n\r\n\r\nx <- c(1:10)\r\ny <- rnorm(10, 10, 5)\r\nuniao <- cbind(x, y)\r\nuniao\r\n\r\n       x          y\r\n [1,]  1 17.1460967\r\n [2,]  2  1.6894210\r\n [3,]  3 13.9688241\r\n [4,]  4 -3.5342734\r\n [5,]  5  1.7062229\r\n [6,]  6  0.3694579\r\n [7,]  7  5.4473491\r\n [8,]  8 12.7948408\r\n [9,]  9  9.0779082\r\n[10,] 10 15.9105311\r\n\r\ndim(uniao)\r\n\r\n[1] 10  2\r\n\r\nA função cbind() adiciona colunas as matrizes.\r\nVetores podem ser unidos a fim de criar uma matriz:\r\n\r\n\r\nx <- c(1:10)\r\ny <- rnorm(10, 20, 5)\r\nuniao <- rbind(x, y)\r\nuniao\r\n\r\n     [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7]\r\nx  1.0000  2.00000  3.00000  4.00000  5.00000  6.00000  7.00000\r\ny 28.7989 11.62114 21.53587 18.96327 17.33439 20.95428 18.61884\r\n     [,8]     [,9]  [,10]\r\nx  8.0000  9.00000 10.000\r\ny 21.1532 17.07201 13.602\r\n\r\ndim(uniao)\r\n\r\n[1]  2 10\r\n\r\nA função rbind() adiciona linhas as matrizes.\r\nListas\r\nListas são elementos importantes na programação em R. Uma das\r\nvantagens de se saber utilizar bem esse tipo de elemento é que nelas é\r\npossível armazenar elementos de diferentes tipos (caracter, número real,\r\ninteiro, complexo, lógico).\r\nElas são diferentes dos vetores que, via de regra, só armazenam\r\nobjetos de mesma classe.\r\nPara criar uma lista:\r\n\r\n\r\nx <- list(1, \"Ola\", 1+5i, TRUE, 4L)\r\nx\r\n\r\n[[1]]\r\n[1] 1\r\n\r\n[[2]]\r\n[1] \"Ola\"\r\n\r\n[[3]]\r\n[1] 1+5i\r\n\r\n[[4]]\r\n[1] TRUE\r\n\r\n[[5]]\r\n[1] 4\r\n\r\nPara selecionar dados de listas, utiliza-se o duplo cochete\r\n[[]]:\r\n\r\n\r\nx <- list(c(1,2,3), c(\"Ola\", \"Mundo\"), 1+5i, TRUE, 4L)\r\nx[[1]]\r\n\r\n[1] 1 2 3\r\n\r\nx[[2]][2]\r\n\r\n[1] \"Mundo\"\r\n\r\nx[[5]] + 6\r\n\r\n[1] 10\r\n\r\nProgramação Básica\r\nFunções\r\nUma coisa essencial em qualquer linguagem de programação é a criação\r\ne utilização de funções. O R (assim como outras\r\nlinguagens) já vem com diversas funções instaladas nele mesmo - chamamos\r\nisso de R base. Por exemplo, se quisermos calcular o\r\nlog de algum valor, podemos utilizar a função\r\nlog() colocando dentro do parênteses o valor que\r\nqueremos.\r\n\r\n\r\nlog(10)\r\n\r\n[1] 2.302585\r\n\r\nPara saber o que é preciso colocar dentro dos parênteses, ou seja,\r\nquais os argumentos (inputs) que cada função toma, podemos\r\nutilizar a função args(). Usando ela com o log (dessa vez\r\nsem parênteses) dentro, podemos ver que a função toma dois argumentos: o\r\nx (valor em que se calcula o logaritmo) e a\r\nbase que já vem com um valor definido de exponencial. Para\r\nse ter mais informações sobre alguma função, podemos, além de usar\r\nargs() utilizar uma interrogação anterior ao nome da função\r\n(sem parêntesis), ou usar a função help(). Essas duas\r\núltimas opções são equivalentes e nos mostram a documentação feita para\r\nessa função no R.\r\n\r\n\r\nargs(log)\r\n?log\r\nhelp(log)\r\n\r\n\r\nO segundo argumento do log() pode ser modificado, basta\r\ndeixar ele explícito ao chamar a função. Não precisamos escrever qual\r\nargumento estamos utilizando desde que se siga a ordem da função\r\n(mostrada anteriormente). Caso se queira escrever os argumentos em outra\r\nordem, é possível, mas é necessário escrever cada um deles. Veja melhor\r\no exemplo abaixo. O primeiro não definimos a base, portanto é usada a\r\npré definida (exponencial). No segundo log feito, não escrevemos qual a\r\nbase e qual o número que queremos o logaritmo, portanto o\r\nR assume que estamos escrevendo na ordem da função, que\r\ntoma como primeiro argumento o valor e o segundo argumento a base. No\r\nterceiro exemplo trocamos as ordens dos argumentos, mas para isso\r\nprecisamos deixar explícito (escrito) quem é cada um.\r\n\r\n\r\nlog(100)\r\n\r\n[1] 4.60517\r\n\r\nlog(100, 10)\r\n\r\n[1] 2\r\n\r\nlog(base = 10, x = 100)\r\n\r\n[1] 2\r\n\r\nAgora vamos fazer nossa própria função dentro do R.\r\nPara isso, primeiro definimos um nome para ser o nome da função (como\r\nfizemos com criação de variáveis / objetos), por exemplo\r\n“fun_area_circulo”. Em seguida devemos dizer que vamos criar uma função\r\ne quais os argumentos que ela toma. Para fazer o exemplo, a área de um\r\ncírculo, precisamos apenas de uma informação - o raio desse círculo.\r\nPodemos fazer quantas operações quisermos dentro da função, no final o\r\núltimo valor será retornado por ela (podemos deixar isso explícito\r\nescrevendo return) nela. Depois chamamos ela como qualquer\r\noutra função!\r\n\r\n\r\nfun_area_circulo <- function(raio){\r\n  x <- 2*pi*raio\r\n  return(x)\r\n}\r\n\r\nfun_area_circulo(5)\r\n\r\n[1] 31.41593\r\n\r\nEstruturas condicionais\r\n(ifelse)\r\nEm programação, algo extremamente importante e útil são os comandos\r\nif e else (e / se). Com\r\nesses comandos, é possível rodar um código apenas se uma condição for\r\ncumprida. Esse comando no R funciona similar a uma\r\nfunção, sendo então o ifelse() (tudo junto!), e toma três\r\nargumentos - um lógico (uma condição), o que fazer se o lógico for\r\nTRUE e o que fazer se o lógico for FALSE.\r\nAbaixo fazemos um exemplo utilizando o ifelse para\r\nverificar se o X é maior ou menor do que 100.\r\n\r\n\r\nx <- 10\r\nifelse(x < 100, \"X é menor que 100\", \"X é maior ou igual a 100\")\r\n\r\n[1] \"X é menor que 100\"\r\n\r\n\r\n\r\nx <- 1000\r\nifelse(x < 100, \"X é menor que 100\", \"X é maior ou igual a 100\")\r\n\r\n[1] \"X é maior ou igual a 100\"\r\n\r\nÉ possível usar também só o if como um comando. Em\r\nseguida rodamos um código para que, se o X for um número não inteiro,\r\narredondamos ele e em seguida o transformamos em inteiro.\r\n\r\n\r\nx <- 3.7\r\nif(class(x) != \"integer\") x <- as.integer(round(x))\r\nclass(x)\r\n\r\n[1] \"integer\"\r\n\r\nLoops (for e while)\r\nA última coisa a se falar do R “básico” é a\r\nconstrução de loops. Eles são utilizados quando queremos\r\nrepetir a mesma coisa várias vezes.\r\nfor\r\nO for() utiliza 2 argumentos. O primeiro fala qua objeto\r\nvai ser iterado várias vezes, e o outro a faixa de valores (quantas\r\nvezes ele vai ser iterado praticamente). No exemplo abaixo vamos por\r\nexemplo variar o i (criado dentro do próprio loop)\r\nna sequência de 1 até 5. Isso é o mais importante desse tipo de\r\nloop, precisamos saber quantas vezes\r\n(1:5) iterar essa variável (nesse caso i). O\r\nresto da função é simplesmente o que vai ser iterado. No exemplo abaixo\r\napenas printamos o valor de i quando ele varia de 1 a\r\n5.\r\n\r\n\r\nfor(i in 1:5){\r\n  print(i)\r\n}\r\n\r\n[1] 1\r\n[1] 2\r\n[1] 3\r\n[1] 4\r\n[1] 5\r\n\r\nwhile\r\nDiferente do for, utilizamos o while quando\r\nnão sabemos a priori quando queremos terminar nosso\r\nloop. Ou seja, vamos ficar repetindo o que foi feito até certa\r\ncondição ser cumprida. No exemplo abaixo, printamos na tela o valor de\r\ni, sendo que a cada “rodada” aumentamos o valor de\r\ni em uma unidade. Isso é feito até o i ser\r\nmenor ou igual a 5, por exemplo.\r\n\r\n\r\ni <- 0\r\n\r\nwhile(i <= 5){\r\n  print(i)\r\n  i <- i + 1\r\n}\r\n\r\n[1] 0\r\n[1] 1\r\n[1] 2\r\n[1] 3\r\n[1] 4\r\n[1] 5\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-27T10:46:14-03:00"
    },
    {
      "path": "data_explore.html",
      "title": "Análise exploratória dos dados",
      "description": "Como obter uma visão geral dos dados",
      "author": [],
      "contents": "\r\n\r\nContents\r\nLeitura dos dados\r\ngerados na última aula\r\nVisualizar a\r\ndisponibilidade de dados\r\nPlotagem da série\r\nhistórica\r\nCaracterização da\r\ndistribuição\r\nDiagramas de caixa\r\n(boxplot)\r\nHistograma\r\nFunções de densidade\r\n\r\nFrequência amostral\r\nCurva\r\nde permanência\r\nAvaliação de tendência\r\nmonotônica\r\n##\r\nMedidas de associação\r\nCaracterização gráfica com\r\nggplot2\r\nGráficos com as 4 estações\r\nOutros gráficos\r\ninteressantes\r\nGráficos usando\r\na tabela de resumo estatístico\r\nLivros !\r\nLivro do criador do\r\nggplot2:\r\nEntender melhor quais cores\r\nusar:\r\nTodas as\r\ncores do R:\r\n\r\n\r\n\r\nNesta aula, iremos realizar um conjunto de atividade que nos ajudarão\r\nentender os dados que temos em mão. Essas atividade são conhecidas como\r\nanálise exploratória de dados.\r\nNão existe um conjunto único de atividades que define uma\r\nanálise exploratória. O que se costuma fazer nessa\r\netapa de um estudo vai depender da natureza do estudo.\r\nEmbora nossa atividade final é a de relaizar um estudo de análise de\r\nfrequÊncia de cheias, nesta aula, apresentaremos algumas atividades mais\r\ngerais, que podem e devem ser utilizadas em outros tipos de estudo.\r\nPara iniciar essas atividades, vamos primeiro carregar os dados que\r\nforam obtidos na aual anterior e gravados em arquivos no fomato\r\ntexto.\r\nLeitura dos dados\r\ngerados na última aula\r\nPara carregar esses dados de vazão, precisamos ler os arquivos com\r\nextensão txt, que foram criados com os dados de vazão\r\nobtidos via webservide da ANA.\r\nFaremos isso com os três arquivos existentes, o primeiro que contém\r\napenas a série histórica de uma estação específica, o segundo que\r\nconsiste dos dados diários da série histórica de quatro estações, e por\r\núltimo, aquele com os valores de máximo, mínimo e média todos a nível\r\nanual.\r\nPara não precisarmos redefinir a coluna de Datas como sendo do\r\nformato Date (lembrar que o R vai ler ela\r\nautomaticamente como character), podemos usar o argumento\r\ncolClasses = para avisar ao R a classe\r\nde cada coluna. Além disso, vamos aproveitar e transformar a coluna de\r\ncódigo das estações como fator. Se não souber qual a classe uma coluna,\r\npode-se botar NA - porém é importante notar que é\r\nobrigatório informar o tipo. Caso coloque menos\r\nargumentos no vetor do que o número de colunas, o R irá\r\niterar sobre o vetor informado.\r\n\r\n\r\ndados_60435000 <- read.table(file = \"dados/60435000.txt\",\r\n                             sep = \"\\t\",\r\n                             dec = \".\",\r\n                             header = T,\r\n                             fileEncoding = \"UTF-8\",\r\n                             colClasses = c(\"factor\", \"Date\", \"numeric\"))\r\n\r\ndados_todas <- read.table(file = \"dados/todas_estacoes.txt\",\r\n                          sep = \"\\t\",\r\n                          dec = \".\",\r\n                          header = T,\r\n                          fileEncoding = \"UTF-8\",\r\n                          colClasses = c(\"factor\", \"Date\", NA))\r\n                          \r\nresumo_todas <- read.table(file = \"dados/Resumo_estacoes.txt\",\r\n                           sep = \"\\t\",\r\n                           dec = \".\",\r\n                           header = T,\r\n                           fileEncoding = \"UTF-8\")\r\n\r\n\r\nVisualizar a\r\ndisponibilidade de dados\r\nÉ comum realizar estudos hidrológicos que contemplem, pelo menos num\r\nprimeiro momento, um número elevado de estações que, em tese, podem ser\r\nutilizadas.\r\nPara termos uma visão de conjunto dos dados que estão disponíveis, é\r\ninteressante fazer uma plotagem que permite entender o período de dados\r\ndisponíveis em cada estação, bem como a ocorrência de falhas nas séries.\r\nEssa visão mais geral nos ajuda a definir quais estações devem ser\r\nselecionadas, e possivelmente o período de dados mais adequado para o\r\nestudo.\r\nMas mesmo que estejamos trabalhando com apenas uma estação, é sempre\r\ninteressante visualizar o período disponível, bem como as falhas\r\ncontidas no registro.\r\nIniciaremos essa visualização da disponibilidade dos dados com apenas\r\numa estação. Na etapa seguinte, expandiremos para um conjunto de quatro\r\nestações selcionadas na aula anterior.\r\nFaremos um gráfico do tipo heatmap, que é\r\nbasicamente uma figura que coloca cores numa Tabela. Neste primeiro\r\npasso, para cada estação, faremos um heatmap das vazões\r\nmédias mensais com os anos no eixo-y e os meses no eixo-x. A tonalidade\r\ndas cores estará associada à magnitude da vazão média do mês em questão.\r\nQuando o mês não possui vazão, a região do mês correspodente ficará\r\nbranca.\r\nO resultado final permite visualizar, dentro de uma faixa de anos, a\r\nmagnitude das vazões por meio de cores, e também a ocorrência de falhas\r\nnos registros, permitindo reconhecer de cara a sazonalidade das vazões,\r\ncom cores mais fortes no período úmido e cores mais suaves no período\r\nseco.\r\nPara construir essa Figura inicial com apenas uma estação, vamos\r\ntrabalhar com o dataframe denominado\r\ndados_60435000, cujas primeiras observações podem ser\r\nvistas abaixo, onde observamos 3 colunas, o código da estação, a data, e\r\no valor da vazão diária correspondente.\r\n\r\n\r\nhead(dados_60435000)\r\n\r\n  Cod_estacao       Data Vazao\r\n1    60435000 1978-05-01    NA\r\n2    60435000 1978-05-02    NA\r\n3    60435000 1978-05-03    NA\r\n4    60435000 1978-05-04    NA\r\n5    60435000 1978-05-05    NA\r\n6    60435000 1978-05-06    NA\r\n\r\nPara facilitar a construção do heatmap, que precisa\r\nseparar as informações de mês e ano, vamos expandir o dataframe com mais\r\nduas colunas, uma com os meses e a outra com os anos, como pode ser\r\nvisto na sequência,\r\n\r\n\r\ndados_60435000$Ano <- year(dados_60435000$Data)\r\ndados_60435000$Mes <- month(dados_60435000$Data)\r\nhead(dados_60435000)\r\n\r\n  Cod_estacao       Data Vazao  Ano Mes\r\n1    60435000 1978-05-01    NA 1978   5\r\n2    60435000 1978-05-02    NA 1978   5\r\n3    60435000 1978-05-03    NA 1978   5\r\n4    60435000 1978-05-04    NA 1978   5\r\n5    60435000 1978-05-05    NA 1978   5\r\n6    60435000 1978-05-06    NA 1978   5\r\n\r\nAs duas colunas extras permitirão a realização do cálculo das vazões\r\nmédias mensais para cada ano. Para isso, utilizaremos as funções\r\ngroup_by(), summarize() e mean().\r\nAo final, rearrumamos as linhas em ordem decrescente de ano apenas para\r\ncriarmos um heatmap que coloque os anos iniciais na\r\nparte de cima da Figura, com veremos mais adiante,\r\n\r\n\r\ndados_60435000_v2 <-\r\n  dados_60435000 %>%\r\n  group_by(Cod_estacao, Ano, Mes) %>%\r\n  summarise(Vazao = mean(Vazao)) %>%\r\n  arrange(desc(Ano))\r\n  \r\ntail(dados_60435000_v2, 12)\r\n\r\n# A tibble: 12 × 4\r\n# Groups:   Cod_estacao, Ano [2]\r\n   Cod_estacao   Ano   Mes Vazao\r\n   <fct>       <dbl> <dbl> <dbl>\r\n 1 60435000     1979     9  1.63\r\n 2 60435000     1979    10  1.38\r\n 3 60435000     1979    11  2.19\r\n 4 60435000     1979    12  2.15\r\n 5 60435000     1978     5 NA   \r\n 6 60435000     1978     6  2.20\r\n 7 60435000     1978     7  1.80\r\n 8 60435000     1978     8  1.52\r\n 9 60435000     1978     9  1.34\r\n10 60435000     1978    10  1.59\r\n11 60435000     1978    11  1.40\r\n12 60435000     1978    12  2.71\r\n\r\nCom esse novo_dataframe em mãos, podemos construir a Figura desejada.\r\nMas para utilizar a função heatmap(), precisamos fazer uma\r\npequena reestruturação, já que essa função precisa receber uma matriz\r\ncom os valores de vazão média mensal, que devem estar organizados de uma\r\nforma específica, com as linhas representando os anos e as colunas\r\nrepresentando os meses. Essa reestruturação é feita com o código\r\nabaixo,\r\n\r\n\r\ndados_heatmap <- pivot_wider(data = dados_60435000_v2,\r\n                             names_from = Mes,\r\n                             values_from = Vazao,\r\n                             names_sort = TRUE)\r\nhead(dados_heatmap)\r\n\r\n# A tibble: 6 × 14\r\n# Groups:   Cod_estacao, Ano [6]\r\n  Cod_estacao   Ano   `1`   `2`   `3`   `4`   `5`   `6`   `7`    `8`\r\n  <fct>       <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>\r\n1 60435000     2021 1.12   4.26  3.18  2.25 1.47  1.05  0.744  0.471\r\n2 60435000     2020 5.02   4.66  7.22  4.94 2.84  1.94  1.38   0.974\r\n3 60435000     2019 2.48   1.86  3.03  3.65 2.11  1.29  0.896 NA    \r\n4 60435000     2018 2.61   2.13  2.55  2.08 1.33  0.840 0.478  0.351\r\n5 60435000     2017 0.876  2.26  1.53  1.26 0.708 0.446 0.266  0.142\r\n6 60435000     2016 3.90   2.67  2.27  1.23 0.933 0.517 0.306  0.176\r\n# … with 4 more variables: `9` <dbl>, `10` <dbl>, `11` <dbl>,\r\n#   `12` <dbl>\r\n\r\nAgora basta utiliza a função heatmap() para construir a\r\nFigura desejada. Primeiro apagamos as primeiras duas colunas dessa\r\nmatriz, porque a primeira traz o código da estação e a segunda os anos,\r\nambas desnecessárias para fazer a Figura.\r\nPara construção do gráfico abaixo, usando a função\r\nheatmap(), precisamos apenas de uma matriz com os valores a\r\nserem utilizados.\r\n\r\n\r\n# Remoção das primeiras duas colunas\r\ndados_heatmap <- as.matrix(dados_heatmap[,-c(1,2)]) \r\n\r\n# Legenda do eixo \"x\" (trocar números pela abreviação dos meses)\r\nmeses <- c(\"Jan\", \"Feb\", \"Mar\", \"Abr\", \"Mai\", \"Jun\",\r\n           \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\")\r\n           \r\n# Criação do heatmap\r\nheatmap(dados_heatmap, Colv = NA, Rowv = NA, scale = \"none\",\r\n        labCol = meses,\r\n        labRow = 2021:1978)\r\n\r\n\r\n\r\nPodemos perceber algumas características importantes nessa plotagem\r\nda disponibilidade dos dados de vazão da estação\r\n60435000.\r\nLogo na primeira linha, que representa o ano de 1978, podemos ver que\r\nnão há dados nos 5 primeiros meses, já que temos a cor branca\r\nrepresentando os valores de vazão. No restante dos anos, pode-se\r\nverificar a ocorrência de falhas em mais três oportunidades: dez/2008,\r\njan/2009 e ago/2019.\r\nAlém das falhas, a Figura indica vazões médias mensais mais baixas\r\n(tons mais suaves) no meio do ano, entre os meses de junho a outubro, e\r\nvazões mais altas (tons mais escuros) entre novembro e maio.\r\nOutra maneira de fazermos o mesmo gráfico é usando o\r\nggplot2, abaixo segue um código mostrando seu formato.\r\nFalaremos mais desse pacote, com suas funções e argumentos, ao decorrer\r\ndeste módulo, portanto não se preocupe tanto com a notação abaixo - o\r\nimportante é mostrar que podemos atingir o mesmo objetivo de diferentes\r\nformas usando diferentes funções dentro do R.\r\n\r\n\r\nggplot() +\r\n  \r\n  # gráfico em sí\r\n  geom_tile(data = dados_60435000_v2,\r\n            aes(x = Mes, y = Ano, fill = Vazao)) +\r\n            \r\n  # o que vai estar no eixo-x:          \r\n  scale_x_discrete(limits = factor(1:12),\r\n                   labels = meses,\r\n                   na.translate = TRUE,\r\n                   expand = c(0, 0)) +\r\n                   \r\n  # escala do nosso eixo-y:                 \r\n  scale_y_continuous(breaks = 1978:2021,\r\n                     trans = \"reverse\", # Aqui deixamos o eixo na ordem decrescente\r\n                     expand = c(0, 0)) +\r\n  \r\n  # as cores de gradiente do nosso gráfico:\r\n  scale_fill_gradient(low = \"lightblue\", high = \"darkblue\",\r\n                      na.value = \"yellow\") +\r\n                      \r\n  # Deixamos aqui sem marcações de qualquer tipo no gráfico\r\n  # Além de colocarmos a cor de fundo amarela (para ficar igual aos valores NAs)\r\n  theme(axis.ticks = element_blank(),\r\n        panel.grid.major = element_blank(),\r\n        panel.grid.minor = element_blank(),\r\n        panel.background = element_rect(fill = \"yellow\"))\r\n\r\n\r\n\r\nPlotagem da série histórica\r\nComo estamos lidando com dadso de vazão, uma das primeira coisas a\r\nfazer é plotar a série histórica, o que permite visualizarmos a faxia de\r\nvariação das vazões diárias, a presença de falhas na série e de valores\r\nmuito diferentes do restante, podendo indicar a necessidade de uma\r\nverificação mais cuidados para confirmarmos que esses valores são\r\nrealmente confiáveis.\r\nO R-base permite plotarmos facilmente a série\r\nhistórica. O código abaixo é o mais simples de todo para realizar esse\r\ntipo de plotagem. Vea que informamos apenas as variáveis referentes aos\r\neixos x e y.\r\n\r\n\r\nplot(x = dados_60435000$Data,\r\n     y = dados_60435000$Vazao)\r\n\r\n\r\n\r\nA Figura gerada não é das mais atraentes, já que o R\r\nfaz suas próprias escolhas, já que não definimos uma gama enorme de\r\nargumentos existentes. É possível fazer um esforço na tentativa de gerar\r\numa Figura um pouco mais atraente, incluindo nomes para os eixos e\r\ntítulo da Figura, espessura da linha, linhas de grade etc,\r\n\r\n\r\nplot(x = dados_60435000$Data,\r\n     y = dados_60435000$Vazao,\r\n     main = \"Estação 60435000\",\r\n     xlab = \"Tempo (anos)\", ylab = \"Vazão (m3/s)\",\r\n     type = \"l\",\r\n     col = \"blue\")\r\n# Adiciona grid horizontal apenas\r\ngrid(nx = NA, ny = NULL,\r\n     lty = 2,      # Grid line type\r\n     col = \"gray\", # Grid line color\r\n     lwd = 2)      # Grid line width\r\n\r\n\r\n\r\n\r\n\r\nhist(dados_60435000$Vazao,xlim = c(0, 40))\r\nrug(jitter(dados_60435000$Vazao))\r\n\r\n\r\n\r\nCaracterização da\r\ndistribuição\r\nDiagramas de caixa\r\n(boxplot)\r\nHistograma\r\nFunções de densidade\r\nFrequência amostral\r\nCurva de permanência\r\nAvaliação de tendência\r\nmonotônica\r\n## Medidas de associação\r\nCaracterização gráfica com\r\nggplot2\r\nDiferentemente dos gráficos que podem ser feitos no R\r\nbase (sem pacotes adicionais), o ggplot2 atua\r\num pouco diferente na forma em que é chamado. Por exemplo, se quisesse\r\nfazer um gráfico da série histórica da estação\r\n60435000, poderíamos fazer sem pacotes.\r\nJá com a função ggplot() não adianta apenas definirmos\r\nem quem iremos mexer. Dentro dessa função existe um argumento chamado de\r\naes. Ele vem do inglês, aesthetics e, como o\r\nnome diz, reflete a estética do gráfico, o que você vai mexer nele\r\n(cores, pontos, linhas…). Se chamarmos apenas o ggplot()\r\ncom o argumento aes definido, nada será plotado, mas\r\nveremos os eixos e as grades (imagem abaixo). Lembrar que esses plots\r\naparecerão no RStudio no canto inferior direito.\r\n\r\n\r\nggplot(dados_60435000, aes(x = Data, y = Vazao))\r\n\r\n\r\n\r\nNo ggplot2, a escrita é um pouco diferente do\r\nR base e se assemelha ao que fizemos com o pipe\r\noperator. Escrevemos ggplot() e em seguida vamos\r\nsomando o que queremos com o sinal de “+”. Por exemplo,\r\nse quisermos um gráfico de linha vamos escrever\r\n+ geom_line(). Temos dois jeitos de escrever isso, um\r\ncolocando os dados dentro do ggplot() e deixando o\r\ngeom_line() em branco, ou o contrário. Ambos códigos abaixo\r\nretornam o mesmo gráfico.\r\n\r\n\r\nggplot(data = dados_60435000, aes(x = Data, y = Vazao)) +\r\n  geom_line()\r\n  \r\nggplot() +\r\n  geom_line(data = dados_60435000, aes(x = Data, y = Vazao))\r\n\r\n\r\n\r\n\r\n\r\nSimilar ao R base, podemos mexer em todos os\r\naspectos gráficos aqui, como a cor dos pontos e o tema\r\n(theme). Esse tema refere a todos os detalhes\r\ngráficos (qual o tamanho das linhas do gráfico, tamanho das letras, do\r\ntítulo, qual fonte…). Já existem diversos temas pré-programados com o\r\nggplot2, como o tema bw (black and white, ou preto e\r\nbranco).\r\n\r\n\r\nggplot() +\r\n  geom_line(data = dados_60435000, aes(x = Data, y = Vazao), col = \"blue\") +\r\n  labs(title = \"Estação 60435000\", subtitle = \"série histórica\",\r\n       caption = \"fonte dos dados: ANA (2022)\",\r\n       x = \"Datas\", y = \"Vazão\") +\r\n  theme_bw()\r\n\r\n\r\n\r\n\r\n\r\nggplot() +\r\n  geom_line(data = dados_60435000, aes(x = Data, y = Vazao), col = \"blue\") +\r\n  labs(title = \"Estação 60435000\", subtitle = \"série histórica\",\r\n       caption = \"fonte dos dados: ANA (2022)\",\r\n       x = \"Datas\", y = \"Vazão\") +\r\n  scale_y_continuous(expand = c(0, 1)) +\r\n  theme_bw() +\r\n  theme(plot.title = element_text(size = 16, face = 2, hjust = 0.5),\r\n        plot.subtitle = element_text(size = 12, hjust = 0.5),\r\n        axis.ticks.y = element_blank(),\r\n        axis.text.x = element_text(angle = 50, vjust = 0.5))\r\n\r\n\r\n\r\n\r\n\r\ntema_top <-\r\n  theme_bw() +\r\n  theme(plot.title = element_text(size = 16, face = 2, hjust = 0.5),\r\n        plot.subtitle = element_text(size = 12, hjust = 0.5),\r\n        axis.ticks.y = element_blank(),\r\n        axis.text.x = element_text(angle = 50, vjust = 0.5))\r\n\r\nggplot() +\r\n  geom_line(data = dados_60435000, aes(x = Data, y = Vazao), col = \"blue\") +\r\n  labs(title = \"Estação 60435000\", subtitle = \"série histórica\",\r\n       caption = \"fonte dos dados: ANA (2022)\",\r\n       x = \"Datas\", y = \"Vazão\") +\r\n  scale_y_continuous(expand = c(0, 1)) +\r\n  tema_top\r\n\r\n\r\n\r\n\r\n\r\ntheme_set(tema_top)\r\n\r\nggplot() +\r\n  geom_line(data = dados_60435000, aes(x = Data, y = Vazao), col = \"blue\") +\r\n  labs(title = \"Estação 60435000\", subtitle = \"série histórica\",\r\n       caption = \"fonte dos dados: ANA (2022)\",\r\n       x = \"Datas\", y = \"Vazão\") +\r\n  scale_y_continuous(expand = c(0, 1))\r\n\r\n\r\n\r\nGráficos com as 4 estações\r\n\r\n\r\nggplot() +\r\n  geom_line(data = dados_todas,\r\n            aes(x = Data, y = Vazao, col = Cod_estacao)) +\r\n  labs(title = \"Estações\",\r\n       caption = \"fonte dos dados: ANA (2022)\",\r\n       x = \"Datas\", y = \"Vazão\",\r\n       col = \"Estação\") +\r\n  scale_y_continuous(breaks = seq(0, 300, 100),\r\n                     minor_breaks = seq(0, 300, 25),\r\n                     expand = c(0, 10))\r\n\r\n\r\n\r\n\r\n\r\nggplot() +\r\n  geom_line(data = dados_todas,\r\n            aes(x = Data, y = Vazao, col = Cod_estacao)) +\r\n  labs(title = \"Estações\",\r\n       caption = \"fonte dos dados: ANA (2022)\",\r\n       x = \"Datas\", y = \"Vazão\",\r\n       col = \"Estação\") +\r\n  scale_y_continuous(breaks = seq(0, 300, 100),\r\n                     minor_breaks = seq(0, 300, 25),\r\n                     expand = c(0, 10)) +\r\n  scale_color_manual(values = c(\"#3943B7\", \"#BDF7B7\",\r\n                                \"#E08E45\", \"#6B2737\")) +\r\n  theme(panel.background = element_rect(fill = \"grey95\"),\r\n        panel.grid.major = element_line(color = \"gray10\",\r\n                                        size = 0.5),\r\n        panel.grid.minor = element_line(color = \"gray70\",\r\n                                        linetype=\"dashed\",\r\n                                        size = 0.25))\r\n\r\n\r\n\r\n\r\n\r\nggplot() +\r\n  geom_line(data = dados_todas, col = \"blue\",\r\n            aes(x = Data, y = Vazao)) +\r\n  labs(title = \"Estações - HidroWeb\",\r\n       caption = \"fonte dos dados: ANA (2022)\",\r\n       x = \"Datas\", y = \"Vazão\") +\r\n  scale_y_continuous(breaks = seq(0, 300, 100),\r\n                     minor_breaks = seq(0, 300, 25),\r\n                     expand = c(0, 10)) +\r\n  facet_wrap(~ Cod_estacao, nrow = 4)\r\n\r\n\r\n\r\n\r\n\r\nggplot() +\r\n  geom_line(data = dados_todas, col = \"blue\",\r\n            aes(x = Data, y = Vazao)) +\r\n  labs(title = \"Estações - HidroWeb\",\r\n       caption = \"fonte dos dados: ANA (2022)\",\r\n       x = \"Datas\", y = \"Vazão\") +\r\n  facet_wrap(~ Cod_estacao, nrow = 4, scales = \"free_y\")\r\n\r\n\r\n\r\nOutros gráficos\r\ninteressantes\r\n\r\n\r\ndados_60435000$Mes <- as.factor(month(dados_60435000$Data))\r\n\r\nboxplot(data = dados_60435000,\r\n        Vazao ~ Mes,\r\n        main = \"Boxplot da vazão por mês\",\r\n        xlab = \"Mês\",\r\n        ylab = \"Vazão\",\r\n        col = \"orange\",\r\n        border = \"brown\")\r\n\r\n\r\n\r\n\r\n\r\n# Mudar os leveis do Fator mês!\r\nlevels(dados_60435000$Mes)\r\n\r\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\"\r\n\r\nlevels(dados_60435000$Mes) <-\r\n  c(\"Jan\", \"Feb\", \"Mar\", \"Abr\", \"Maio\", \"Jun\",\r\n    \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\")\r\nlevels(dados_60435000$Mes)\r\n\r\n [1] \"Jan\"  \"Feb\"  \"Mar\"  \"Abr\"  \"Maio\" \"Jun\"  \"Jul\"  \"Ago\"  \"Set\" \r\n[10] \"Out\"  \"Nov\"  \"Dez\" \r\n\r\n# Fazer um objeto contendo um ggplot\r\ngrafico_boxplot_1 <-\r\n  ggplot(data = dados_60435000,\r\n         aes(x = Mes, y = Vazao)) +\r\n    geom_boxplot() +\r\n    stat_summary(fun = mean,\r\n                 geom = \"line\",\r\n                 aes(group = 1),\r\n                 col = \"red\")\r\n \r\n# Printar o ggplot na tela do computador\r\ngrafico_boxplot_1\r\n\r\n\r\n\r\nGráficos usando\r\na tabela de resumo estatístico\r\n\r\n\r\nresumo_todas$Cod_estacao <- as.factor(resumo_todas$Cod_estacao)\r\n\r\nggplot(data = resumo_todas,\r\n       aes(x = ano_hidro, y = media, col = Cod_estacao)) +\r\n  geom_ribbon(aes(x = ano_hidro, fill = Cod_estacao,\r\n                  ymax = maxima, ymin = minima),\r\n              alpha = 0.5) +\r\n  geom_line() +\r\n  geom_point() +\r\n  labs(title = \"Estações - HidroWeb\",\r\n       caption = \"fonte dos dados: ANA (2022)\",\r\n       x = \"Ano hidrológico\", y = \"Vazão\",\r\n       fill = \"Estação\", color = \"Estação\")\r\n\r\n\r\n\r\n\r\n\r\nggplot(data = resumo_todas,\r\n       aes(x = ano_hidro, y = media, col = Cod_estacao)) +\r\n  geom_ribbon(aes(x = ano_hidro, fill = Cod_estacao,\r\n                  ymax = maxima, ymin = minima),\r\n              alpha = 0.5) +\r\n  geom_line() +\r\n  geom_point() +\r\n  labs(title = \"Estações - HidroWeb\",\r\n       caption = \"fonte dos dados: ANA (2022)\",\r\n       x = \"Ano hidrológico\", y = \"Vazão\",\r\n       fill = \"Estação\", color = \"Estação\") +\r\n  facet_wrap(~ Cod_estacao, nrow = 4, scales = \"free_y\")\r\n\r\n\r\n\r\nLivros !\r\nLivro do criador do ggplot2:\r\nhttps://ggplot2-book.org/\r\nEntender melhor quais cores\r\nusar:\r\nhttp://www.cookbook-r.com/Graphs/Colors_(ggplot2)/\r\nhttps://eos.org/features/visualizing-science-how-color-determines-whatwesee?utm_source=eos&utm_medium=email&utm_campaign=EosBuzz052920\r\nhttps://eagereyes.org/basics/rainbow-color-map\r\nhttps://ieeexplore.ieee.org/document/4118486\r\nTodas as cores do R:\r\nhttp://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-31T20:32:10-03:00"
    },
    {
      "path": "data_manip.html",
      "title": "Manipulação dos dados",
      "description": "Como organizar as informações para facilitar as análises",
      "author": [],
      "contents": "\r\n\r\nContents\r\nPacotes\r\nPuxar arquivo anterior e\r\nanalisar ele\r\nManipulações básicas nos\r\ndados\r\nDados em\r\nBranco (NA)\r\nAno\r\nhidrológico\r\nTabela\r\nResumo\r\nTabela final\r\n(loop)\r\n\r\n\r\nPacotes\r\nNessa seção vamos usar mecanismos de pacotes já feitos no\r\nR. Existem inúmeros pacotes, cada um com suas funções\r\ne/ou bancos de dados para diferentes assuntos. Eles podem, inclusive,\r\nser apenas um aglomerado de diferentes pacotes para não precisar baixar\r\ntodos um por um. A primeira etapa de utilizar um pacote é a sua\r\ninstalação, isso é feito com o comando install.packages()\r\ncom o nome do pacote estando entre aspas (““) dentro dos parêntesis.\r\nAssim podemos fazer com todos que se encontram no CRAN (repositório que\r\ncontém o que queremos). Na aula de hoje utilizaremos apenas o\r\ntidyverse, que é um agregado de pacotes extremamente\r\npopulares hoje para manipulação e análise de dados.\r\n\r\n\r\ninstall.packages(\"tidyverse\")\r\n\r\n\r\nPara que o R não fique muito pesado, todos os\r\npacotes baixados precisam ser carregados na sua seção do\r\nR - isso é feito com o comando library()\r\ncom o pacote estando detro do parêntesis sem aspas.\r\nPodemos notar que ao carregar o pacote dentro da nossa seção primeiro\r\nvemos quais outros pacotes que foram carregados e suas respectivas\r\nversões. Nesse exemplo, ao carregar o tidyverse, ele\r\ncontém o ggplot2, purrr,\r\ntibble, dplyr, tidyr,\r\nstringr, readr e\r\nforcats. Além disso, aparece uma mensagem mostrando\r\n“conflitos”. Esses conflitos são quando diferentes pacotes utilizam\r\nfunções de mesmo nome (as vezes para fazer coisas diferentes), assim o\r\nR te avisa quais funções são iguais e quais serão as\r\nutilizadas normalmente no programa. É possível usar qualquer função se\r\ndeixarmos explícito de qual pacote queremos (por exemplo\r\nstats::filter())\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n── Attaching packages ───────────────────────────── tidyverse 1.3.1 ──\r\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\r\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\r\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\r\n✔ readr   2.1.2     ✔ forcats 0.5.1\r\n── Conflicts ──────────────────────────────── tidyverse_conflicts() ──\r\n✖ lubridate::as.difftime() masks base::as.difftime()\r\n✖ lubridate::date()        masks base::date()\r\n✖ dplyr::filter()          masks stats::filter()\r\n✖ lubridate::intersect()   masks base::intersect()\r\n✖ dplyr::lag()             masks stats::lag()\r\n✖ lubridate::setdiff()     masks base::setdiff()\r\n✖ lubridate::union()       masks base::union()\r\n\r\nPuxar arquivo anterior e\r\nanalisar ele\r\nPrimeiro vamos baixar apenas uma das estações que fizemos na última\r\naula. Ao final podemos repetir o que foi feito anteriormente e criar um\r\nloop para repetir para as outras 3 estações.\r\n\r\n\r\ndados_ANA <- read.table(file = \"dados/60435000.txt\",\r\n                        sep = \"\\t\",\r\n                        dec = \".\",\r\n                        header = T,\r\n                        fileEncoding = \"UTF-8\")\r\n\r\n\r\nApesar de termos mexido nesses dados na última aula, o\r\nR não sabe disso, ele baixa o arquivo como se fosse um\r\noutro qualquer, assim a coluna da estação é do tipo “inteiro” e a\r\nsegunda coluna (de data) está do tipo “caractere”. Vemos isso abaixo e\r\nem seguida corrigimos ambas para caractere e data, respectivamente.\r\n\r\n\r\nclass(dados_ANA$Cod_estacao)\r\n\r\n[1] \"integer\"\r\n\r\nclass(dados_ANA$Data)\r\n\r\n[1] \"character\"\r\n\r\ndados_ANA$Cod_estacao <- as.character(dados_ANA$Cod_estacao)\r\ndados_ANA$Data <- as.Date(dados_ANA$Data)\r\n\r\n\r\nManipulações básicas nos\r\ndados\r\nAgora que temos um arquivo do jeito que queríamos (diferente do que\r\npegamos diretamente do servidor da ANA), fazer algumas análises podem\r\nser bem fáceis. Se quisermos saber de quando a quando essa estação tem\r\ndados, basta vermos os valores mínimos e máximos da Data.\r\n\r\n\r\nmin(dados_ANA$Data)\r\n\r\n[1] \"1978-05-01\"\r\n\r\n\r\n\r\nmax(dados_ANA$Data)\r\n\r\n[1] \"2021-11-30\"\r\n\r\nSe quisermos saber qual valor mínimo, máximo e médio de vazão podemos\r\ntambém, mas aparece um problema! Nesses valores temos dados em branco,\r\nou NA (Not Available). Dados faltantes sempre são\r\nproblemático e devem ser tratados quando possível. Para algumas funções\r\nnativas, como max(), min() e\r\nmean() temos a opção de apenas ignorar eles com o argumento\r\nna.rm = TRUE, assim os valores máximos, médios e mínimos\r\nsão calculados sem considerar os dados em branco.\r\n\r\n\r\nmax(dados_ANA$Vazao, na.rm = T)\r\n\r\n[1] 37.4633\r\n\r\nmin(dados_ANA$Vazao, na.rm = T)\r\n\r\n[1] 0.0539\r\n\r\nmean(dados_ANA$Vazao, na.rm = T)\r\n\r\n[1] 2.096619\r\n\r\nDados em Branco (NA)\r\nAntes mesmo de começar a fazer essas avaliações é interessante e\r\nimportante entender melhor os dados em branco. Primeiro, quantos\r\nexistem? Para isso podemos usar a função is.na(), vamos\r\nrodar ela apenas para os primeiros 15 dados de vazão para mostrar na\r\ntela.\r\n\r\n\r\nis.na(dados_ANA$Vazao)[1:15]\r\n\r\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\r\n[12] FALSE FALSE FALSE FALSE\r\n\r\nEssa função retorna um dado TRUE ou FALSE\r\npara cada valor avaliado. Como dados lógicos também são\r\nbinários/numéricos (TRUE = 1 e FALSE =\r\n0), podemos somar esses valores para ver quantos dados em\r\nbranco temos no total. Temos então\r\nsum(is.na(dados_ANA[,3])) dados em branco.\r\n\r\n\r\nsum(is.na(dados_ANA$Vazao))\r\n\r\n[1] 87\r\n\r\nPara saber quais as datas que tem o valor de vazão em branco basta\r\naplicarmos esse is.na() na coluna de datas.\r\n\r\n\r\ndados_ANA$Data[is.na(dados_ANA$Vazao)]\r\n\r\n [1] \"1978-05-01\" \"1978-05-02\" \"1978-05-03\" \"1978-05-04\" \"1978-05-05\"\r\n [6] \"1978-05-06\" \"1978-05-07\" \"1978-05-08\" \"1978-05-09\" \"1978-05-10\"\r\n[11] \"1978-05-11\" \"2008-12-01\" \"2008-12-02\" \"2008-12-03\" \"2008-12-04\"\r\n[16] \"2008-12-05\" \"2008-12-06\" \"2008-12-07\" \"2008-12-08\" \"2008-12-09\"\r\n[21] \"2008-12-10\" \"2008-12-11\" \"2008-12-12\" \"2008-12-13\" \"2008-12-14\"\r\n[26] \"2008-12-15\" \"2008-12-16\" \"2008-12-17\" \"2008-12-18\" \"2008-12-19\"\r\n[31] \"2008-12-20\" \"2008-12-21\" \"2008-12-22\" \"2008-12-23\" \"2008-12-25\"\r\n[36] \"2008-12-26\" \"2008-12-27\" \"2008-12-28\" \"2008-12-29\" \"2008-12-30\"\r\n[41] \"2008-12-31\" \"2009-01-01\" \"2009-01-02\" \"2009-01-03\" \"2009-01-04\"\r\n[46] \"2009-01-05\" \"2009-01-06\" \"2009-01-07\" \"2009-01-08\" \"2009-01-09\"\r\n[51] \"2009-01-10\" \"2009-01-11\" \"2009-01-12\" \"2009-01-13\" \"2009-01-14\"\r\n[56] \"2009-01-15\" \"2019-08-01\" \"2019-08-02\" \"2019-08-03\" \"2019-08-04\"\r\n[61] \"2019-08-05\" \"2019-08-06\" \"2019-08-07\" \"2019-08-08\" \"2019-08-09\"\r\n[66] \"2019-08-10\" \"2019-08-11\" \"2019-08-12\" \"2019-08-13\" \"2019-08-14\"\r\n[71] \"2019-08-15\" \"2019-08-16\" \"2019-08-17\" \"2019-08-18\" \"2019-08-19\"\r\n[76] \"2019-08-20\" \"2019-08-21\" \"2019-08-22\" \"2019-08-23\" \"2019-08-24\"\r\n[81] \"2019-08-25\" \"2019-08-26\" \"2019-08-27\" \"2019-08-28\" \"2019-08-29\"\r\n[86] \"2019-08-30\" \"2019-08-31\"\r\n\r\nE se quiser o último (a última data com vazão em branco), podemos\r\nfazer o max() dessas datas todas.\r\n\r\n\r\nmax(dados_ANA$Data[is.na(dados_ANA$Vazao)])\r\n\r\n[1] \"2019-08-31\"\r\n\r\nO que fazer com cada dado em branco vai depender do que se quer com\r\nos dados. Como completar essas falhas é uma temática extremamente\r\nrelevante e difícil de responder até mesmo hoje. Pararemos por hora de\r\nfalar desses valores, e não entraremos muito a fundo sobre o que fazer\r\ncom eles (até porque depende do que se quer fazer) nesse curso.\r\nAno hidrológico\r\nEm hidrologia estatística, é muito comum utilizarmos o ano\r\nhidrológico ao invés do calendário “normal” (janeiro a dezembro) para\r\nfazer análises estatísticas. Onde começa o ano hidrológico também não é\r\ntão simples, mas a via de regra é: entre as secas e cheias.\r\nFaremos aqui uma função para transformar nossa data em ano\r\nhidrológico, assim conseguiremos fazer algumas análises anuais\r\ninteressantes. A função, chamada aqui de fun_ano_hidro()\r\ntomará 2 argumentos: um sendo as datas que queremos transformar e o\r\noutro em que mês que se inicia o ano hidrológico, aqui deixamos\r\npré-definido como 8, mas se quiser mudar isso, basta alterar o argumento\r\nna hora de chamar ela (assim não ficamos preso a esse número)! Primeiro\r\ndevemos garantir que as datas estão no formato certo, portanto fazemos\r\nessa transformação no começo da função. Em seguida definimos qual será o\r\nano hidrológico. O que fazemos é avaliar se o mês em questão é menor ou\r\nmaior do que o começo do ano hidrológico definido pela função. Se for\r\nmaior, significa que já entramos em outro ano hidrológico, portanto o\r\nano em questão é o seguinte (o mês 8, Agosto, de 2000 entra para o ano\r\nhidrológico de 2001 e assim por diante).\r\n\r\n\r\nfun_ano_hidro <- function(datas,\r\n                          comeco_ano_hidro = 8){\r\n \r\n  # Se não tiver no formato de datas, fazer essa correção\r\n  datas <- as.Date(datas)\r\n  \r\n  # Se vai pular (deslocar) um ano ou não\r\n  desloc_ano <- ifelse(month(datas) < comeco_ano_hidro, 0, 1)\r\n  \r\n  # Ano Hidro\r\n  ano_hidro <- year(datas) + desloc_ano\r\n  \r\n  return(ano_hidro)\r\n}\r\n\r\n\r\nAbaixo testamos ela fazendo uma nova coluna no nosso\r\ndataframe.\r\n\r\n\r\ndados_ANA$ano_hidro <- fun_ano_hidro(dados_ANA$Data)\r\n\r\nhead(dados_ANA)\r\n\r\n  Cod_estacao       Data Vazao ano_hidro\r\n1    60435000 1978-05-01    NA      1978\r\n2    60435000 1978-05-02    NA      1978\r\n3    60435000 1978-05-03    NA      1978\r\n4    60435000 1978-05-04    NA      1978\r\n5    60435000 1978-05-05    NA      1978\r\n6    60435000 1978-05-06    NA      1978\r\n\r\nTabela Resumo\r\nAqui introduzimos um novo conceito do pacote\r\nmagrittr (ele está internamente no\r\ntiyverse). Esse conceito se chama pipe\r\noperator e é dado pelo símbolo %>%. Basicamente\r\no que ele faz é tomar o que está na esquerda dele, e usar como argumento\r\nda função a direita. Assim ao invés de escrever as funções umas dentro\r\ndas outras, podemos deixar o código mais limpo e fácil de entender. Olhe\r\no exemplo abaixo. Nele estamos tirando o log das vazões, com a função\r\nlog(), depois calculando as diferenças desse log em um\r\npasso de tempo com diff(), calculamos o exponencial disso\r\ncom exp(), em seguimas calculamos a média desses valores e\r\ndepois arredondamos isso para ter apenas 2 casas decimais.\r\n\r\n\r\nround(mean(exp(diff(log(dados_ANA$Vazao))), na.rm = T), 2)\r\n\r\n[1] 1.03\r\n\r\nÉ fácil se perder lendo isso pois no R normalmente\r\nlemos de dentro para fora das funções (e portanto da direita para a\r\nesquerda) e é mais fácil ainda confundir qual argumento entra em qual\r\nfunção. Usando o pipe operator, dado por\r\n%>%, o código fica mais facilmente interpretável.\r\nSelecionamos a vazão e em seguida tiramos o log, depois a diferença,\r\ndepois o expoente… Quando uma função tem diversos argumentos podemos\r\nescrever explicitamente onde que o objeto a esquerda do pipe\r\nvai entrar colocando um ponto no lugar dele, não precisando que ele\r\nsempre entre no primeiro argumento da função.\r\n\r\n\r\ndados_ANA$Vazao %>%\r\n  log() %>%\r\n  diff() %>%\r\n  exp() %>%\r\n  mean(., na.rm = T) %>%\r\n  round(digits = 2, x = .)\r\n\r\n[1] 1.03\r\n\r\nAgora que temos o ano hidrológico para cada data, podemos fazer a\r\nnossa série de máximos, mínimos e médias anuais a partir dos dados\r\ndiários. Primeiro cria-se um dataframe vazio com as colunas\r\npara cada ano, uma coluna para os máximos, outra para os mínimos e outra\r\npara as médias anuais. Podemos também criar uma quarta coluna para o\r\nnúmero de valores NA nesse período.\r\nJá iremos fazer isso no formato de função, para que possamos replicar\r\npara as outras estações também! A função tomará como argumento a tabela\r\noriginal de dados (dados_ANA), e irá rodar a função\r\nfun_ano_hidro() internamente. Assim teremos uma nova coluna\r\ncriada com a função mutate(). Em seguida agrupamos os dados\r\npor estação (se tivesse mais de uma por exemplo) e por ano hidrológico\r\nusando o group_by e falamos o que faremos ao juntar esses\r\ndados com o summarise(). Um problema é se o ano hidrológico\r\nestiver todo com falha, nesses casos as funções usadas retornarão\r\nInf (infinito), -Inf ou NaN\r\n(Not a Number), portanto depois de agruparmos, iremos trocar\r\nqualquer valor não-finito na tabela por NA.\r\nRodar uma outra função internamente requer alguns cuidados. Por\r\nexemplo, aqui assumimos que a tabela virá com uma coluna chamada “Data”.\r\nCaso isso não aconteca a nossa função não irá funcionar.\r\n\r\n\r\nfun_resumo_ano <- function(dados_hidro){\r\n  \r\n  tabela_resumo <-\r\n    dados_hidro %>%\r\n    mutate(ano_hidro = fun_ano_hidro(Data)) %>%\r\n    group_by(Cod_estacao, ano_hidro) %>%\r\n    summarise(maxima = max(Vazao, na.rm = T),\r\n              minima = min(Vazao, na.rm = T),\r\n              media = mean(Vazao, na.rm = T),\r\n              NAs = sum(is.na(Vazao)))\r\n  \r\n  tabela_resumo[!is.finite(tabela_resumo$maxima), c(3, 4, 5)] <- NA\r\n  \r\n  return(tabela_resumo)\r\n}\r\n\r\n\r\nTabela final (loop)\r\nAgora podemos aplicar essa função diretamente aos\r\ndados_ANA da última aula. Na realidade, podemos fazer um\r\nloop para abrir cada uma das 4 estações, rodar essa função e\r\njuntar essas tabelas em uma só com a função rbind() - essa\r\nfunção junta diferentes dataframes pelas mesmas colunas,\r\ncolocando um embaixo do outro. Abaixo rodamos o loop de outra\r\nmaneira, definindo antes quais os códigos das estações e rodando o\r\nfor() variando de 1 a 4. Primeiro lemos a primeira estação\r\ne, se for a primeira iteração, salvamos ela em um objeto chamado\r\ntabela_final. Se não for a primeira iteração, juntamos elas com\r\no rbind().\r\n\r\n\r\nestacoes_cod <- c(60435000, 60436000, 60436190, 60443000)\r\n\r\nfor(i in 1:4){\r\n  dados_proxy <- read.table(file = paste0(\"dados/\", estacoes_cod[i],\".txt\"),\r\n                            sep = \"\\t\",\r\n                            dec = \".\",\r\n                            header = T,\r\n                            fileEncoding = \"UTF-8\")\r\n  \r\n  dados_proxy <- fun_resumo_ano(dados_proxy)\r\n  \r\n  if(i == 1) tabela_final <- dados_proxy\r\n  if(i != 1) tabela_final <- rbind(tabela_final, dados_proxy)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-23T15:39:10-03:00"
    },
    {
      "path": "frequency_analysis.html",
      "title": "Análise de frequência de cheias",
      "description": "Exemplo de análise local com dados reais",
      "author": [],
      "contents": "\r\n\r\nContents\r\nObjetivos da atividade\r\nSeleção das vazões máximas\r\nanuais\r\nObtenção da série de vazões\r\ndiárias\r\nExtração da série de\r\nvazões máximas anuais\r\nVisualização da série\r\nde máximos anuais\r\n\r\nConstrução da curva\r\nde frequência amostral\r\nPosição\r\nde plotagem\r\nPlotagem da amostra na\r\nFigura\r\n\r\nAjuste de\r\numa distribuição teórica de probabilidades\r\nA distribuição lognormal\r\nQuantis de cheia da\r\nlognormal\r\nMétodo de\r\najuste\r\nAjuste da\r\nlognormal e estimativa dos quantis\r\n\r\nDescrição das incertezas\r\nLógica\r\nda construção de intervalos de confiança aproximados\r\nEstimadores\r\nintervalares para \\(Y_p\\) e \\(Q_p\\)\r\n\r\nPlotagem final da curva\r\nde frequência\r\n\r\nObjetivos da atividade\r\nO objetivo desta atividade é realizar uma análise de frequência de\r\ncheias a nível local. Isso significa que iremos relacionar a magnitude\r\ndas vazões máximas anuais com a probabilidade da mesma ser excedida. A\r\nanálise a nível local siginifca que utilizaremos apenas as informações\r\nde vazão observadas na estação fluviométrica de interesse, sem fazer uso\r\nde informações sobre as vazões máximas anuais que teham acontecido em\r\noutras estações fluviométricas localizadas na região.\r\nAlém de construirmos a relação entre a magnitude das vazões máximas\r\nanuais e a respectiva probabilidade de excedência, é importante saber\r\nestimar também o grau de incerteza nessas estimativas. Essas incertezas\r\nsão usualmente representadas por intervalos de confiança, como veremos\r\nmais adianate.\r\nAlém de calcular essas quantidades, a curva de frequência, e suas\r\nrespectivas incertezas, são representadas graficamente, como na figura\r\nabaixo, que mostra os resultados para um estudo de cheias numa seção do\r\nRio Salado, localizada na província de Santa Fé, na Argentina, onde em\r\n2003 ocorreu o rompimento de um dique que resultou em perde de vidas\r\nhumanas e elevados prejuízos. Nesse caso, utilizou-se a distribuição\r\nGeneralizada de Valores Extremos (GEV), mas aqui no curso faremos uso de\r\numa distribuição mais simples de se trabalhar, a lognormal. O objetivo\r\naqui é ter uma motivação hidrológica para apreder a usar a linguagem\r\nR.\r\nContruiremos aqui no curso uma figura semelhante a esta, onde no\r\neixo-x temos o tempo de recorrência e no eixo-y a magnitude das vazões\r\nmáximas anuais. O tempo de recorrência apresentado no eixo-x é uma\r\nmaneira de representar a probabilidade de excedência. A linha cheia em\r\nvermelho representa o valor esperado dos valores da vazão máxima anual\r\nem função do tempo de recorrência, enquanto as linhas tracejadas\r\nrepresentam os intervalos de confiança de 95%, ilustrando as incertezas\r\nenvolvidas nessas estimativas. Os círculos azuis escuros representam as\r\nvazões máximas anuais registradas no passado, enquanto o círculo azul\r\nclaro mostra a cheia destruidora de 2003.\r\n\r\n\r\n\r\n(#fig:curva_freq)Curva de frequência do cheias do Rio Salado, na\r\nArgentina.\r\n\r\n\r\n\r\nSeleção das vazões máximas\r\nanuais\r\nO primeiro passo de nossa atividade consiste em obter a série de\r\nmáximos anuais que desejamos analisar. A obtenção da série de máximos\r\nanuais será realizada em duas etapas. Primeiro vamos obter a séries de\r\nvazões diárias, e para isso utilizaremos a mesma função de obtenção de\r\nséries diárias de vazão que aprendemos na segunda aula deste curso. Com\r\na série de vazões diárias em mãos, passaremos para a segunda etapa, que\r\né a de extrair a vazão máxima de cada ano hidrológico.\r\nObtenção da série de vazões\r\ndiárias\r\nA função abaixo permite obter a série de vazões diárias de uma\r\nestação fluviométrica. O único argumento desta função é o código da\r\nestação. Quando chamamos esta função, ela retorna um dataframe com 3\r\ncolunas: o código da estação, a data, e o valor da vazão diária.\r\nComo já estudamos esta função anteriormente, a uitlizaremos aqui sem\r\nentrar em qualqer detalhes sobre seu funcionamento.\r\n\r\n\r\n# Função para obter série histórica de vazão de uma determinada estação ####\r\ndados_serie_ANA <- function(cod_estacao = NA,\r\n                            data_inicio = \"01/01/1800\",\r\n                            data_fim = Sys.Date(),\r\n                            tipo_dados = 3,\r\n                            nivel_consist = 1){\r\n  \r\n  # Pegar dados a partir do url e transformar em um dataframe\r\n  url_base <-\r\n    paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/\",\r\n           \"HidroSerieHistorica?\",\r\n           \"codEstacao=\", cod_estacao,\r\n           \"&dataInicio=\", data_inicio,\r\n           \"&dataFim=\", data_fim,\r\n           \"&tipoDados=\", tipo_dados,\r\n           \"&nivelConsistencia=\", nivel_consist)\r\n  \r\n  url_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n  node_doc <- XML::getNodeSet(url_parse, \"//SerieHistorica\")\r\n  dados_estacao <- XML::xmlToDataFrame(nodes = node_doc)\r\n  \r\n  # Por algum motivo o hidroweb não está filtrando os dados pela consistencia\r\n  dados_estacao <- filter(dados_estacao, NivelConsistencia == nivel_consist)\r\n  \r\n  # Separar data e hora\r\n  dados_estacao$Data <- as.Date(substr(dados_estacao$DataHora, 1, 10))\r\n  dados_estacao$Hora <- substr(dados_estacao$DataHora, 12, 19)\r\n  \r\n  # Fazer um dataframe só com datas e valores de vazão\r\n  datas_dia <- seq.Date(from = min(dados_estacao$Data),\r\n                        to = max(dados_estacao$Data) %m+% months(1) - 1,\r\n                        by = \"day\")\r\n  \r\n  tabela_final <- data.frame(Cod_estacao = dados_estacao$EstacaoCodigo[1],\r\n                             Data = as.character(datas_dia),\r\n                             Vazao = as.numeric(NA))\r\n  \r\n  \r\n  for(i in 1:nrow(tabela_final)){\r\n    # Dia em análise\r\n    dia <- as.numeric(substr(tabela_final$Data[i], 9, 10))\r\n    \r\n    # Mês e ano em análise\r\n    mes_ano <- as.Date(paste0(substr(tabela_final$Data[i], 1, 8), \"01\"))\r\n    \r\n    # Olhar a linha do mes e ano e escolher a coluna pelo dia + 15\r\n    linha_dado <- which(dados_estacao$Data == mes_ano)\r\n    \r\n    # Se não tiver o mês nos dados da estação, colocar valor NA\r\n    ifelse(length(linha_dado) == 0,\r\n           tabela_final$Vazao[i] <- NA,\r\n           tabela_final$Vazao[i] <-\r\n             as.numeric(dados_estacao[linha_dado, (dia + 15)]))\r\n    \r\n  }\r\n  \r\n  return(tabela_final)\r\n}\r\n\r\n\r\nPrecisamos escolher uma estação fluviométrica para realizar nossa\r\nanálise. Sugiro utilizar a estação 60435000, localizada\r\nna bacia do Rio Descoberto, que drena uma área de 113.2 km\\(^2\\), mas vocês têm a indepedência de\r\nescolhar qualquer outras estação que esteja no banco de dados da Agência\r\nNacional de Águas.\r\nPara obter a série diária da estação escolhida, basta chamar a função\r\nacima passando o argumento necessário, que é simplesmente o código da\r\nestação desejada. A função devolve um dataframe com a série de vazões\r\nmédias diárias.\r\nPara fins de visualização, utilizamos a função\r\nhead(nome_do_dataframe) do R, como mostrado abaixo, que nos\r\nmostra as primeiras 6 linhas do dataframe.\r\n\r\n\r\ndados_60435000 <- dados_serie_ANA(cod_estacao = 60435000)\r\nindex_falha_diario <- which(is.na(dados_60435000[,3]==TRUE))\r\ndias_falha <- dados_60435000[index_falha_diario,2:3]\r\nhead(dados_60435000)\r\n\r\n  Cod_estacao       Data Vazao\r\n1    60435000 1978-05-01    NA\r\n2    60435000 1978-05-02    NA\r\n3    60435000 1978-05-03    NA\r\n4    60435000 1978-05-04    NA\r\n5    60435000 1978-05-05    NA\r\n6    60435000 1978-05-06    NA\r\n\r\nAlém disso, é sempre importante visualizar os dados para que se teha\r\numa ideia geral da faixa de variação das vazões, sazonalidade e outras\r\npadrões que possa ser percebidos num gráfico.\r\nAqui, nós plotaremos a série completa das vazões diárias da estação\r\n60435000 utilizando o código abaixo, que emprega o\r\nchamado R-base, ao invés de pacote ggplot2, visto na aula\r\nanterior. Mas se preferir utilizar o ggplot2 para realizar\r\nesta plotagem, fique à vontade.\r\n\r\n\r\ntime <- as.Date(dados_60435000$Data)\r\nplot(time,dados_60435000$Vazao,type=\"l\",\r\n     main = \"Vazões diárias - estação 60435000\",\r\n     xlab = \"Anos\",ylab = \"Q (m3/s)\")\r\n# Adiciona grid horizontal apenas\r\ngrid(nx = NA, ny = NULL,\r\n     lty = 2,      # Grid line type\r\n     col = \"gray\", # Grid line color\r\n     lwd = 2)      # Grid line width\r\n\r\n\r\n\r\nExtração da série de\r\nvazões máximas anuais\r\nCom a série de vazões diárias, passamos ao segundo passo que é o de\r\nconstruir a série de máximos anuais com base no ano hidrológico. Para\r\nisso, utilizaremos uma outra função, que é apresentada abaixo. Veja que\r\na função tem como default o ano hidrológico com início no mês\r\nde agosto. Mas o mês de início do ano hidrológico pode ser facilmente\r\nalterado, bastando aicionar esse argumento quando chamar a função.\r\n\r\n\r\n# Contrução da série de máximos anuais a partir de um ano hidrológico ####\r\nfun_max_ano <- function(tabela = NA,\r\n                        comeco_ano_hidro = 8){\r\n  \r\n  # Transformar a coluna Data em \"Dates\" (caso esteja em character)\r\n  tabela$Data <- as.Date(tabela$Data)\r\n  \r\n  # Definir se o mês em questão entra no ano atual ou no próximo ano\r\n  desloc_ano <- ifelse(month(tabela$Data) < comeco_ano_hidro, 0, 1)\r\n  \r\n  # Ano Hidro\r\n  tabela$ano_hidro <- year(tabela$Data) + desloc_ano\r\n  \r\n  # Fazer uma tabela final apenas com os máximos anuais\r\n  max_anuais <-\r\n    tabela %>%\r\n    group_by(Cod_estacao, ano_hidro) %>%\r\n    summarise(maxima = max(Vazao))\r\n}\r\n\r\n\r\nPara finalmente obtermos a série de máximos anuais, basta chamar a\r\nfunção fornecendo o arquivo que contém as séries diárias de vazão, que\r\nno nosso caso é o dados_60435000. Mais uma vez, podemos\r\nutilizar a função head para dar uma leve espiada nas\r\ninformoações contidas no dataframe.\r\n\r\n\r\nQ_max <- fun_max_ano(dados_60435000)\r\nhead(Q_max)\r\n\r\n# A tibble: 6 × 3\r\n# Groups:   Cod_estacao [1]\r\n  Cod_estacao ano_hidro maxima\r\n  <chr>           <dbl>  <dbl>\r\n1 60435000         1978   NA  \r\n2 60435000         1979   16.1\r\n3 60435000         1980   28.9\r\n4 60435000         1981   11.1\r\n5 60435000         1982   12.8\r\n6 60435000         1983   25.3\r\n\r\nA função fun_max_ano foi escrita de forma que qualquer\r\nfalha na série de vazões diárias num dado ano hidrológico resulta numa\r\nfalha na série de máximos anuais. Isso nem semrpe é necessário, já que\r\nfalhas no período de estiagem não indicam falhas nas séries de máximos,\r\nmas creio que a função nos serve bem para este curso.\r\nPodemos notar a presença de um NA na nossa plotagem\r\nacima. É interessante verificar o número total de anos disponíveis com\r\ndados diários de vazão, bem como o número de anos com falha na série de\r\nmáximos anuais.\r\nO número de anos com dados de vazões diárias pode ser obtidos\r\nsimplemente identificando o número de linhas no dataframe\r\nQ_max, e para isso utilizamos o código abaixo,\r\n\r\n\r\nn_anos <- nrow(Q_max)\r\nn_anos\r\n\r\n[1] 45\r\n\r\nMas já sabemos que o ano de 1978 não contém o valor de vazão máxima\r\nporque a série de vazões diárias não estava completa. Será que há outros\r\nanos no histórico com esse problema? Para identificar se há falha em\r\noutros anos, utilizaremos duas funções do R de forma\r\nconjunta, is.na e which. A função\r\nis.na identifica se o elemento é um NA ou não,\r\nretornando um valor lógico, TRUE ou FALSE,\r\nenquanto a função which permite identificar a posição de\r\numa dada condição. O código abaixo permite identificar em quais anos\r\nocorrem falhas na série de máximos anuais,\r\n\r\n\r\nindex <- which(is.na(Q_max[,3]==TRUE))\r\nanos_falha <- Q_max[index,2:3]\r\nanos_falha\r\n\r\n# A tibble: 3 × 2\r\n  ano_hidro maxima\r\n      <dbl>  <dbl>\r\n1      1978     NA\r\n2      2009     NA\r\n3      2020     NA\r\n\r\nA primeira linha de código identifica as posições em que há a\r\npresença de NA na terceira coluna do dataframe, que é a\r\ncoluna com as informações sobre as vazões máximas de cada ano\r\nhidrológico, e associa à variável index. Na linha seguinte,\r\ncriamos um novo dataframe com a informação dos anos em que temos falhas\r\nnos dados.\r\nÉ verdade que poderíamos ter escrito o código acima de uma forma mais\r\ncompacta, porém ficaria mais difícil de entender. Veja o que você\r\nacha.\r\n\r\n\r\nanos_falha <- Q_max[which(is.na(Q_max[,3]==TRUE)),2:3]\r\nanos_falha\r\n\r\n# A tibble: 3 × 2\r\n  ano_hidro maxima\r\n      <dbl>  <dbl>\r\n1      1978     NA\r\n2      2009     NA\r\n3      2020     NA\r\n\r\nMais à frente, quando tivermos que fazer os cálculos necessários para\r\nrealizar a análise de frequência, teremos que nos livrar desses anos com\r\nfalhas. Mas por enquanto, vamos deixá-los como estão, e passemos `a\r\netapa seguinte que é a de visualizar a série de máximos anuais.\r\nVisualização da série\r\nde máximos anuais\r\nAgora já podemos visualizar a série de máximos anuais que serivirão\r\nde base para a nossa análise de frequência. Essa visualização pode ser\r\nfeita com o código abaixo, que utiliza apenas o R-base.\r\nMais uma vex, se desejar utilizar o ggplot2 para essa\r\nplotagem, fique à vontade.\r\n\r\n\r\nplot(Q_max$ano_hidro,Q_max$maxima,type = \"o\",\r\n     main = \"Máximos anuais - 60435000\",\r\n     xlab = \"Anos\",ylab = \"Q_max (m3/s)\",lwd = 2)\r\n# Adiciona grid\r\ngrid(nx = NULL, ny = NULL,\r\n     lty = 2,      # Grid line type\r\n     col = \"gray\", # Grid line color\r\n     lwd = 1)      # Grid line width\r\n\r\n\r\n\r\nConstrução da curva\r\nde frequência amostral\r\nPosição de plotagem\r\nPara que possamos plotar os círculos azuis escuros da Figura\r\napresentada anteriormente, para o caso do Rio Salado, que representam as\r\nvazões máximas anuais observadas na série histórica, precisamos\r\ndeterminar as chamadas posição de plotagem, que servirão de base para o\r\ncálculo do tempo de recorrência empírico para cada valor de vazão da\r\namostra.\r\nPara que seja possível entender esta etapa, vale a pena investir um\r\ncerto tempo do curso em alguns conceitos básicos.\r\nO tempo de recorrência associado a uma determinada magnitude de\r\nvazão, \\(T_r(q)\\), é um conceito\r\nhidrológico bastante conhecido, de forma que não dedicaremos muito tempo\r\npara discutí-lo aqui. Por definição, o tempo de recorrência de um\r\nevento, cuja magnitude vale \\(q\\), é\r\nigual ao inverso da probabilidade da vazão máxima anual exceder esse\r\nvalor,\r\n\\[T_r(q) =\r\n\\frac{1}{P(Q>q)}\\]\r\nPor exemplo, se a probabilidade da vazão máxima anual ultrapassar um\r\ndado valor \\(q\\) for igual a 0.10,\r\ndizemos que o tempo de recorrência dessa vazão \\(q\\) é de 10 anos. Da mesma forma, se \\(P(Q>q)=0.01\\), dizemos que o tempo de\r\nrecorrência de \\(q\\) vale 100 anos.\r\nPortanto, para que possamos incluir as vazões observadas na nossa\r\ncurva de frequência, será preciso determinar a probabilidade de\r\nexcedência de cada uma das observações contidas na série de vazões\r\nmáximas anuais da localidade de interesse. Como o intuito neste primeiro\r\nmomento é plotar as vazões observadas na curva de frequência, nos\r\nbasearemos na chamada distribuição empírica de frequência.\r\nA distribuição empírica de frequência relaciona cada valor de vazão\r\nmáxima observada na série histórica, denominada aqui de \\(q_i\\), com sua frequência relativa\r\nacumulada, \\(\\hat{F}_Q(q_i)\\). A\r\nquantidade \\(\\hat{F}_Q(q_i)\\)\r\nrepresenta a nossa estimativa para a probabilidade da variável de\r\ninteresse, \\(Q\\), ser menor ou igual ao\r\nvalor amostral, \\(q_i\\),\r\n\\[\\hat{F}_Q(q_i) = \\hat{P}(Q \\le\r\nq_i)\\]\r\nem que \\(\\hat{F}_Q\\) é a estimativa\r\nda frequência relativa acumulada da variável aleatória \\(Q\\) baseada na amostra, enquanto \\(q_i\\) representa o valor de uma dada\r\nobservação \\(i\\). O uso do acento\r\ncircunflexo na equação acima é uma convenção utilizada em estatística\r\npara mostrar que estamos nos referindo a uma estimativa da grandeza em\r\nquestão baseada na amostra que se tem em mãos.\r\nJá dissemos acima que o tempo de recorrência \\(T_r(q)\\) é função da probabilidade de\r\nexcedência, que por sua vez pode ser interpretada como o complemento de\r\n\\(F_Q(q_i)\\). Dessa forma, podemos\r\ndizer que\r\n\\[\\hat{P}(Q \\gt q_i) = 1 - \\hat{P}(Q \\le\r\nq_i)\\] de forma que\r\n\\[\\hat{T}_r(q_i) = \\frac{1}{1-\\hat{P}(Q\r\n\\le q_i)}\\]\r\nPode parecer estranho se você estiver vendo isso pela primeira vez,\r\nmas a verdade é que há diferentes maneiras de se estimar a distribuição\r\nempírica de frequência das observações de uma amostra, \\(\\hat{P}(Q\\le q_i)\\), ou seu complemento,\r\n\\(\\hat{P}(Q\\gt q_i)\\).\r\nUma maneira bem comum de estimar tais probabilidades, quando se tem\r\numa amostra de tamanho \\(n\\), consiste\r\nem ordenar a série em ordem decrescente e determinar a probabilidade de\r\nexcedência utilizando a seguinte fórmula,\r\n\\[\\hat{P}(Q > q_{(i)}) = 1 -\r\n\\hat{F}_Q(q_{(i)}) = \\frac{i}{n+1}\\]\r\nem que \\(q_{(i)}\\) representa a\r\nchamada estatística de ordem \\(i\\), em\r\nque \\(q_{(1)}\\gt q_{(2)}\\gt \\ldots \\gt\r\nq_{(n)}\\) representa a série ordenada das vazões máximas anuais,\r\nde forma que \\(q_{(1)}\\) e \\(q_{(n)}\\) são, respectivamente, a maior e a\r\nmenor observações da amostra. De acordo com essa expressão, por exemplo,\r\nnuma amostra de tamanho 49, a probabilidade da vazão máxima anual ser\r\nmaior do que a maior observação da amostra vale \\(P(Q>q_{(1)})=0.02\\)), o que resulta num\r\ntempo de recorrência de \\(T_r(q_{(1)})=50\\) anos.\r\nNão se preocupe tanto se esse conceito de posição de plotagem não\r\nficou totalmente claro. Basta saber que plotaremos os valores de máximos\r\nanuais da amostra na curva de frequência utilizando a posição de\r\nplotagem de Weibull, que é o nome que se dá à posição de plotagem \\(i/(n+1)\\).\r\nPlotagem da amostra na\r\nFigura\r\nNa verdade, utilizaremos o tempo de recorrência, \\(T_r\\), para plotagem, lembrando que o \\(T_r\\) é simplemenste o inverso da\r\nprobabilidade de excedência, representada pela posição de plotagem de\r\nWeibull.\r\nO código para o cálculo do \\(Tr\\) é\r\napresentado abaixo. Para facilitar a compreenção de como o cálculo é\r\nfeito, criaram-se três novas colunas ao dataframe que contém as vazões\r\nmáximas anuais. Mas antes disso, efetuou-se o ordenamento das vazões\r\nmáximas em ordem decrescente, ou seja, o primeiro valor de vazão da nova\r\nsérie ordenada é o maior da amostra.\r\nAs três novas colunas são, respectivamente, o índice das vazões,\r\ncomeçando de 1 indo até o número total de valores, a posição de plotagem\r\nde Weilbull, que expressa a probabilidade de excedência, e por último o\r\ntempo de recorrência, \\(Tr\\).\r\n\r\n\r\n# Remoção dos anos com falha\r\nQ_max <- na.omit(Q_max)\r\n# Ordenamento decrescente do dataframe\r\nQ_max_ord <- Q_max[order(Q_max$maxima, decreasing = TRUE), ]\r\n# Inclusão de Três novas colunas: index, posição de plotagem de Weibull, e Tr\r\nQ_max_ord$index <- seq(from = 1,to = nrow(Q_max_ord))\r\nQ_max_ord$weibull <- Q_max_ord$index/(nrow(Q_max_ord) + 1)\r\nQ_max_ord$Tr <- 1/Q_max_ord$weibull\r\n\r\n\r\nComo já fizemos antes, podemos dar uma espiada nesse novo dataframe\r\ncom as vazões máximas anuais ordenada utilizando a função\r\nhead(dataframe_name),\r\n\r\n\r\nhead(Q_max_ord)\r\n\r\n# A tibble: 6 × 6\r\n# Groups:   Cod_estacao [1]\r\n  Cod_estacao ano_hidro maxima index weibull    Tr\r\n  <chr>           <dbl>  <dbl> <int>   <dbl> <dbl>\r\n1 60435000         2004   37.5     1  0.0233 43   \r\n2 60435000         1980   28.9     2  0.0465 21.5 \r\n3 60435000         1983   25.3     3  0.0698 14.3 \r\n4 60435000         1994   19.3     4  0.0930 10.8 \r\n5 60435000         2016   17.8     5  0.116   8.6 \r\n6 60435000         1988   17.1     6  0.140   7.17\r\n\r\nA última coluna de Q_max_ord contém o valor do tempo de\r\nrecorrência de cada uma das observações contidas na amostra. Vale notar\r\nque as observações em Q_max_ord estão ordenadas em ordem\r\ndecrescente.\r\nPodemos agora criar uma Figura, similar àquela apresentada para o\r\nestudo do Rio Salado. Porém, nesta etapa de nossa análise, apenas os\r\nvalores amostrais das vazões máximas serão apresentados.\r\n\r\n\r\nplot(Q_max_ord$Tr,Q_max_ord$maxima,type = \"p\", pch = 19,cex = 1.5,col = \"blue\",\r\n     log = \"x\",main = \"Curva de frequência de cheias - 60435000\",\r\n     xlab = \"Tr (anos)\",ylab = \"Q_max (m3/s)\",\r\n     xlim = c(1, 100),   # X-axis limits\r\n     ylim = c(1, 50))\r\n# Adiciona grid horizontal\r\naxis(1, at = c(seq(1,10,by=1),seq(10,100,by=10),seq(200,1000,by=100)),\r\n     tck = 1, lty = 2, col = \"gray\")\r\n# Adiciona grid vertical\r\naxis(2, tck = 1, lty = 2, col = \"gray\")\r\n\r\n\r\n\r\nAjuste de\r\numa distribuição teórica de probabilidades\r\nEstudos que realizam de análise de frequência de cheias geralmente\r\nutilizam as seguintes distribuições teóricas de probabilidade:\r\nLognormal de 2 parâmetros (LN2)\r\nLognormal de 3 parâmetros (LN3)\r\nGeneralizada de Valoes Extremos (GEV)\r\nLog-Pearson Tipo 3 (LP3).\r\nComo o intuito aqui não é o de se aprofundar nos detalhes técnicos de\r\nanálise de frequência, o que exigiria um número muito maior de horas de\r\naula, mas de ter uma motivação maior para aprender a linguagem\r\nR, vamos realizar nossa análise de frequência de cheias\r\ncom a distribuição lognormal de 2 parâmetros, que é bastante simples de\r\ntratar.\r\nA distribuição lognormal\r\nSe considerarmos que as vazões máximas anuais \\((Q)\\) possuem uma distribuição lognormal,\r\nentão os logaritmos de \\(Q\\), chamados\r\naqui de \\(Y = ln(Q)\\), terão, por\r\ndefinição, uma distribuição normal,\r\n\\[\r\nY = ln(Q) \\sim N(\\mu_Y,\\sigma_Y^2)\r\n\\] o que significa dizer que os logarítmicos das vazões máximas\r\nanuais são bem representados por uma distribuição Normal com parâmetros\r\n\\(\\mu_Y\\) e \\(\\sigma_Y^2\\), que, para quem não lembra,\r\nrepresentam a média e a variância populacionais.\r\nO adjetivo populacional utilizado aqui é para lembrarmos que essas\r\ncaracerísticas da distribuição são, na verdade, desconhecidas. A única\r\npista que temos sobre o valor desses parâmetros está contida na amostra\r\nque temos, formada por um conjunto de vazões máximas anuais. A maneira\r\nque utilizaremos a amostra para tentar compreender essa distribuição é o\r\nassunto da seção Método de ajuste.\r\nQuantis de cheia da\r\nlognormal\r\nÉ muito provável que vocês não se recordem, mas a distribuição Normal\r\npossui uma caracterísitca bastante interessante. Se aplicarmos uma\r\ntransformação linear numa variável normalmente distribuída, a nova\r\nvariável continua sendo normalmente distribuída, porém com diferentes\r\nvalores para os parâmetros da distribuição.\r\nUma transformação bastante útil é aquela em que a variável é\r\ntransformada numa variável normal-padrão, usualmente representada pela\r\nletra \\(Z\\). A variável normal-padrão\r\n\\(Z\\) possui média zero e variância\r\nunitária, \\(Z \\sim N(0,1)\\). Qualquer\r\nvariável que possui distribuição Normal pode ser transformada numa\r\nvariável normal-padrão, bastando subtrair sua média e dividir pelo seu\r\ndesvio-padrão,\r\n\\[\r\nZ = \\frac{Y-\\mu_Y}{\\sigma_Y}\\sim N(0,1)\r\n\\]\r\nEssa transformação é bastate útil aqui, pois utilizaremos o quantil\r\nda variável normal-padrão, \\(Z_p\\),\r\npara escrever o quantil de \\(Y\\), \\(Y_p\\), e também o quantil de cheia, \\(Q_p\\).\r\nQuantil de uma variável aleatória, para quem não se lembra, é o valor\r\nda variável associado a uma dada probabilidade de não-excedência. Por\r\nexemplo, por definição, a probabilidade da variável aleatória \\(X\\) ser menor ou igual ao quantil \\(x_p\\) é igual a p,\r\n\\[\r\nP(X\\le x_p)=p\r\n\\] Portanto, a probabilidade da variável normal-padrão, \\(Z\\), ser menor do que os quantis \\(Z_{0.10}\\), \\(Z_{0.50}\\) e \\(Z_{0.90}\\) é, respectivamente, 0.10, 0.50 e\r\n0.90.\r\nComo \\(Z = (Y-\\mu_Y)/\\sigma_Y\\),\r\npodemos dizer que \\(Z_p =\r\n(Y_p-\\mu_Y)/\\sigma_Y\\), de forma que\r\n\\[\r\nY_p = \\mu_Y + Z_p\\sigma_Y\r\n\\] E como \\(Y=ln(Q)\\), podemos\r\nafirmar que\r\n\\[\r\nQ_p = exp(\\mu_Y + Z_p\\sigma_Y)\r\n\\] em que \\(Q_p\\) é o quantil\r\npopulacional da variável aleatória \\(Q\\), que representa as vazões máximas\r\nanuais. Da mesma for que \\(\\mu_y\\) e\r\n\\(\\sigma_Y\\) são desconhecidos, \\(Q_p\\) também é. A única maneira de estimar\r\n\\(Q_p\\) é por meio das estimativas de\r\n\\(\\mu_Y\\) e de \\(\\sigma_Y\\).\r\nMétodo de ajuste\r\nExistem diversos métodos para ajustar uma distribuição teórica de\r\nprobabilidades aos dados que se tem em mãos. Para o caso da distribuição\r\nlognormal com 2 parâmetros, sabe-se que uma forma eficiente de estimar\r\nos parâmetros \\(\\mu_Y\\) e \\(\\sigma_Y^2\\) é por meio do método dos\r\nmomentos, que será explicado na sequência.\r\nCom base numa série de vazões máximas anuais \\(\\{Q_1,Q_2,\\ldots,Q_n\\}\\), determinamos uma\r\nnova série com base no logarítmos da série original, \\(Y = \\{Y_1,Y_2,\\ldots,Y_n\\}\\).\r\nEm seguida, aplicamos o métodos dos momentos para estimar \\(\\mu_Y,\\sigma_Y^2\\), o que consiste em\r\nigualar esses parâmetros aos seus valores amostrias, ou seja,\r\n\\[\r\n\\hat{\\mu}_Y = \\bar{Y} = \\frac{\\sum_1^n y_i}{n}\r\n\\] e\r\n\\[\r\n\\hat{\\sigma}_Y^2 = \\frac{\\sum_{i=1}^n (y_i - \\bar{Y})^2}{n-1}\r\n\\] Vale notar mais uma vez que \\(\\hat{\\mu}_Y\\) e \\(\\hat{\\sigma}_Y^2\\) possuem um acento\r\ncircunflexo para indicar que eles são os estimadores amostrais dos\r\nparâmetros populacionais \\(\\mu_Y\\) e\r\n\\(\\sigma_Y^2\\).\r\nCom os valores de \\(\\hat{\\mu}_Y\\) e\r\n\\(\\hat{\\sigma}_Y^2\\), podemos estimar\r\nos quantis de \\(Y\\) e de \\(Q\\),\r\n\\[\r\n\\hat{Y}_p = \\hat{\\mu}_Y + Z_p\\hat{\\sigma}_Y\r\n\\] e\r\n\\[\r\n\\hat{Q}_p = exp(\\hat{\\mu}_Y + Z_p\\hat{\\sigma}_Y)\r\n\\]\r\nAjuste da\r\nlognormal e estimativa dos quantis\r\nEntão, vamos ao que interessa. Temos basicamente que realizar três\r\netapas para determinar os quantis de cheia com base na distribuição\r\nlognormal,\r\nConstruir a série \\(Y =\r\nln(Q)=\\{Y_1,Y_2,\\ldots,Q_n\\}\\)\r\nEstimar os parâmetros \\(\\mu_y\\) e\r\n\\(\\sigma_Y^2\\) por meio dos estimadores\r\n\\(\\hat{\\mu}_Y\\) e \\(\\hat{\\sigma}_Y^2\\)\r\nEstimar os quantis de cheia, \\(Q_p\\), por meio do estimador \\(\\hat{Q}_p = exp(\\hat{\\mu}_Y +\r\nZ_p\\hat{\\sigma}_Y)\\)\r\nO código para realizar esse ajuste segue abaixo,\r\n\r\n\r\n# Determinar a nova série Y = ln(Q)\r\nQ_max_ord$Y <- log(Q_max_ord$maxima)\r\n\r\n# Estimar os parâmetros da distribuição Normal, sabendo que Y ~ N(mu_y,sigma2_Y)\r\nmu_Y_hat <- mean(Q_max_ord$Y)\r\nsigma2_hat <- var(Q_max_ord$Y)\r\n\r\n# Estimar os quantis de Y e de Q\r\np <- seq(from = 0.01,to = 0.99,by = 0.01)     # define valores de p que serão empregados para os quantis\r\nTr <- 1/(1-p)                                 # Calcula os tempos de recorrência para cada valro de p\r\nz_p <- qnorm(p, 0, 1)                         # quantil da normal-padrão\r\ny_p_hat <- mu_Y_hat + z_p*sqrt(sigma2_hat)    # estimativa do quantil de Y\r\nq_p_hat <- exp(y_p_hat)                       # estimativa do quantil de Q\r\n\r\n# Criação de um dataframe com os quantis de cheia\r\nQuantis_Q <- data.frame(q_p_hat,Tr)\r\n\r\n\r\nPodemos dar uma espiada no dataframe que contém os quantis de cheia\r\nutilizando a função head(dataframe.name),\r\n\r\n\r\nhead(Quantis_Q)\r\n\r\n   q_p_hat       Tr\r\n1 3.603989 1.010101\r\n2 4.101790 1.020408\r\n3 4.452708 1.030928\r\n4 4.736340 1.041667\r\n5 4.980326 1.052632\r\n6 5.197874 1.063830\r\n\r\nPodemos perceber que os seis primeiros valores dos quantis estimados\r\nnão são tão interessantes, pois eles estão associados a tempos de\r\nrecorrência muito baixos. Existe uma outra função no função no\r\nR que permite espiar a parte final do dataframe, ao invés\r\nda parte inicial. Essa função é chamada de\r\ntail(dataframe.name).\r\n\r\n\r\ntail(Quantis_Q,5)\r\n\r\n    q_p_hat        Tr\r\n95 23.73313  20.00000\r\n96 24.95571  25.00000\r\n97 26.54536  33.33333\r\n98 28.81638  50.00000\r\n99 32.79664 100.00000\r\n\r\nO número 5 no código acima serve para especificar\r\nquantas linhas eu estou interessado em ver.\r\nFInalizamos esta parte da análise com a plotagem dos quantis de\r\ncheias estimados com base na distribuição lognormal,\r\n\r\n\r\nplot(Q_max_ord$Tr,Q_max_ord$maxima,type = \"p\", pch = 19,cex = 1.5,col = \"blue\",\r\n     log = \"x\",main = \"Curva de frequência de cheias - 60435000\",\r\n     xlab = \"Tr (anos)\",ylab = \"Q_max (m3/s)\",\r\n     xlim = c(1, 100),   # X-axis limits\r\n     ylim = c(1, 50))\r\n\r\n# Adiciona a LN2\r\nlines(Quantis_Q$Tr,Quantis_Q$q_p_hat,\r\n      col = \"red\",\r\n      lwd = 2)\r\n\r\n# Adiciona grid horizontal\r\naxis(1, at = c(seq(1,10,by=1),seq(10,100,by=10),seq(200,1000,by=100)),\r\n     tck = 1, lty = 2, col = \"gray\")\r\n# Adiciona grid vertical\r\naxis(2, tck = 1, lty = 2, col = \"gray\")\r\n\r\n\r\n\r\nDescrição das incertezas\r\nQuando realizamos uma análise de frequência, além da estimativa dos\r\nquantis de cheia, precisamos ter uma ideia do quão confiantes estamos em\r\nrelação aos valores estimados. Sendo assim, precisamos entender como\r\ncalcular a precisão dessas estimativas.\r\nNormalmente, a maneira que empregamos para descrever as incertezas\r\nnas estimativas dos quantis de cheias é por meio de intervalos de\r\nconfiança. Neste nosso exercício aqui, aprenderemos como calcular\r\nintervalos de confiança associados à distribuição lognormal, que é a\r\ndistribuição que está sendo utilizada por nós para construir a curva de\r\nfrequência.\r\nExistem duas maneiras de se calcular intervalos de confiança para a\r\ndistribuição lognormal,\r\nintervalos aproximados\r\nintervalos exatos\r\nAqui aprenderemos como determinar intervalos de confiança aproximados\r\npara os quantis de cheia oriundos da distribuição lognormal.\r\nLógica\r\nda construção de intervalos de confiança aproximados\r\nSuponha que tenhamos uma estimador qualquer denominado \\(\\hat{W}_p\\). Estou usando a variável \\(W\\) apenas para reforçar a ideia de que não\r\nprecisa ser aquele estimador apresentado anteriormente, \\(\\hat{Q}_p = exp(\\hat{\\mu}_Y +\r\nZ_p\\hat{\\sigma}_Y)\\), embora possa ser.\r\nComo um estimador depende da amostra que se tem em mãos, ele é também\r\numa variável aleatória. E como toda variável aleatória, seu\r\ncomportamento pode se descrito por uma distribuição teórica de\r\nprobabilidades.\r\nPara a quase totalidade de possíveis estimadores, quando \\(n\\rightarrow \\infty\\), ou em outras\r\npalavras, à medida que a amostra aumenta e passa a ter um número bem\r\ngrande de observações, esses estimadores tendem a ter uma distribuição\r\nNormal.\r\nBem, se \\(\\hat{W}_p\\) possui\r\ndistribuição Normal e variância \\(V(\\hat{W}_p)\\), então nós já sabemos que se\r\nsubtrairmos seu valor esperado, \\(E[\\hat{W}_p]\\), e dividirmos o resulto pelo\r\nseu desvio-padrão, \\(\\sqrt{V(\\hat{W}_p)}\\), obteremos uma\r\nvariável Normal-padrão, usualmente denominada de \\(Z\\),\r\n\\[\r\nZ = \\frac{\\hat{W}_p-E[\\hat{W}_p]}{\\sqrt{V(\\hat{W}_p)}}\r\n\\] Como \\(Z\\sim N(0,1)\\),\r\npodemos afirmar que a probabilidade de \\(Z\\) estar entre os quantis \\(Z_{\\alpha/2}\\) e \\(Z_{1-\\alpha/2}\\) vale \\(1-\\alpha\\),\r\n\\[\r\nP(z_{\\alpha/2}\\le Z \\le z_{1-\\alpha/2}) = 1-\\alpha\r\n\\] Se substituirmos \\(Z\\) da\r\nequação acima pela equação anterior, obtemos\r\n\\[\r\nP\\Bigg(z_{\\alpha/2}\\le\r\n\\frac{\\hat{W}_p-E[\\hat{W}_p]}{\\sqrt{V(\\hat{W}_p)}} \\le\r\nz_{1-\\alpha/2}\\Bigg) = 1-\\alpha\r\n\\] Depois de algumas manipulações algébricas, e admitindo que o\r\nestimador \\(\\hat{W}_p\\) é\r\nnão-tendencioso, o que significa dizer que \\(E[\\hat{W}_p]=W_p\\), chegamos à afirmação\r\nabaixo,\r\n\\[\r\nP\\Bigg(\\hat{W}_p - z_{1-\\alpha/2}\\sqrt{V(\\hat{W}_p)} \\le W_p \\le\r\n\\hat{W}_p + z_{1-\\alpha/2}\\sqrt{V(\\hat{W}_p)}\\Bigg) = 1-\\alpha\r\n\\] que em bom português diz que a probabilidade do valor\r\npopulacional de \\(W_p\\) estar entre\r\nesses dois limites, \\(\\hat{W}_p \\pm\r\nz_{1-\\alpha/2}\\sqrt{V(\\hat{W}_p)}\\), é igual à \\(1-\\alpha\\). Quando \\(\\alpha = 0.05\\), essa probabilidade vale\r\n0.95.\r\nÉ essa afirmação matemática que nos permite estabelecer o intervalo\r\nde confiança de \\(100(1-\\alpha)\\%\\)\r\npara \\(W_p\\), apresentado abaixo,\r\n\\[\r\n\\Bigg[\\hat{W}_p - z_{1-\\alpha/2}\\sqrt{V(\\hat{W}_p)};\\hat{W}_p +\r\nz_{1-\\alpha/2}\\sqrt{V(\\hat{W}_p)}\\Bigg]\r\n\\]\r\nEstimadores\r\nintervalares para \\(Y_p\\) e \\(Q_p\\)\r\nA expressão acima pode ser utilizada para construir o intervalo de\r\nconfiança aproximado de \\(Y_p=ln(Q_p)\\)\r\ne de \\(Q_p\\), sendo esse último o que\r\nde fato nos interessa.\r\nPrimeiro, constuímos o intervalo de confiança aproximado de \\(Y_p\\),\r\n\\[\r\n\\Bigg[\\hat{Y}_p - z_{1-\\alpha/2}\\sqrt{V(\\hat{Y}_p)};\\hat{Y}_p +\r\nz_{1-\\alpha/2}\\sqrt{V(\\hat{Y}_p)}\\Bigg]\r\n\\]\r\nMas veja que embora tenhamos definido quem é \\(V(\\hat{Y}_p)\\), ainda não comentamos como\r\npodemos calcular essa grandeza, e sem ela não temos como determinar, de\r\nfato, o intervalo de confiança.\r\nEste não é um curso de estatística, mas sim de R\r\naplicado à Hidrologia. De todo modo, deixarei aqui uma breve explicação\r\nde como obter \\(V(\\hat{Y}_p)\\) para\r\naqueles interessados nos detalhes da metodologia,\r\n\\[\r\n\\begin{align}\r\nV(\\hat{Y}_p) &= V(\\hat{\\mu}_y + z_p\\hat{\\sigma}_Y)\\\\\r\n             &= V(\\hat{\\mu}_y) + V(z_p\\hat{\\sigma}_Y)\\\\\r\n             &= V(\\hat{\\mu}_y) + z_p^2V(\\hat{\\sigma}_Y)\\\\\r\n             &= \\frac{\\hat{\\sigma}_Y^2}{n} + z_p^2V(\\hat{\\sigma}_Y)\r\n\\end{align}\r\n\\]\r\nPara finalmente encontrar uma expressão para \\(V(\\hat{Y}_p)\\), precisamos ainda entender\r\ncomo determinar \\(V(\\hat{\\sigma}_Y)\\).\r\nPara isso, recorremos ao trabalho de Ahn & Fessler (2003), que nos\r\nmostraram que \\(V(\\sigma_Y)\\approx\r\n\\hat{\\sigma}_Y^2/(2n)\\), o que resulta na seguinte expressão para\r\n\\(V(\\hat{Y}_p)\\),\r\n\\[\r\nV(\\hat{Y}_p) \\approx\r\n\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_p^2\\Bigg)\r\n\\]\r\nDessa forma, o intervalo de confiança de \\(100(1-\\alpha)\\%\\) aproximado para \\(Y_p\\) pode ser descrito como\r\n\\[\r\n\\Bigg[\\hat{Y}_p -\r\nz_{1-\\alpha/2}\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_p^2\\Bigg)};\\hat{Y}_p\r\n+\r\nz_{1-\\alpha/2}\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_p^2\\Bigg)}\\Bigg]\r\n\\]\r\nPara determinar o intervalo de confiança de \\(100(1-\\alpha)\\%\\) aproximado para \\(Q_p\\), basta exponenciar o intervalo\r\nacima,\r\n\\[\r\n\\begin{align}\r\nIC_{(1-\\alpha)}(Q_p) &= exp\\Bigg[\\hat{Y}_p \\pm\r\nz_{1-\\alpha/2}\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_p^2\\Bigg)}\\Bigg]\\\\\r\n               &= exp\\Bigg[(\\hat{\\mu}_Y+z_p\\hat{\\sigma}_y) \\pm\r\nz_{1-\\alpha/2}\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_p^2\\Bigg)}\\Bigg]\r\n\\end{align}\r\n\\]\r\nPor exemplo, suponha que queiramos estabelecer o intervalo de\r\nconfiança de 95% para o quantil \\(Q_{99}\\), equivalente à cheia de 100 anos\r\nde recorrência. Nesse caso, \\(\\alpha =\r\n0.05\\) e \\(p=0.99\\), o que leva\r\nao seguinte intervalo de confiança,\r\n\\[\r\n\\begin{align}\r\nIC_{.95}(Q_{0.99}) &= exp\\Bigg[(\\hat{\\mu}_Y+z_{.99}\\hat{\\sigma}_y)\r\n\\pm\r\nz_{.975}\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}Z_{.99}^2\\Bigg)}\\Bigg]\\\\\r\n                    &=exp\\Bigg[(\\hat{\\mu}_Y+2.326\\hat{\\sigma}_y) \\pm\r\n1.96\\sqrt{\\frac{\\hat{\\sigma}_Y^2}{n}\\Bigg(1+\\frac{1}{2}2.326^2\\Bigg)}\\Bigg]\r\n\\end{align}\r\n\\] As linhas de código abaixo permitem calcular os limites\r\ninferior e superior do intervalo de confiança aproximado para os quantis\r\nda distribuição lognornal,\r\n\r\n\r\nalpha <- 0.05\r\nvar_yp <- sigma2_hat/nrow(Q_max_ord)*(1 + z_p^2/2)\r\n\r\nlower_IC <- exp((mu_Y_hat + z_p*sqrt(sigma2_hat)) - qnorm(1-alpha/2,0,1)*sqrt(var_yp))\r\nupper_IC <- exp((mu_Y_hat + z_p*sqrt(sigma2_hat)) + qnorm(1-alpha/2,0,1)*sqrt(var_yp))\r\n\r\n\r\nPlotagem final da curva\r\nde frequência\r\nPodemos agora terminar a Figura com a nossa curva de frequência de\r\ncheias completa, incluindo os intervalor de confiança de \\(95\\%\\) representados com a linha\r\ntracejada.\r\n\r\n\r\nplot(Q_max_ord$Tr,Q_max_ord$maxima,type = \"p\",           # plota apenas pontos\r\n     pch = 19,col = \"blue\", cex = 1.5,                   # círculos azuis de tamanho 1.5 \r\n     log = \"x\",                                          # escala logaritmica no eixo-x\r\n     main = \"Curva de frequência de cheias - 60435000\",  # título \r\n     xlab = \"Tr (anos)\",ylab = \"Q_max (m3/s)\",           # nome dos eixos\r\n     xlim = c(1, 100),                                   # limites od eixo-x              \r\n     ylim = c(1, 50))                                    # limites do eixo-y\r\n\r\n# Adiciona a LN2\r\nlines(Quantis_Q$Tr,Quantis_Q$q_p_hat,\r\n      col = \"red\",\r\n      lwd = 2)\r\n\r\n# Adiciona IC\r\nlines(Quantis_Q$Tr,lower_IC,\r\n      col = \"red\",lty = 2,\r\n      lwd = 2)\r\n\r\nlines(Quantis_Q$Tr,upper_IC,\r\n      col = \"red\",lty = 2,\r\n      lwd = 2)\r\n\r\n# Adiciona grid horizontal\r\naxis(1, at = c(seq(1,10,by=1),seq(10,100,by=10),seq(200,1000,by=100)),\r\n     tck = 1, lty = 2, col = \"gray\")\r\n# Adiciona grid vertical\r\naxis(2, tck = 1, lty = 2, col = \"gray\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2022-09-03T11:34:07-03:00"
    },
    {
      "path": "get_data.html",
      "title": "Obtenção de dados hidrológicos na web",
      "description": "Conceitos básicos",
      "author": [],
      "contents": "\r\n\r\nContents\r\nRepositório de dados\r\nObtenção de dados\r\n“tradicional”\r\nObtenção via webservice\r\nLista das Estações\r\nTelemétricas da ANA\r\nDados Hidrometeorológicos da\r\nANA\r\nSérie\r\nHistórica\r\n\r\nSalvar\r\narquivos\r\nSalvar um arquivo único\r\nSalvar em um\r\nloop\r\n\r\n\r\nRepositório de dados\r\nExistem inúmeros repositórios contendo dados hidrológicos no mundo e\r\nno Brasil. Alguns exemplos são:\r\nHidroWeb da ANA;\r\nSéries históricas do ONS;\r\nDados do CPRM;\r\nDados do INMET.\r\nObtenção de dados\r\n“tradicional”\r\n<<<<<<< HEAD Uma maneira de obter dados\r\nhidrológicos é simplesmente acessando de algum site oficial. Geralmente,\r\no arquivo obtido baixado está no formato .csv,\r\n.txt ou .xls (excel) - esse último sendo menos\r\ncomum. No próprio portal da ANA tem a opção de baixar os dados\r\ndiretamente se souber a estação em questão ou utilizando um mapa\r\ndinâmico. Fazemos o exemplo abaixo para a estação 60435000. Ao baixar o\r\narquivo, é importante entender como ele está salvo, para isso podemos\r\nabrir o arquivo pelo bloco de notas por exemplo. O arquivo em questão é\r\nmostrado na figura abaixo ======= Uma maneira de obter dados é\r\nsimplesmente baixando eles de algum site oficial. Geralmente o arquivo\r\nbaixado está no formato .csv, .txt ou\r\n.xls (excel) - esse último sendo menos comum. No próprio\r\nportal da ANA tem a opção de baixar os dados diretamente se souber a\r\nestação em questão (https://www.snirh.gov.br/hidroweb/serieshistoricas) ou\r\nutilizando um mapa dinâmico (https://www.snirh.gov.br/hidroweb/mapa). Fazemos o\r\nexemplo abaixo para a estação 60435000. Ao baixar o arquivo, é\r\nimportante entender como ele está salvo, para isso podemos abrir o\r\narquivo pelo bloco de notas por exemplo. O arquivo em questão é mostrado\r\nna figura abaixo >>>>>>>\r\n2aa96fc38fa716a70fee28c186be23697f6320d1\r\n\r\n\r\n\r\nÉ possível perceber alguns detalhes importantes. As primeiras 13\r\nlinhas contém informações sobre o sistema em sí e a estação, mas os\r\ndados medidos começam de fato na linha 14. O separador de cada coluna é\r\num “;” e os decimais são separados por “,”.\r\nAgora já temos as informações necessárias para acessar esses dados pelo\r\nR. Usamos aqui a função read.table(),\r\ntambém é possível utilizar a função read.csv(), ambas fazem\r\na mesma coisa, apenas alteram os argumentos pré definidos (que podem ser\r\ntrocados).\r\n\r\n\r\ndados_ANA <- read.table(file = \"dados/vazoes_T_60435000.txt\",\r\n                        skip = 13,\r\n                        header = T,\r\n                        sep = \";\",\r\n                        dec = \",\")\r\n\r\n\r\nAgora podemos ver quais colunas existem nesse dataframe dentro do\r\npróprio R e tentar entender ele melhor também!\r\n\r\n\r\ncolnames(dados_ANA)\r\n\r\n [1] \"EstacaoCodigo\"        \"NivelConsistencia\"   \r\n [3] \"Data\"                 \"Hora\"                \r\n [5] \"MediaDiaria\"          \"MetodoObtencaoVazoes\"\r\n [7] \"Maxima\"               \"Minima\"              \r\n [9] \"Media\"                \"DiaMaxima\"           \r\n[11] \"DiaMinima\"            \"MaximaStatus\"        \r\n[13] \"MinimaStatus\"         \"MediaStatus\"         \r\n[15] \"MediaAnual\"           \"MediaAnualStatus\"    \r\n[17] \"Vazao01\"              \"Vazao02\"             \r\n[19] \"Vazao03\"              \"Vazao04\"             \r\n[21] \"Vazao05\"              \"Vazao06\"             \r\n[23] \"Vazao07\"              \"Vazao08\"             \r\n[25] \"Vazao09\"              \"Vazao10\"             \r\n[27] \"Vazao11\"              \"Vazao12\"             \r\n[29] \"Vazao13\"              \"Vazao14\"             \r\n[31] \"Vazao15\"              \"Vazao16\"             \r\n[33] \"Vazao17\"              \"Vazao18\"             \r\n[35] \"Vazao19\"              \"Vazao20\"             \r\n[37] \"Vazao21\"              \"Vazao22\"             \r\n[39] \"Vazao23\"              \"Vazao24\"             \r\n[41] \"Vazao25\"              \"Vazao26\"             \r\n[43] \"Vazao27\"              \"Vazao28\"             \r\n[45] \"Vazao29\"              \"Vazao30\"             \r\n[47] \"Vazao31\"              \"Vazao01Status\"       \r\n[49] \"Vazao02Status\"        \"Vazao03Status\"       \r\n[51] \"Vazao04Status\"        \"Vazao05Status\"       \r\n[53] \"Vazao06Status\"        \"Vazao07Status\"       \r\n[55] \"Vazao08Status\"        \"Vazao09Status\"       \r\n[57] \"Vazao10Status\"        \"Vazao11Status\"       \r\n[59] \"Vazao12Status\"        \"Vazao13Status\"       \r\n[61] \"Vazao14Status\"        \"Vazao15Status\"       \r\n[63] \"Vazao16Status\"        \"Vazao17Status\"       \r\n[65] \"Vazao18Status\"        \"Vazao19Status\"       \r\n[67] \"Vazao20Status\"        \"Vazao21Status\"       \r\n[69] \"Vazao22Status\"        \"Vazao23Status\"       \r\n[71] \"Vazao24Status\"        \"Vazao25Status\"       \r\n[73] \"Vazao26Status\"        \"Vazao27Status\"       \r\n[75] \"Vazao28Status\"        \"Vazao29Status\"       \r\n[77] \"Vazao30Status\"        \"Vazao31Status\"       \r\n[79] \"X\"                   \r\n\r\nA seguir puxaremos o mesmo dado porém diretamente da internet,\r\nutilizando o que chamamos de webservice. Isso facilita muito a\r\ncriação de códigos mais automatizados em que não é necessário ficar\r\nbaixando os dados um a um.\r\nObtenção via webservice\r\nSer capaz de obter informações hidrológicas de forma gratuita\r\ndiretamente da internet, algo conhecido como “webscraping”, representa\r\num ganho significativo de eficiência no desenvolvimento de estudos e\r\nprojetos de hidrologia, recursos hídricos, e áreas afins.\r\nEssa possibilidade vem se tornando cada vez mais comum nos dias de\r\nhoje. Por exemplo, a Agência Nacional de Águas e Saneamento Básico\r\n(ANA), o Operador Nacional do Sistema Elétrico (ONS), e outras\r\ninstituições no Brasil e no exterior disponibilizam alguns de seus dados\r\npor meio do chamado webservice.\r\nEm essência, o webservice é apenas um site que contém os dados.\r\nPorém, esses dados estão organizados de uma maneira bem específica, de\r\nforma que para que seja possível obtê-los de forma eficiente, é\r\nimprescindível que essa organização seja bem entedida. Aqui neste curso\r\nintrodutório, vamos focar nossas atividades no webservice da ANA, que se\r\nencontra disponível por meio do url http://telemetriaws1.ana.gov.br/ServiceANA.asmx.\r\nQuando acessamos esse endereço, somos levados para a página\r\nabaixo,\r\n\r\n\r\n\r\nSe dermos um zoom na figura, podemos verificar todas as informações\r\nque estão disponíveis no webservice, tais como “dados\r\nhidrometeorológicos”, “dados hidrometeorológicos gerais”, “lista de\r\nestações telemétricas”, “Cotas”, “inventário”, “rios”, “série\r\nhistórica”, entre outras.\r\nNesse mesmo site, pode-se acessar um arquivo em formato pdf com\r\ndetalhes sobre o sistema como um todo, e com o que se pode obter dentro\r\ndele http://telemetriaws1.ana.gov.br/Telemetria1ws.pdf! Esse\r\narquivo é essencial para entendermos como os dados estão disponíveis e\r\ncomo podemos acessá-los.\r\nEsse documento nos informa que os dados hidrológicos da ANA estão\r\ndisponibilizados no formato XML (“Extended Markup Language”), de forma\r\nque precisamos aprender como acessar e manipular as informações\r\ndisponibilizados nesse formato. Mas discutiremos apenas o básico neste\r\ncurso, sem nos profundarmos muito. Porém se você deseja saber mais sobre\r\nwebscraping e usufruir de várias de suas possibilidade, sugerimos que\r\nprocure se aprofundar mais nesse tema.\r\nPara acessar dados do tipo XML dentro do\r\nR, utilizamos um pacote já criado, chamado\r\nXML. Lembrando que caso não tenhamos instalado ele\r\nainda, precisamos o fazer com o install.packages(). Em\r\nseguida precisamos apenas carregar na seção utilizando\r\nlibrary() como escrito abaixo. Além desse pacote, também\r\nutilizaremos algumas partes do pacote lubridate para\r\ntrabalharmos com datas.\r\n\r\n\r\n#install.packages(\"XML\")\r\nlibrary(XML)\r\n\r\n#install.packages(\"lubridate\")\r\nlibrary(lubridate)\r\n\r\n\r\nLista das Estações\r\nTelemétricas da ANA\r\nComeçaremos nossas atividades acessando os dados das estações\r\ntelemétricas desse sistema. Pode-se perceber olhando para o próprio\r\nsite, que são necessários dois parâmetros para pesquisar as estações. O\r\nprimiero chama-se “statusEstacoes”, que pode ser 0, que significa\r\nestação ativa, ou 1, que representa estação em manutenção. O segundo\r\nparâmetro é chamado de “Origem”, podendo variar entre 0 e 5. Se olharmos\r\no arquivo em formato pdf mencioando acima, vamos ver que se deixarmos o\r\n“statusEstacoes” em branco, serão retornadas as informações de todas as\r\nestações do sistema, que é exatamente o que queremos agora.\r\nSendo assim, se colocarmos no nosso navegador o seguinte url: http://telemetriaws1.ana.gov.br/ServiceANA.asmx/ListaEstacoesTelemetricas?statusEstacoes=&origem=,\r\nteremos acesso ao arquivo XML com a informação de todas as estações\r\ntelemétricas.\r\n\r\n\r\n\r\nPara que tenhamos cesso a essas informações nesse mesmo formato no\r\nRStudio, teremos que fazer uso de um pacote chamado “XML”, que contém a\r\nfunção denominada xmlParse(). Essa função é capaz de ler um\r\narquivo do tipo XML e gerar uma estrutura no R similar\r\nao que aparece na imagem acima (formato de “árvore”). A função exige que\r\ninformemos um argumento obrigatório, que é o url a ser\r\nutilizado, e permite ainda que passemos um argumento opcional, que é a\r\ncodificação do arquivo (do inglês encoding). Usualmente no Brasil,\r\nutilizamos o “UTF-8” para poder utilizar nossos acentos (mas lembre-se\r\nque essa parte é um outro mundo no R e não entraremos com maiores\r\ndetalhamentos). Quando um pacote já está carregado dentro do\r\nR, não precisamos escrever ele antes da função - isso,\r\nporém, pode ser uma boa prática para deixar o código mais fácil de ler\r\n(uma vez que qualquer leitor entenderia que a funçção\r\nxmlParse() pertence ao pacote XML uma vez\r\nque está escrito XML:: antes da função!\r\n\r\n\r\nstatus_codigo <- \"\"\r\norigem_codigo <- \"\"\r\n\r\nurl_base <- paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/ListaEstacoesTelemetricas?\",\r\n                   \"statusEstacoes=\", status_codigo, \"&origem=\", origem_codigo)\r\nurl_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n\r\n\r\nOlha o nosso código um pouco. Percebe que invés de digitar\r\ndiretamente o url para acesso, quebramos ele em várias partes e juntamos\r\ncom a função paste0(). Fizemos isso para ficar mais fácil de mudar algo\r\ndepois. Caso quisermos utilizar outro valor em “statusEstacoes” ou em\r\n“Origem”, basta mudarmos os objetos criados e o resto do código continua\r\nigual! Ao chamar o url_parse no console, verá uma imagem similar ao site\r\nquando abrimos o url.\r\nPara puxar agora as informações dessas estações, precisamos entender\r\nmelhor o arquivo original no formato XML. De maneira resumida, arquivos\r\nno formato XML ou HTML possuem estruturas que são definidas entre “<\r\n>”. Ao mexer no url que nos dá todas as estações, percebe-se que\r\ntodos os dados de cada estação são precedidos por um elemento chamado\r\n“Table” (dentro do “<>”). Porém, queremos os nodes que estão\r\nassociados a esses “Tables” (tabelas). Para isso, samos a função\r\ngetNodeSet(). Com os argumentos dessa função sendo primeiro o objeto\r\ncriado no R depois de ter feito um xmlParse() e o segundo argumento\r\nsendo “//Table” (lembrar de colocar essas duas barras)\r\n\r\n\r\n\r\nA próxima etapa agora é transformar esse arquivo em algo que estamos\r\nmais acostumados a mexer dentro do R. Boas opções são dataframes e\r\nlistas. Como não aprendemos a mexer muito com listas, vamos transformar\r\nnosso objeto em um dataframe. Para isso utilizamos a função\r\nxmlToDataFrame().\r\n\r\n\r\nnodes_doc <- XML::getNodeSet(url_parse, \"//Table\")\r\ncadastro_estacoes <- XML::xmlToDataFrame(nodes = nodes_doc)\r\n\r\n\r\nAgora podemos fazer as manipulações que já aprendemos anteriormente\r\n(com dataframe ficou fácil!). Por exemplo, se quisermos selecionar\r\napenas as estações de Brasília, escrevemos o código abaixo. O\r\n“Municipio-UF” é apenas uma das colunas do dataframe, podemos filtrar\r\ncom base em qualquer outra também. Vemos então a estrutura desse\r\ndataframe criado, usando a função str(), e as primeiras 5\r\nlinhas delem usando a função head().\r\n\r\n\r\nestacoes_bsb <- dplyr::filter(cadastro_estacoes, `Municipio-UF` == \"BRASÍLIA-DF\")\r\nstr(estacoes_bsb)\r\n\r\n'data.frame':   48 obs. of  14 variables:\r\n $ NomeEstacao  : chr  \"ANA SEDE (COTA ONLINE)\" \"ANA SEDE - TELEMÉTRICA\" \"RIBEIRÃO PALMEIRAS\" \"SONHEM\" ...\r\n $ CodEstacao   : chr  \"01547032\" \"01547079\" \"20000950\" \"20001050\" ...\r\n $ Bacia        : chr  \"6\" \"6\" \"2\" \"2\" ...\r\n $ SubBacia     : chr  \"60\" \"60\" \"20\" \"20\" ...\r\n $ Operadora    : chr  \"00001 - ANA - Agência Nacional de Águas \" \"00001 - ANA - Agência Nacional de Águas \" \"00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\" \"00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\" ...\r\n $ Responsavel  : chr  \"00001 - ANA - Agência Nacional de Águas \" \"00001 - ANA - Agência Nacional de Águas \" \"00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\" \"00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\" ...\r\n $ Municipio-UF : chr  \"BRASÍLIA-DF\" \"BRASÍLIA-DF\" \"BRASÍLIA-DF\" \"BRASÍLIA-DF\" ...\r\n $ Latitude     : chr  \"-15.81805\" \"-15.81810\" \"-15.52810\" \"-15.52310\" ...\r\n $ Longitude    : chr  \"-47.94500\" \"-47.94500\" \"-47.74190\" \"-47.81580\" ...\r\n $ Altitude     : chr  \"1150.00\" \"1150.00\" \"0.00\" \"0.00\" ...\r\n $ CodRio       : chr  \"0\" \"0\" \"20003000\" \"20030000\" ...\r\n $ NomeRio      : chr  \"\" \"\" \"RIBEIRÃO PALMEIRAS\" \"RIO SONHEM\" ...\r\n $ Origem       : chr  \"CotaOnline\" \"RHN\" \"Setor de Saneamento\" \"Setor de Saneamento\" ...\r\n $ StatusEstacao: chr  \"Ativo\" \"Ativo\" \"Ativo\" \"Ativo\" ...\r\n\r\nhead(estacoes_bsb)\r\n\r\n             NomeEstacao CodEstacao Bacia SubBacia\r\n1 ANA SEDE (COTA ONLINE)   01547032     6       60\r\n2 ANA SEDE - TELEMÉTRICA   01547079     6       60\r\n3     RIBEIRÃO PALMEIRAS   20000950     2       20\r\n4                 SONHEM   20001050     2       20\r\n5      CONTAGEM - VC 201   20001200     2       20\r\n6    RIBEIRÃO SANTA RITA   42450050     4       42\r\n                                                         Operadora\r\n1                         00001 - ANA - Agência Nacional de Águas \r\n2                         00001 - ANA - Agência Nacional de Águas \r\n3 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n4 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n5 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n6 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n                                                       Responsavel\r\n1                         00001 - ANA - Agência Nacional de Águas \r\n2                         00001 - ANA - Agência Nacional de Águas \r\n3 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n4 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n5 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n6 00190 - ADASA-DF - Agência Reguladora de Águas e Saneamento - DF\r\n  Municipio-UF  Latitude Longitude Altitude   CodRio\r\n1  BRASÍLIA-DF -15.81805 -47.94500  1150.00        0\r\n2  BRASÍLIA-DF -15.81810 -47.94500  1150.00        0\r\n3  BRASÍLIA-DF -15.52810 -47.74190     0.00 20003000\r\n4  BRASÍLIA-DF -15.52310 -47.81580     0.00 20030000\r\n5  BRASÍLIA-DF -15.50080 -47.85420     0.00 20050000\r\n6  BRASÍLIA-DF -15.58560 -47.33330   870.00 42250100\r\n               NomeRio              Origem StatusEstacao\r\n1                               CotaOnline         Ativo\r\n2                                      RHN         Ativo\r\n3   RIBEIRÃO PALMEIRAS Setor de Saneamento         Ativo\r\n4           RIO SONHEM Setor de Saneamento         Ativo\r\n5 RIBEIRÃO DA CONTAGEM                 RHN         Ativo\r\n6  RIBEIRÃO SANTA RITA                 RHN         Ativo\r\n\r\nLembrando que isso tudo nos dá apenas a lista com informações sobre\r\nas estações telemétricas. Para de fato termos acesso aos dados dessas\r\nestações, precisamos acessar outro url e fazer mais alguns códigos!\r\nIdealmente, se a gente quiser ficar sempre puxando diferentes\r\ninformações e não ficar precisando rodar linha por linha de código,\r\npodemos juntar tudo isso em uma função. Para a nossa função, deixaremos\r\no processo um pouco melhor. Primeiro definiremos que a função precisa de\r\n3 parâmetros (o status da estação, a origem e qual Unidade Federativa do\r\nBrasil queremos). Após puxar os dados em XML e transformar tudo em um\r\ndataframe, fazemos aqui algo novo - criamos uma coluna chamada “UF”\r\ncontendo apenas as últimas duas letras do Município (isos porque no\r\narquivo original, as duas últimas letras são as siglas da UF).\r\n\r\n\r\nANA_info <- function(status_codigo = \"\",\r\n                     origem_codigo = \"\",\r\n                     UF_fun = \"DF\"){\r\n\r\n  # Essas etapas foram vistas anteriormente\r\n  url_base <- paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/ListaEstacoesTelemetricas?\",\r\n                     \"statusEstacoes=\", status_codigo,\r\n                     \"&origem=\", origem_codigo)\r\n  url_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n  nodes_doc <- XML::getNodeSet(url_parse, \"//Table\")\r\n  cadastro_estacoes <- XML::xmlToDataFrame(nodes = nodes_doc)\r\n  \r\n  # Aqui criamos uma coluna no dataframe apenas com nomes das UFs\r\n  cadastro_estacoes$UF <- substr(cadastro_estacoes$`Municipio-UF`,\r\n                                 nchar(cadastro_estacoes$`Municipio-UF`) - 1,\r\n                                 nchar(cadastro_estacoes$`Municipio-UF`))\r\n                                 \r\n  estacoes_UF <- dplyr::filter(cadastro_estacoes, `UF` == UF_fun)\r\n\r\n  return(estacoes_UF)\r\n}\r\n\r\n\r\nPodemos simplesmente testar essa função criada chamando a função e\r\natribuindo para um objeto qualquer (chamamos aqui de “teste”) seu\r\nresultado. Em seguida falamos para o R printar as colunas desse\r\ndataframe.\r\n\r\n\r\n# Testar a função feita!\r\nteste <- ANA_info()\r\ncolnames(teste)\r\n\r\n [1] \"NomeEstacao\"   \"CodEstacao\"    \"Bacia\"         \"SubBacia\"     \r\n [5] \"Operadora\"     \"Responsavel\"   \"Municipio-UF\"  \"Latitude\"     \r\n [9] \"Longitude\"     \"Altitude\"      \"CodRio\"        \"NomeRio\"      \r\n[13] \"Origem\"        \"StatusEstacao\" \"UF\"           \r\n\r\nDados Hidrometeorológicos da\r\nANA\r\nPara acessar os dados hidrometeorológicos nesse webservice, temos\r\noutro url: http://telemetriaws1.ana.gov.br/ServiceANA.asmx?op=DadosHidrometeorologicos.\r\nNele, vemos que são necessárias agora três parâmetros para fazermos uma\r\nbusca: o “codEstacao” (que a gente pegou na parte anterior!), a\r\n“dataInicio” e a “dataFim”. Do mesmo jeito de antes, vamos definir um\r\nobjeto para cada parâmetro e depois criar um url baseado nesses\r\nparâmetros. Em seguida fazemos um xmlParse() e pegamos as informações\r\ncontidas nos nodes com o getNodeSet(). Por último, transformamos isso em\r\num dataframe. Dessa vez, podemos fazer a função direto ja!\r\n\r\n\r\ndados_ANA <- function(cod_estacao = \"\",\r\n                      data_inicio = \"01/01/2020\",\r\n                      data_fim = Sys.Date()){\r\n\r\n  # Puxar dados do url e transformar em dataframe\r\n  url_base <- paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/DadosHidrometeorologicos?\",\r\n                     \"codEstacao=\", cod_estacao,\r\n                     \"&dataInicio=\", data_inicio,\r\n                     \"&dataFim=\", data_fim)\r\n  url_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n  node_doc <- XML::getNodeSet(url_parse, \"//DadosHidrometereologicos\")\r\n  dados_estacao <- XML::xmlToDataFrame(nodes = node_doc)\r\n  \r\n  return(dados_estacao)\r\n}\r\n\r\n\r\nA partir da função que criamos anteriormente, para puxar as\r\ninformações das estações, podemos ver os códigos de todas as estações.\r\nUm exemplo é a FAL, da própria UnB. Seu código é 60478482 - podemos usar\r\nele na nossa nova função “dados_ANA”. Para ver o que essa função criada\r\nretorna, podemos pedir ao R as primeiras 6 linhas desse dataframe.\r\n\r\n\r\ndados_FAL <- dados_ANA(cod_estacao = 60478482)\r\nhead(dados_FAL)\r\n\r\n  CodEstacao             DataHora Vazao Nivel Chuva\r\n1   60478482 2022-07-04 23:00:00        27.00  0.00\r\n2   60478482 2022-07-04 22:45:00        27.00  0.00\r\n3   60478482 2022-07-04 22:30:00        27.00  0.00\r\n4   60478482 2022-07-04 22:15:00        27.00  0.00\r\n5   60478482 2022-07-04 22:00:00        27.00  0.00\r\n6   60478482 2022-07-04 21:45:00        27.00  0.00\r\n\r\nPercebemos aqui um “problema”. A data e a hora estão na mesma coluna\r\ne idealmente queremos deixar em colunas separadas (uma contendo a data e\r\noutra contendo as horas). Então iremos adicionar dentro da nossa função,\r\nmais um comando para fazer essa separação. Um jeito simples (mas não o\r\núnico) de fazer isso é selecionando os primeiros 10 caracteres como\r\nsendo os de data e os últimos 8 como sendo de hora - porque a data\r\nsempre vai estar no formato “dia/mes/ano” e o horário em\r\n“hora:minuto:segundo”. Podemos também reorganizar as colunas do jeito\r\nque quisermos. Abaixo está essa nova função mais organizada.\r\n\r\n\r\ndados_ANA <- function(cod_estacao = \"\",\r\n                      data_inicio = \"01/01/2020\",\r\n                      data_fim = Sys.Date()){\r\n\r\n  # Puxar dados do url e transformar em dataframe\r\n  url_base <- paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/DadosHidrometeorologicos?\",\r\n                     \"codEstacao=\", cod_estacao,\r\n                     \"&dataInicio=\", data_inicio,\r\n                     \"&dataFim=\", data_fim)\r\n  url_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n  node_doc <- XML::getNodeSet(url_parse, \"//DadosHidrometereologicos\")\r\n  dados_estacao <- XML::xmlToDataFrame(nodes = node_doc)\r\n  \r\n  # Separar data e hora\r\n  dados_estacao$Data <- substr(dados_estacao$DataHora, 1, 10)\r\n  dados_estacao$Hora <- substr(dados_estacao$DataHora, 12, 19)\r\n\r\n  # Re-organizar a ordem das colunas do dataframe dados_estacao\r\n  dados_estacao <- dados_estacao[,c(1, 6, 7, 3, 4, 5)]\r\n  \r\n  return(dados_estacao)\r\n}\r\n\r\n\r\nChamamos novamente essa função (agora atualizada) para rodar a\r\nestação da FAL. Em seguida printamos no R apenas as primeiras 6 linhas\r\ndesse dataframe.\r\n\r\n\r\n# Rodar a função para a estação da FAL\r\ndados_FAL <- dados_ANA(cod_estacao = 60478482)\r\nhead(dados_FAL)\r\n\r\n  CodEstacao       Data     Hora Vazao Nivel Chuva\r\n1   60478482 2022-07-04 23:00:00       27.00  0.00\r\n2   60478482 2022-07-04 22:45:00       27.00  0.00\r\n3   60478482 2022-07-04 22:30:00       27.00  0.00\r\n4   60478482 2022-07-04 22:15:00       27.00  0.00\r\n5   60478482 2022-07-04 22:00:00       27.00  0.00\r\n6   60478482 2022-07-04 21:45:00       27.00  0.00\r\n\r\nAqui rodamos a função apenas para uma estação. Mas se quisermos rodar\r\npara várias estações, basta utilizar um loop (for) ou até mesmo a função\r\nlapply do R (mais rápido!).\r\nSérie Histórica\r\nOutro local do HidroWeb da ANA que possui dados hidrológicos\r\nrelevantes é na seção de série histórica, disponível online em:\r\nhttp://telemetriaws1.ana.gov.br/ServiceANA.asmx?op=HidroSerieHistorica.\r\nPara puxar esse arquivo dentro do R é possível fazer\r\nalgo similar ao feito acima. Nessa seção, porém, são necessários 5\r\nargumentos:\r\ncodEstacao (código da estação);\r\ndataInicio (primeira data em que se quer os\r\ndados);\r\ndataFim (última data em que se quer os dados);\r\ntipoDados (podendo ser cotas, 1, chuvas, 2, ou\r\nvazões, 3);\r\nnivelConsistencia (podendo ser Bruto, 1, ou\r\nconsistido, 2).\r\nPrimeiro então criamos objetos contendo essas informações necessárias\r\npara entrar no url da série histórica.\r\n\r\n\r\ncod_estacao <- 60435000\r\ndata_inicio <- \"01/01/1800\"\r\ndata_fim <- Sys.Date()\r\ntipo_dados <- 3\r\nnivel_consist <- 1\r\n\r\n\r\nEm seguida, esses objetos são utilizados para criar um url\r\npara podermos acessar os dados do HidroWeb. Após é feito o mesmo que a\r\ncima em outros portais dentro do portal da ANA, fazendo então um\r\nXML::xmlParse(), seguido por um\r\nXML::getNodeSet() e XML::xmlToDataFrame().\r\nAssim como anteriormente, faz-se também a separação da coluna de data em\r\nduas, uma contendo a data e outra contendo a hora. Na coluna de Data é\r\nfeita a transformação de character para Date de modo\r\nque possamos fazer algumas operações com ela depois.\r\nobs: Por algum motivo o hidroweb não está filtrando os dados pela\r\nconsistencia, sendo necessária essa etapa abaixo (um filtro).\r\n\r\n\r\n# Puxar dados do url e transformar em dataframe\r\nurl_base <-\r\n  paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/\",\r\n         \"HidroSerieHistorica?\",\r\n         \"codEstacao=\", cod_estacao,\r\n         \"&dataInicio=\", data_inicio,\r\n         \"&dataFim=\", data_fim,\r\n         \"&tipoDados=\", tipo_dados,\r\n         \"&nivelConsistencia=\", nivel_consist)\r\n         \r\nurl_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\nnode_doc <- XML::getNodeSet(url_parse, \"//SerieHistorica\")\r\ndados_estacao <- XML::xmlToDataFrame(nodes = node_doc)\r\n\r\n# Separar data e hora\r\ndados_estacao$Data <- as.Date(substr(dados_estacao$DataHora, 1, 10))\r\ndados_estacao$Hora <- substr(dados_estacao$DataHora, 12, 19)\r\n\r\n\r\nÉ interessante lembrar um pouco como funciona esse formato de datas\r\naqui. As datas podem vir de inúmeras formas diferentes de algum banco de\r\ndados. Elas podem vir com “dia - mês - ano”, com o ano podendo ser\r\nescrito com todos os dígitos (2022) ou apenas os últimos dois (22).\r\nOutra coisa que pode ser alterada é a ordem (“dia - mês - ano” ou “ano -\r\nmês - dia” ou qualquer variação desses três. Ainda podemos encontrar em\r\nbases de dados o mês escrito por extenso ou abreviado como\r\n“01/Jan/1990”. Isso sem contar com o separador dessas datass (“/”, “-”,\r\num espaço em branco…). Podemos definir isso dentro da função\r\nas.Date(), utilizando como argumento a seguinte\r\nconvenção:\r\n%Y para anos com quatro dígitos;\r\n%y para anos com dois dígitos;\r\n%d para os dias (dígitos de 1 a 31);\r\n%m para os meses (dígitos de 1 a 12);\r\n%b para meses no formato abreviado em inglês\r\n(Jan, Feb, …);\r\n%B para meses no formato por extenso em inglês\r\n(January, February, …).\r\nEssa função do R possui um argumento que irá ficar\r\ntentando diversos formatos diferentes e tomará como verdade o primeiro\r\nque não retornar valores NA - porém, para formatos específicos (e se já\r\nsabemos qual é), pode ser melhor já deixar isso explícito em seu\r\ncódigo.\r\n\r\n\r\nas.Date(\"2021-11-01\", format = \"%Y-%m-%d\")\r\n\r\n[1] \"2021-11-01\"\r\n\r\nas.Date(\"01/Jan/70\", format = \"%d/%b/%y\")\r\n\r\n[1] \"1970-01-01\"\r\n\r\nNesse arquivo temos a necessidade de uma nova etapa. Ao olhar um\r\npouco como os dados estão oganizados, percebemos que existem 78 colunas.\r\nAo invés dos dados de vazão estarem todos em uma mesma coluna, eles\r\nestão espaçados por coluna, contendo 1 mês completo para cada linha do\r\ndataframe. Isso é um pouco problemático, pois não podemos simplesmente\r\npuxar todas as colunas visto que cada mês vai ter datas diferentes\r\n(fevereiro podendo até mudar dependendo do ano bisexto). Para resolver\r\nisso, primeiro criamos um vetor/objeto contendo todas\r\nas datas desde o primeiro mês em questão, até o útimo dia do último\r\nmês.\r\n\r\n\r\ndatas_dia <- seq.Date(from = min(dados_estacao$Data),\r\n                      to = max(dados_estacao$Data) %m+% months(1) - 1,\r\n                      by = \"day\")\r\n\r\n\r\nÉ extremamente interessante notar duas coisas aqui. Primeiro, sempre\r\ntemos diferentes formas de fazer um código, isso vai variar muito com a\r\nlógica de cada programador. Acima utilizamos uma função feita do pacote\r\nlubridate para somar um mês a uma certa data. Porém,\r\npodemos fazer o mesmo sem utilizar pacotes adicionais. Apesar deles\r\najudarem, podem tornar a manutenção do seu código algo essencial - as\r\nvezes o pacote pode alterar funções com atualizações ou até mesmo\r\ntornarem algumas obsoletas! Abaixo então fazemos a mesma sequência de\r\noutra forma, e ao final comparamos se ambas são idênticas.\r\n\r\n\r\ndatas_i <- min(dados_estacao$Data)\r\ndatas_f <- seq.Date(max(dados_estacao$Data), by = \"month\", length.out = 2)[2] - 1\r\n\r\ndatas_dia_v2 <- seq.Date(from = datas_i,\r\n                         to = datas_f,\r\n                         by = \"day\")\r\n                         \r\n#identical(datas_dia,datas_dia_V2)\r\n\r\n\r\nEm seguida fazemos um dataframe vazio, contendo 3 colunas. A primeira\r\npossui o código da estação sendo avaliado (como repete para todas as\r\nlinhas, podemos pegar apenas o primeiro valor). A segunda as datas, no\r\nformato character (útil para manipulação de texto), e a última\r\nsendo a coluna com os dados de vazão que está, por hora, vazio.\r\n\r\n\r\ntabela_final <- data.frame(Cod_estacao = dados_estacao$EstacaoCodigo[1],\r\n                           Data = as.character(datas_dia),\r\n                           Vazao = as.numeric(NA))\r\n\r\n\r\nAgora vamos preencher essa tabela com os dados de vazão do arquivo\r\nacessado. Uma maneira de fazer isso é fazendo um loop para cada\r\nlinha dessa tabela. Para cada linha, acessamos o dia em questão (o dia é\r\nsempre os últimos 2 caracteres da coluna data). Em seguida obtemos o mês\r\ne ano dessa data (os primeiros oito caracteres da coluna de data) e\r\nadicionamos o dia “-01” a eles (isso para sabermos em qual linha do\r\narquivo da ANA está o dado) - para isso criamos o objeto\r\nlinha_dado. Por último rodamos um ifelse() do\r\ntipo: se eu não tiver essa linha_dado, ou seja, se não houver\r\nmedição desse mês na ANA, eu coloco um NA (Not\r\nAvailable) na tabela final, caso o contrário é pego o valor na\r\nlinha definida e na coluna do dia + 15 (é somado 15 porque as colunas de\r\ndia começam a partir da coluna 16).\r\n\r\n\r\nfor(i in 1:nrow(tabela_final)){\r\n  # Dia em análise\r\n  dia <- as.numeric(substr(tabela_final$Data[i], 9, 10))\r\n    \r\n  # Mês e ano em análise\r\n  mes_ano <- as.Date(paste0(substr(tabela_final$Data[i], 1, 8), \"01\"))\r\n  \r\n  # Olhar a linha do mes e ano e escolher a coluna pelo dia + 15\r\n  linha_dado <- which(dados_estacao$Data == mes_ano)\r\n  \r\n  # Se não tiver o mês nos dados da estação, colocar valor NA\r\n  ifelse(length(linha_dado) == 0,\r\n         tabela_final$Vazao[i] <- NA,\r\n         tabela_final$Vazao[i] <-\r\n           as.numeric(dados_estacao[linha_dado, (dia + 15)]))\r\n    \r\n}\r\n\r\n\r\nNovamente, poderíamos fazer esse código acima utilizando pacotes para\r\n“facilitar a nossa vida” (o lubridate para mexer com datas).\r\nPor exemplo, poderíamos usar a função day() para puxar o\r\ndia de cada linha (usando a coluna no formato de Date) ao invés\r\nde fazer uma manipulação de texto. Aqui não vemos se são idênticos\r\nporque não são (a função day() retorna números inteiros),\r\nportanto utilizamos a função all.equal() que avalia, até\r\ncerto ponto, se são praticamente iguais.\r\n\r\n\r\nexemplo_dia <- as.numeric(substr(tabela_final$Data, 9, 10))\r\nexemplo_dia_v2 <- day(as.Date(tabela_final$Data))\r\n \r\nall.equal(exemplo_dia, exemplo_dia_v2)\r\n\r\n[1] TRUE\r\n\r\nPronto, agora podemos ver, por exemplo, as primeiras 5 medições que\r\nnão são NA\r\n\r\n\r\nhead(tabela_final[!is.na(tabela_final$Vazao),])\r\n\r\n   Cod_estacao       Data  Vazao\r\n12    60435000 1978-05-12 2.5342\r\n13    60435000 1978-05-13 2.5004\r\n14    60435000 1978-05-14 2.5004\r\n15    60435000 1978-05-15 2.4667\r\n16    60435000 1978-05-16 2.4667\r\n17    60435000 1978-05-17 2.5004\r\n\r\nAssim como feito nas outras etapas, podemos aqui fazer uma função\r\npara automatizar tudo que foi feito em várias etapas para deixar o\r\nprocesso mais automatizado e mais fácil quando quiser rodar o mesmo\r\nprocesso para outras estações.\r\n\r\n\r\ndados_serie_ANA <- function(cod_estacao = NA,\r\n                            data_inicio = \"01/01/1800\",\r\n                            data_fim = Sys.Date(),\r\n                            tipo_dados = 3,\r\n                            nivel_consist = 1){\r\n  \r\n  # Puxar dados do url e transformar em dataframe\r\n  url_base <-\r\n    paste0(\"http://telemetriaws1.ana.gov.br/ServiceANA.asmx/\",\r\n           \"HidroSerieHistorica?\",\r\n           \"codEstacao=\", cod_estacao,\r\n           \"&dataInicio=\", data_inicio,\r\n           \"&dataFim=\", data_fim,\r\n           \"&tipoDados=\", tipo_dados,\r\n           \"&nivelConsistencia=\", nivel_consist)\r\n  \r\n  url_parse <- XML::xmlParse(url_base, encoding = \"UTF-8\")\r\n  node_doc <- XML::getNodeSet(url_parse, \"//SerieHistorica\")\r\n  dados_estacao <- XML::xmlToDataFrame(nodes = node_doc)\r\n  \r\n  # Por algum motivo o hidroweb não está filtrando os dados pela consistencia\r\n  dados_estacao <- filter(dados_estacao, NivelConsistencia == nivel_consist)\r\n  \r\n  # Separar data e hora\r\n  dados_estacao$Data <- as.Date(substr(dados_estacao$DataHora, 1, 10))\r\n  dados_estacao$Hora <- substr(dados_estacao$DataHora, 12, 19)\r\n  \r\n  # Fazer um dataframe só com datas e valores de vazão\r\n  datas_dia <- seq.Date(from = min(dados_estacao$Data),\r\n                        to = max(dados_estacao$Data) %m+% months(1) - 1,\r\n                        by = \"day\")\r\n  tabela_final <- data.frame(Cod_estacao = dados_estacao$EstacaoCodigo[1],\r\n                             Data = as.character(datas_dia),\r\n                             Vazao = as.numeric(NA))\r\n  \r\n  \r\n  for(i in 1:nrow(tabela_final)){\r\n    dia <- as.numeric(substr(tabela_final$Data[i], 9, 10))\r\n    mes_ano <- as.Date(paste0(substr(tabela_final$Data[i], 1, 8), \"01\"))\r\n    linha_dado <- which(dados_estacao$Data == mes_ano)\r\n    ifelse(length(linha_dado) == 0,\r\n           tabela_final$Vazao[i] <- NA,\r\n           tabela_final$Vazao[i] <-\r\n             as.numeric(dados_estacao[linha_dado, (dia + 15)])) \r\n  } # fim do loop\r\n  return(tabela_final)\r\n}\r\n\r\n\r\nPara testar essa função basta utilizar a linha abaixo.\r\n\r\n\r\ndados_60435000 <- dados_serie_ANA(cod_estacao = 60435000)\r\ndados_60435000[10:15,]\r\n\r\n   Cod_estacao       Data  Vazao\r\n10    60435000 1978-05-10     NA\r\n11    60435000 1978-05-11     NA\r\n12    60435000 1978-05-12 2.5342\r\n13    60435000 1978-05-13 2.5004\r\n14    60435000 1978-05-14 2.5004\r\n15    60435000 1978-05-15 2.4667\r\n\r\nSalvar arquivos\r\nSalvar um arquivo único\r\nUma etapa tão importante quanto baixar os próprios dados que se\r\nprecisa é conseguir salvar eles antes ou depois de alguma manipulação\r\nfeita. Isso pode ser feito pelo R utilizando as funções\r\nwrite.table(), write.csv() ou variações delas\r\n- da mesma forma que haviam variações em read.table()\r\nread.csv().\r\nUma boa prática é deixar todos os argumentos mais importantes\r\nexplícitos, para que não tenha dúvidas de qua função usar ou como se irá\r\nsalvar. Assim deixa-se explícito abaixo o separador (tab), os\r\ndecimais (“.”), que não irá salvar o nome das linhas (elas não tem nome)\r\ne a codificação do arquivo (acentos e etc.).\r\n\r\n\r\nwrite.table(x = dados_60435000,\r\n            file = \"dados_60435000.txt\",\r\n            sep = \"\\t\",\r\n            dec = \".\",\r\n            row.names = FALSE,\r\n            fileEncoding = \"UTF-8\")\r\n\r\n\r\nSalvar em um loop\r\nA vantagem de utilizar funções e automatizações é fazer tudo que foi\r\nfeito acima para n estações, não apenas uma! Selecionamos já 4\r\nestações de uma mesma bacia para fazermos análises mais a frente. Os\r\ncódigos delas são:\r\n60435000 (feita);\r\n60436000;\r\n60436190;\r\n60443000 (última estação).\r\nPara fazer isso, podemos rodar a nossa funão criada,\r\ndados_serie_ANA(), para cada uma dessas estações. Depois de\r\nrodar a função, podemos rodar também o código para salvar elas! Note que\r\no i interno ao for() não precisa ser uma\r\nsequência, ele apenas informa quais os valores que i\r\nvai tomar a cada iteração. Na hora de salvar usamos a função\r\npaste0() pois o nome vai variar com cada iteração.\r\n\r\n\r\nfor(i in c(60435000, 60436000, 60436190, 60443000)){\r\n  dados_proxy <- dados_serie_ANA(i)\r\n  \r\n  write.table(x = dados_proxy,\r\n              file = paste0(i, \".txt\"),\r\n              sep = \"\\t\",\r\n              dec = \".\",\r\n              row.names = FALSE,\r\n              fileEncoding = \"UTF-8\")\r\n}\r\n\r\n\r\nAgora temos 4 arquivos, um para cada estação que definimos, salvos em\r\nformato .txt do jeito que queremos - o que tornará a próxima\r\netapa de manipulação muito mais fácil. Ao invés de termos um arquivo\r\npara cada estação com 78 colunas e as vazões podendo estar em diferentes\r\nlinhas e colunas temos uma tabela bem simples, com apenas 3 colunas. Uma\r\ncontendo o código da estação, outra a data e a última o valor de vazão\r\nobservado. Se quisermos fazer um loop para salvarmos os 4\r\narquivos em um mesmo data.frame também podemos o fazer. Segue abaixo\r\nesse último exemplo.\r\n\r\n\r\nestacoes <- c(60435000, 60436000, 60436190, 60443000)\r\n\r\nfor(i in 1:4){\r\n  # Qual estação estamos avaliando nesse loop específico\r\n  estacao_proxy <- estacoes[i]\r\n  \r\n  # Rodar a função criada\r\n  dados_proxy <- dados_serie_ANA(estacao_proxy)\r\n  \r\n  # Juntar as estações em uma só\r\n  if(i == 1) todas_estacoes <- dados_proxy\r\n  if(i != 1) todas_estacoes <- rbind(todas_estacoes, dados_proxy)\r\n}\r\n\r\nwrite.table(x = todas_estacoes,\r\n            file = \"todas_estacoes.txt\",\r\n            sep = \"\\t\",\r\n            dec = \".\",\r\n            row.names = FALSE,\r\n            fileEncoding = \"UTF-8\")\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-30T07:47:19-03:00"
    },
    {
      "path": "index.html",
      "title": "Obtenção, manipulação e análise de dados hidrológicos com R: uma introdução para iniciantes",
      "description": "Uma iniciativa do grupo [Água e Modelagem](https://aguaemodelagem.wordpress.com) para a Semana Universitária da Universidade de Brasília de 2022\n",
      "author": [
        {
          "name": "Dirceu S. Reis Jr.",
          "url": "https://github.com/DirceuReis"
        },
        {
          "name": "Francisco Eustáquio Oliveira e Silva",
          "url": "https://github.com/fcoeustaquio"
        },
        {
          "name": "Pedro Luis Borges Chaffe",
          "url": "https://github.com/fcoeustaquio"
        },
        {
          "name": "Wilson dos Santos Fernandes",
          "url": "https://github.com/wsf-ehr"
        },
        {
          "name": "Thiago Lappicy",
          "url": "https://github.com/rich-iannone"
        },
        {
          "name": "Saulo AIres de Souza",
          "url": {}
        },
        {
          "name": "Luiz Felipe Pereira de Brito",
          "url": {}
        }
      ],
      "contents": "\r\n\r\nContents\r\nApresentação\r\nDatas e local do curso\r\nPróxima data\r\nSemana Universitária da UnB\r\nde 2022\r\n\r\n\r\nApresentação\r\nEste é um curso introdutório sobre a linguagem R para aqueles\r\ninteressados em realizar análises hidrológicas.\r\nO curso foi oferecido pela primeira vez muito recentemete, durante a\r\nSemana Universitária da\r\nUniversidade de Brasília, que ocorreu entre os dias 29/08 e 02/09 de\r\n2022.\r\nEste mesmo curso deve ser replicado mais vezes no futuro próximo. Os\r\nalunos qye venham a fazer este curso irão aprender como utilizar a\r\nlinguagem R para executar um conjunto de atividades que permitirão\r\nrealizar uma análise de frequência de cheias para uma estação\r\nfluviométrica, cujos dados serão automaticamente obtidos do webservice\r\nda Agência Nacional de Águas.\r\nAo final do curso, os alunos terão finalizado um estudo que permitirá\r\nrelacionar a magnitude das vazões máximas anuais com sua probabilidade\r\nde excedência, relação primoridal para dimensionameno de diversas\r\nestrutaras de engenharia, gestão do risco de cheias e para o\r\noredenamento do uso e ocupação do solo.\r\nEste curso é o primeiro de um conjunto maior de cursos que estão\r\nsendo elaborados pelos seguintes professores do blog Água e Modelagem,\r\napresentados em ordem alfabética:\r\nDirceu S. Reis Jr. (UnB)\r\nFrancisco Eustáquio (UFMG)\r\nPedro Chaffe (UFSC)\r\nWilson Fernandes (UFMG)\r\nDatas e local do curso\r\nPróxima data\r\nAssim que tivermos a data da próxima realização do curso, colocaremos\r\naqui neste site.\r\nSemana Universitária da UnB\r\nde 2022\r\nO curso será dado na Sala 5 do Laboratório Central de Computação\r\nCientífica da Faculdade de Tecnologia da Universidade de Brasília (LCCC\r\nULEG-FT), que fica localizado no prédio da Unidade de Laboratórios de\r\nEnsino de Graduação da Faculdade de Tecnologia (ULEG/FT).\r\nO curso será dividido em 5 aulas de 2 horas cada, totalizando 10\r\nhoras. As aulas serão dadas nos seguintes horários:\r\n29/08 a 01/09 das 8h00 às 10h00\r\n02/09 das 12h00 às 14h00.\r\nInscriçõs\r\nAs inscrições poderão ser feitas entre os dias 01 e 28 de agosto por\r\neste link\r\nda Semana Universitária. Vale notar que este curso só estará\r\ndisponível na lista fornecido pelo link acima a partir do dia 01 de\r\nagosto.\r\nComo o número de vagas é limitado, recomenda-se que a inscrição seja\r\nfeita o quanto antes.\r\nAntes do curso\r\nOs computadores da sala onde será ministrado o curso já tem os\r\nprogramas instalados. De todo modo, para que seja possível trabalhar\r\nfora do horario do curso, sugerimos que os participantes tenham os\r\nmesmos programas instalados em seu própio computador.\r\nSugerimos instalar tanto o R quanto o\r\nRStudio. Para isso, entre na aula Conceitos\r\nBásicos em R e siga as instruções de instalação.\r\nCódigos em R das\r\nauals dadas\r\nOs códigos criados durante as aulas serão em breve disponibilizados\r\naqui.\r\n\r\n\r\n\r\n",
      "last_modified": "2022-09-03T11:45:57-03:00"
    }
  ],
  "collections": []
}
